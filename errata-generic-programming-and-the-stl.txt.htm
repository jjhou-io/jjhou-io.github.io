<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=big5">
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
<title>勘誤《泛型程式設計與 STL》</title>
</head>

<body>

<pre>本勘誤檔更新日期: 2005/01/07</pre>

<pre>《泛型程式設計與 STL》
碁峰, 2000</pre>

<pre>目前刷次: 2000/11 第一刷 印量 0001~2000
          2003/04 第二刷 印量 2001~2500</pre>

<pre>原著：Generic Programming and the STL, 
     by Matthew H. Austern
      Addison Wesley,1999</pre>

<pre><font color="#0000FF">●<a name="special-thanks">特別感謝</a>
</font>請容我在此特別感謝讀者 jaulueng（Jan-Lueng Su）先生。他為本書勘誤
做出了很大貢獻。看到他所列出的勘誤和意見，我一方面對他下的功夫感到
敬佩，一方面對自己的疏忽感到愧赧。寫譯這種手冊型、參考工具型的書籍，
是我最感「害怕」的工作。讀者看到那麼多筆誤（主要集中於 2003/02/20），
應該會大聲責罵我吧！面對這麼多筆誤，我是該被罵 :(</pre>

<p>　</p>

<pre>注意：以下按修正日期排序。</pre>

<pre>======================================================</pre>

<pre>書籍內容更正，有兩種作法，一是在網際網路上做個專屬勘誤
網頁，讓大家上去看。這是比較即時的作法。而更理想更負責
的作法是：不但有勘誤網頁，並且在新刷中予以更正 — 如果
有新刷的話 :)</pre>

<pre>不過，理想與現實之間需要一點協調。書籍的製作是這樣的，
製版與印刷時，是以檯（8 或 16 頁）為單位。因此，每換一
頁，同檯的各頁統統要換過。這便造成印製成本的大量增加。</pre>

<pre>以前，我從不考慮成本，只要我認為書籍內容有修改必要，即
使只是某個字詞用得不甚理想，我都會請出版社更新。出版社
也都全力配合（這一點讓我非常感謝）。</pre>

<pre>慢慢地，我的行事不再這麼霹靂，我覺得我多少也要站在出版
社的立場想想。所以我打算，如果是關係到對錯正誤的根本性
問題，我便一定在新刷修正。如果是易判別的錯別字或排版誤
失或用詞不很恰當…等等，我便先在勘誤網頁上明載，但不求
一定於新刷中更正。直到收集來的這類誤失較為密集了，才一
併於下一刷修正。</pre>

<pre>哪些是新刷已修正的，哪些是暫請讀者自行動手更改的，我會
在勘誤網頁（網址見書封底）上清楚說明。</pre>

<pre>這是個便宜法門，請讀者見諒。</pre>

<pre>書籍應該在出版前就詳細檢查，以完美之姿出現。但是完美很
難達到。對於下列大大小小輕重不等的誤失，我謹向讀者說抱
歉。</pre>

<pre>本檔歡迎廣為流傳，謝謝。</pre>

<pre>以下為更新記錄。如果您購買的是第 n 刷，請將以下第 n+1
刷之後的更新內容自行修正至書上。謝謝</pre>

<pre>======================================================</pre>

<pre>以下為第一刷更正（已修正於第二刷紙本）
（注意，Lm 表示第 m 行，L-n 表示倒數第 n 行）</pre>

<pre>■p.5  L-5（排版未留意）
原文：倒數第五行最後的 &quot;<font
color="#FF0000">???</font>&quot; 符號
更正：請拿掉
感謝：edward
日期：2000/12/03</pre>

<pre>■p.240  L-7（中譯本筆誤）
原文：class <font color="#FF0000">UnaryFunction</font>,
更正：class <font
color="#0000FF">OutputIterator</font>,
感謝：張振宇
日期：2001/01/18
</pre>

<pre>■p.240  L-4（中譯本筆誤）
原文：InputIterator2 first2 ,  <font
color="#FF0000">InputIterator2</font> last2 ,
更正：InputIterator2 first2 ,  <font
color="#0000FF">OutputIterator</font> result ,
感謝：張振宇
日期：2001/01/18
</pre>

<pre>■p.39  L4（中譯本筆誤）
原文：if (n &gt;= <font color="#FF0000">n</font>)
更正：if (n &gt;= <font
color="#0000FF">0</font>)
感謝：PG63 XWang
日期：2001/01/19
討論：我找出兩版 STL 源碼，卻發現其中有奇怪之處</pre>

<pre>1. RogueWave STL（附於 Inprise Borland C++Builder）的 iterator.cc 是</pre>

<pre>template &lt;class BidirectionalIterator, class Distance&gt;
  void __advance (BidirectionalIterator&amp; i, Distance n,
                  bidirectional_iterator_tag)
  {
    if (n &gt;= 1)          // 注意這裡！
      while (n--) ++i;
    else
      while (n++) --i;
  }</pre>

<pre>2. SGI STL（附於 CYGNUS G++）的 stl_iterator.h 是</pre>

<pre>template &lt;class Bidirectionalterator, class Distance&gt;
inline void __advance(BidirectionalIteator&amp; i, Distane n,
                      bidirectional_iterator_tag)
{
  if (n &gt;= 0)
    while (n--) ++i;
  else
    while (n++) --;
}</pre>

<pre>■p.ix  L-5 目錄（中譯本失誤）
原文：12.1 <font color="#FF0000">線性搜尋</font>
更正：12.1 <font
color="#0000FF">拷貝某個範圍（Copying Ranges）</font>
說明：這是翻譯過程中的不當處理結果，很抱歉。
感謝：jjhou
日期：2001/03/13</pre>

<pre>■p.233  L-5 大標題（中譯本失誤）
原文：12.1 <font color="#FF0000">線性搜尋</font>
更正：12.1 <font
color="#0000FF">拷貝某個範圍（Copying Ranges）</font>
說明：這是翻譯過程中的不當處理結果，很抱歉。
感謝：jjhou
日期：2001/03/13</pre>

<pre>■p.311  L11 （誤譯）
原文：如果 value 存在，那麼它傳回的 iterator 將指向 value 的<font
color="#FF0000">前</font>一位置...
更正：如果 value 存在，那麼它傳回的 iterator 將指向 value 的<font
color="#0000FF">下</font>一位置...
感謝：jjhou
日期：2001/03/19</pre>

<pre>■p.428  L1 （筆誤）
原文：15.8.5 u<font color="#FF0000">n</font>nary_negate
更正：15.8.5 unary_negate
感謝：jjhou
日期：2001/03/19</pre>

<pre>■p.433  L3 （中譯本失誤）
原文：如果 f <font color="#FF0000">和 g 都</font>是 Adaptable Binary Functions，...
更正：如果 f 是 Adaptable Binary Functions，...
感謝：jjhou
日期：2001/03/19</pre>

<pre>■p.321  L-2（中譯本失誤）
原文：假設某個元素在 [first1,last1) 出現<font
color="#FF0000">n</font>次，在 [first2,last2) 出現 <font color="#FF0000">m</font>次，
更正：假設某個元素在 [first1,last1) 出現<font
color="#0000FF">m</font>次，在 [first2,last2) 出現 <font color="#0000FF">n</font>次，
感謝：jjhou
日期：2001/05/28</pre>

<pre>■p.x  L-3（中譯本筆誤）
原文：12.10.1 accumlate
更正：12.10.1 accum<font
color="#0000FF">u</font>late
感謝：jjhou
日期：2001/05/30</pre>

<pre>■p.144 L9（中譯本失誤）
原文：a.<font color="#FF0000">front</font>()
更正：a.<font
color="#0000FF">back</font>()
感謝：cber
日期：2001/07/17</pre>

<pre>■p.132 L1（中譯本筆誤）
原文：Iequality
更正：I<font color="#0000FF">n</font>equality
感謝：cber
日期：2001/07/17</pre>

<pre>■p.147 L8（中譯本格式失誤）
原文：X() X a;
更正：X()
      X a;
感謝：cber
日期：2001/07/17</pre>

<pre>■p.367 L2（中譯本失誤）
原文：reverse_iterator&lt;<font color="#FF0000">T</font>&gt;
更正：reverse_iterator&lt;<font
color="#0000FF">Y</font>&gt;
感謝：cber
日期：2001/07/17</pre>

<pre>■p.128 L5（重新修潤）
原文：則這個Container的area將是某個常數值乘以container size再乘以sizeof(T)。
更正：則這個Container的area將是某個數值（Container本身所耗用的額外空間；
      可能隨container size變動）加上「container size和sizeof(T)的乘積」。
感謝：cber
日期：2001/07/17</pre>

<pre>■p.141 L6（中譯本筆誤）
原文：void insert(iterator p, size_type n, <font
color="#FF0000">const_value</font>&amp; t) {
更正：void insert(iterator p, size_type n, <font
color="#0000FF">const value_type</font>&amp; t) {
感謝：ccplusplus
日期：2002/02/15</pre>

<pre>■p.189 L3（中譯本筆誤）
原文：pointer allocator::allocate(size_type n, c<font
color="#FF0000">osn</font>t void* = 0)
更正：pointer allocator::allocate(size_type n, c<font
color="#0000FF">ons</font>t void* = 0)
感謝：ccplusplus
日期：2002/02/15</pre>

<pre>■p.191 L3（中譯本筆誤）
原文：standard 並不涵蓋 <font color="#FF0000">construct</font>
更正：standard 並不涵蓋 <font
color="#0000FF">destroy</font>
感謝：ccplusplus
日期：2002/02/15</pre>

<pre>■p.322 第二段（中譯本筆誤）
原文：<font color="#FF0000">請注意，includes 與 set_union (p.324) 很類似... ...的長度總和。</font>
更正：原書並無此段，是翻譯時剪貼失誤所致。非常非常抱歉。
感謝：ccplusplus
日期：2002/02/15</pre>

<pre>■p120, L15（英文版筆誤）
原文：y   型別 <font color="#FF0000">Y</font> 的 object
更正：y   型別 <font
color="#0000FF">X</font> 的 object
感謝：s892301
日期：2002/03/14</pre>

<pre>■p130,L4（中譯本筆誤）
原文：<font color="#FF0000">x</font> = b;
更正：<font
color="#0000FF">a</font> = b;
感謝：s892301
日期：2002/03/14</pre>

<pre>■p255,L5（中譯本筆誤）
原文：<font color="#FF0000">void</font>            remove_if(ForwardIterator first, ForwardIterator last,...
更正：<font
color="#0000FF">ForwardIterator</font> remove_if(ForwardIterator first, ForwardIterator last,...
感謝：bahamut
日期：2002/05/31</pre>

<pre>■p154,L17（中譯本處理錯誤）
原文：除了 Associative Container 所定義的算式外，<font
color="#FF0000">以下算式也必須有效：</font>
更正：除了 Associative Container 所定義的算式外，<font
color="#0000FF">沒有其他更多的了。</font>
感謝：jaulueng
日期：2002/06/01</pre>

<pre>■p189,L11（中譯本筆誤1, 原書值得斟酌1）
原文：等同於 new(<font
color="#FF0000">const </font>void*) p) T(x)
更正：等同於 new<font color="#0000FF">(</font>(void*) p) T(x)
討論：p 轉型為 (const void*) 之後，將成為一個 non-const pointer to const value，
      那麼就無法在該指標所指位置執行 construction 動作了。那可不妙。
      所以我認為不該有 const。如果轉型為 (void* const) 倒是可以（實驗證實）。
提示：請同時修改《STL源碼剖析》p44, L-10.
感謝：jaulueng
日期：2002/06/01</pre>

<pre>■p157,L5（中譯本筆誤）
原文：t  <font color="#FF0000">type</font>::value_type 的 object。
更正：t  <font
color="#0000FF">X</font>::value_type 的 object。
感謝：jaulueng
日期：2002/06/02</pre>

<pre>■p17,L-14（中譯本筆誤）
原文：concpt Input Iterator
更正：conc<font
color="#0000FF">e</font>pt Input Iterator
感謝：Ark Noah
日期：2002/07/24</pre>

<pre>■p56,L-18（中譯本筆誤）
原文：class un<font color="#FF0000">ra</font>y_negate
更正：class un<font
color="#0000FF">ar</font>y_negate
感謝：jianghg
日期：2003/02/11</pre>

<pre>■p60,L-1（中譯本筆誤）
原文：block 這個名稱是 Andre Koenig 建議的
更正：block 這個名稱是 Andre<font
color="#0000FF">w</font> Koenig 建議的
感謝：jianghg
日期：2003/02/18

■p54,L6（中譯本筆誤）
原文：4.2.3  相關型別（Assocated Types）
更正：4.2.3  相應型別（Assoc<font
color="#0000FF">i</font>ated Types）
感謝：jianghg
日期：2003/02/18

■p50,L-14,L-13（中譯本筆誤）
原文：is_even<font
color="#FF0000">t</font>
更正：is_even
感謝：jianghg
日期：2003/02/18</pre>

<pre>■p13,L7（中譯本筆誤）
原文：正如 Adrew Koenig [Koe89] 指出
更正：正如 A<font
color="#0000FF">n</font>drew Koenig [Koe89] 指出
感謝：jianghg
日期：2003/02/18</pre>

<pre>■p161,L-6（中譯本筆誤）
原文：<font color="#FF0000">type</font>::value_type
更正：<font
color="#0000FF">X</font>::value_type
感謝：jaulueng
日期：2003/02/20

■p176,L-10（中譯本筆誤，第一個小括弧誤為角括弧）
原文：pair::pair<font
color="#FF0000">&lt;</font>const pair&lt;U1, U2&gt;&amp; p)
更正：pair::pair<font
color="#0000FF">(</font>const pair&lt;U1, U2&gt;&amp; p)
感謝：jaulueng
日期：2003/02/20

■p178,L-8（英文版遺漏）
說明：本頁中下的 last_value() 函式本體結束前應該有一行 <font
color="#0000FF">return result;</font>
感謝：jaulueng
日期：2003/02/20

■p178,L-5（英文版筆誤）
原文：Bidirectional Iterators 或 <font
color="#FF0000">Forward</font> Iterators 所形成的 range 中
更正：Bidirectional Iterators 或 <font
color="#0000FF">Random Access</font> Iterators 所形成的 range 中
感謝：jaulueng
日期：2003/02/20

■p178,L-5（中譯本遺漏一個句點）
原文：我們有更好的方法來找尋最後一個元素
更正：我們有更好的方法來找尋最後一個元素<font
color="#0000FF">。</font>
感謝：jaulueng
日期：2003/02/20

■p188,L-3（中譯本筆誤）
原文：<font
color="#FF0000">Default constructor</font>
更正：<font color="#0000FF">destructor</font>
感謝：jaulueng
日期：2003/02/20

■p197,L15（補潤）
原文：引數 len 是欲獲得之緩衝區大小。
更正：引數 len 是欲獲得之緩衝區大小<font
color="#0000FF">（元素個數）</font>。
感謝：jaulueng
日期：2003/02/20

■p207,L1,L4（英文版筆誤）
原文：[first1, last1-(last2-first2)<font
color="#FF0000">)</font>
更正：[first1, last1-(last2-first2)<font color="#0000FF">]</font>
說明：假設 [first1,last1) 表示字串 &quot;abcde&quot;，[first2,last2) 表示字串 &quot;cde&quot;，
      則 [first1,last1-(last2-first2)) 將表示字串 &quot;ab&quot; 而非 &quot;abc&quot;，
      但其實 &quot;abc&quot; 才是正確的區間。所以應該使用「後閉」區間。
感謝：jaulueng
日期：2003/02/20

■p207,L9（中譯本筆誤 + 英文版筆誤）
原文：[first1, last-(last2-first2)<font
color="#FF0000">)</font>
更正：[first1, last<font color="#0000FF">1</font>-(last2-first2)<font
color="#0000FF">]</font>
說明：使用「後閉」區間之原因，同上一條勘誤
感謝：jaulueng
日期：2003/02/20

■p209 L-12,L-8,L-3（英文版筆誤）
原文：[first1, last1-(last2-first2)<font
color="#FF0000">)</font>
更正：[first1, last1-(last2-first2)<font color="#0000FF">]</font>
說明：同上
感謝：jaulueng
日期：2003/02/20

■p211,L-3,L-2, p212,L1（英文版筆誤）
原文：[first, last-count<font
color="#FF0000">)</font>
更正：[first, last-count<font color="#0000FF">]</font>
說明：同上
感謝：jaulueng
日期：2003/02/20

■p221,L-7（中譯本遺漏）
說明：請在本頁最下程式碼的第一行 int A2[]= ... 之前加上三行程式碼如下：
<font
color="#0000FF">      int main()
      {
         int A1[] = {3, 1, 4, 1, 5, 9, 3};</font>
感謝：jaulueng
日期：2003/02/20

■p226,L14（補潤）
原文：最多比較 2min
更正：最多比較 2<font
color="#0000FF"> * </font>min
感謝：jaulueng
日期：2003/02/20

■p233,L-6（中譯本筆誤）
原文：coping form
更正：cop<font
color="#0000FF">y</font>ing form
感謝：jaulueng
日期：2003/02/20

■p236,L8（補潤）
原文：對於<font
color="#FF0000">每個</font>從 0 到 last-first（不含）的整數 n，
更正：對於從 0 到 last-first（不含）的<font
color="#0000FF">每個</font>整數 n，
感謝：jaulueng
日期：2003/02/20

■p236,L9（中譯本筆誤）
原文：*(result-n-1) = *(<font
color="#FF0000">first</font>-n-1)
更正：*(result-n-1) = *(<font color="#0000FF">last</font>-n-1)
感謝：jaulueng
日期：2003/02/20

■p239,L-7（中譯本遺漏，最後少一個小括弧）
原文：[first2, first2+(last1-first1) 中相對的
更正：[first2, first2+(last1-first1)<font
color="#0000FF">)</font> 中相對的
感謝：jaulueng
日期：2003/02/20

■p242,L3（英文版筆誤）
原文：<font
color="#FF0000">Unary</font>Function
更正：<font color="#0000FF">Binary</font>Function
感謝：jaulueng
日期：2003/02/20

■p242,L-10（中譯本筆誤）
原文：transform 的為將與 copy 相同。
更正：transform 的<font
color="#0000FF">作</font>為將與 copy 相同。
感謝：jaulueng
日期：2003/02/20

■p246,L-7（修潤）
原文：可將 [first, last) 的元素複製<font
color="#FF0000">於</font>
更正：可將 [first, last) 的元素複製<font
color="#0000FF">到</font>
感謝：jaulueng
日期：2003/02/20

■p247,L13; p248,L-3（討論 replace_copy）
原文：result 不是 [first, last) 中的某個 iterator。
<font
color="#408080">建議：result 不是 [first+1, last) 中的某個 iterator。
討論：
若依照原文所述，則 replace_copy() 不能是 &quot;in-place&quot;，亦即 first 與 result 不能
指向同物。但根據《STL源碼剖析》一書 p359 可看出 first 與 result 可以相同，
並於 VC6 測試通過；所以或可修訂之。
然若要修訂，則 p246,L-6 的 &quot;[first, last) 不會被更動&quot; 一語建議稍加修潤。</font>

侯捷回覆：
謝謝您縝密的思考與前後觀照。&quot;[first,last) 不被更動&quot; 是 replace_copy 的前提（條件），
所以 &quot;result 不得在 [first,last) 之內&quot; 是正確的約束。如果違反這條約束，也許可以編譯
也可執行，但 replace_copy 因此不保證任何事情 :)
BTW，您所說的是正確的：如果令 result == first，那麼就是做 in-place operation。
不過別忘了，in-place op. 改變了原區間內容，違反了前提。
例：
  int ia[10] = {7,3,9,2,0,8,1,6,4,5};
  vector&lt;int&gt; iv(ia,ia+10);
  replace_copy(iv.begin(), iv.end(), iv.begin(), 8, 88);
  for_each(iv.begin(), iv.end(), printElem&lt;int&gt;());
  // 7,3,9,2,0,88,1,6,4,5,5

感謝：jaulueng
日期：2003/02/20

■p247,L15（中譯本筆誤）
原文：恰恰進行 last-first 次相等比較，<font
color="#FF0000">最多</font>進行 last-first 次指派動作。
更正：恰恰進行 last-first 次相等比較，<font
color="#0000FF">恰恰</font>進行 last-first 次指派動作。
感謝：jaulueng
日期：2003/02/20

■p248,L13（修潤）
原文：如果 pred(*(first+n)) 
更正：如果 pred(*(first+n)) <font
color="#0000FF">為 true</font>
感謝：jaulueng
日期：2003/02/20

■p248,L-10（英文版筆誤）
原文：<font
color="#FF0000">T</font> 可轉換為 Predicate 之引數型別
更正：<font
color="#0000FF">InputIterator 之 value type</font> 可轉換為 Predicate 之引數型別
感謝：jaulueng
日期：2003/02/20

■p249,L1（修潤）
原文：以下將 vector 內的元素複製<font
color="#FF0000">於</font>標準輸出裝置
更正：以下將 vector 內的元素複製<font
color="#0000FF">到</font>標準輸出裝置
感謝：jaulueng
日期：2003/02/20

■p254,L6（中譯本處理錯誤）
原文：<font
color="#FF0000">T 可轉換為 ForwardIterator 之 value type。</font>
更正：（請將整行刪除）
感謝：jaulueng
日期：2003/02/20

■p257,L6（中譯本筆誤）
原文：T object 可與 OutputIterator value 的 object
更正：T object 可與 OutputIterator value<font
color="#0000FF"> type</font> 的 object
感謝：jaulueng
日期：2003/02/20

■p257,L11（討論 remove_copy）
原文：result 並非 [first, last) 內的某個 iterator。
<font
color="#408080">建議：result 並非 [first+1, last) 內的某個 iterator。
討論：
result 可以等於 first，也就是說可以進行 in-place 運算。
同理，p258,L-5 的 [first, last) 也建議改為 [first+1, last)。</font>

侯捷回覆：
&quot;[first,last) 不被更動&quot; 是 remove_copy 的前提（條件），
所以 &quot;result 不得在 [first,last) 之內&quot; 是正確的約束。如果違反這條約束，也許可以編譯
也可執行，但 remove_copy 因此不保證任何事情 :)
BTW，您所說的是正確的：如果令 result == first，那麼就是做 in-place operation。
不過別忘了，in-place op. 改變了原區間內容，違反了前提。
例：
  int ia[10] = {7,3,9,2,0,8,1,6,4,5};
  vector&lt;int&gt; iv(ia,ia+10);
  remove_copy(iv.begin(), iv.end(), iv.begin(), 8);  
  for_each(iv.begin(), iv.end(), printElem&lt;int&gt;());
  // 7,3,9,2,0,1,6,4,5,5
感謝：jaulueng
日期：2003/02/20

■p258,L8（中譯本筆誤）
原文：造成 pred 為 true
更正：造成 pred <font
color="#0000FF">不</font>為 true
感謝：jaulueng
日期：2003/02/20

■p258,L-10（中譯本筆誤）
原文：InputIterator 之 value
更正：InputIterator 之 value <font
color="#0000FF">type</font>
感謝：jaulueng
日期：2003/02/20

■p263,L-11（討論 unique_copy 的比較次數）
原文：恰恰套用 ... ... last-first 次
<font
color="#408080">建議：恰恰套用 ... ... last-first-1 次</font>

侯捷回覆：
由 unique_copy 源碼（《STL源碼剖析》p371,p372）觀察得知，元素比較動作的確一共
做了 last-first-1 次。但其實比較動作還包括 iterator 的比較，而其次數與實作技巧
有關。所以我認為本書許多地方所談的「各種操作次數」，不是很有意義。我並不嚴肅對待。
這是我的看法 :)
感謝：jaulueng
日期：2003/02/20

■p265,L-5（英文版筆誤）
原文：*(result+(last-first)-n) = *(first+n)
更正：*(result+(last-first)-n<font
color="#0000FF">-1</font>) = *(first+n)
感謝：jaulueng
日期：2003/02/20

■p270,L-14,L-10; p272,L9,L13
原文：<font
color="#FF0000">Output</font>Iterator 是可變的
更正：<font color="#0000FF">Bidirectional</font>Iterator 是可變的
感謝：jaulueng
日期：2003/02/20

■p277,L-1; p279,L-1（中譯本筆誤）
原文：n!(N-n<font
color="#FF0000">!)</font> / N!
更正：n!(N-n<font color="#0000FF">)!</font> / N!
感謝：jaulueng
日期：2003/02/20

■p282,L14（中譯本筆誤）
原文：InputIterator 之 value type 為
更正：InputIterator 之 value type <font
color="#0000FF">可轉換</font>為
感謝：jaulueng
日期：2003/02/20


■p284,L9（一個中譯本筆誤 + 一個英文版筆譯）
原文：binary_op<font
color="#FF0000">2</font>1( ... ... )))
更正：binary_op1 ( ... ... )))<font
color="#0000FF">)</font>
感謝：jaulueng
日期：2003/02/20

■p284,L-3,L-2（中譯本筆誤）
原文：InputIterator1 之 value type 為
更正：InputIterator1 之 value type <font
color="#0000FF">可轉換</font>為
感謝：jaulueng
日期：2003/02/20

■p288,L5（中譯本筆誤）
原文：x <font
color="#FF0000">+</font> y
更正：x <font color="#0000FF">-</font> y
感謝：jaulueng
日期：2003/02/20

■p294,L4（中譯本筆誤）
原文：Function object greater（p.<font
color="#FF0000">2</font>86）
更正：Function object greater（p.<font color="#0000FF">3</font>86）
感謝：jaulueng
日期：2003/02/20

■p310,L-9（中譯本筆誤）
原文：<font
color="#FF0000">const </font>StrictWeakOrdering&amp; comp
更正：StrictWeakOrdering&amp; comp
感謝：jaulueng
日期：2003/02/20

■p310,L-7（中譯本筆誤）
原文：return loc == last || <font
color="#FF0000">value &lt; *loc</font> ? last : loc;
更正：return loc == last || <font
color="#0000FF">comp(value, *loc)</font> ? last : loc;
感謝：jaulueng
日期：2003/02/20

■p317,L-5,L-2; p319,L-1,L-2; p323,L1,L3; p326,L1,L3
  p329,L1,L3;   p332,L4,L6;   p335,L9,L11（中譯本筆誤）
原文：<font
color="#FF0000">operator&lt;</font>
更正：<font color="#0000FF">function object comp</font>
感謝：jaulueng
日期：2003/02/20

■p324,L-5（英文版錯誤）
原文：max(<font
color="#FF0000">n-m</font>, 0)
更正：max(<font color="#0000FF">m-n</font>, 0)
感謝：jaulueng
日期：2003/02/20

■p340,L2（中譯本筆誤）
原文：is_heap(first, last) ... ... is_heap(first, last, comp)
更正：is_heap(first, last<font
color="#0000FF">-1</font>) ... ... is_heap(first, last<font color="#0000FF">-1</font>, comp)
感謝：jaulueng
日期：2003/02/20

■p342,L11~L12（中譯本處理錯誤）
原文：<font
color="#FF0000">sort_heap 的兩個版本... ... ... ... 為真。</font>
更正：（請將整段刪除）
感謝：jaulueng
日期：2003/02/20

■p350,L-4（中譯本筆誤）
原文：<font
color="#FF0000">front</font>_insert_iterator
更正：<font color="#0000FF">back</font>_insert_iterator
感謝：jaulueng
日期：2003/02/20

■p356,L-9（中譯本遺漏）
原文：這是 default constructor。<font
color="#FF0000">(描述於 Input Iterator)</font>
更正：這是 default constructor。<font
color="#0000FF">產生一個 end-of-stream iterator，那是個
      past-the-end（最後元素的下一位置）iterator，可於建構某個區間（range）時
      派上用場。</font>
感謝：jaulueng
日期：2003/02/20

■p359,L8（中譯本處理錯誤）
原文：...的指派動作猶如 s &lt;&lt; t &lt;&lt; delim。<font
color="#FF0000">（描述於 Output Iterator）</font>
更正：...的指派動作猶如 s &lt;&lt; t &lt;&lt; delim。
感謝：jaulueng
日期：2003/02/20

■p369,L-14（補充說明）
原文：Constructor 的引數型別。
更正：<font
color="#0000FF">ForwardIterator::value_type 的</font> Constructor 的引數型別。
感謝：jaulueng
日期：2003/02/20

■p381,L7（中譯本筆誤）
原文：assert(v1[i] + v<font
color="#FF0000">1</font>[i] == 0);
更正：assert(v1[i] + v<font color="#0000FF">2</font>[i] == 0);
感謝：jaulueng
日期：2003/02/20

■p381,L14（中譯本筆誤）
原文：Adaptable <font
color="#FF0000">Binary</font> Function (p.11<font color="#FF0000">5</font>)
更正：Adaptable <font
color="#0000FF">Unary</font> Function (p.11<font color="#0000FF">4</font>)
感謝：jaulueng
日期：2003/02/20

■p383,L7; p384,L-12; p385,L-1; p387,L9; p388,L-9
  p390,L4; p391,L-10; p392,L-1; p394,L9（中譯本筆誤）
原文：<font
color="#FF0000">T</font>
更正：<font color="#0000FF">bool</font>
感謝：jaulueng
日期：2003/02/20

■p394,L10（中譯本筆誤）
原文：(const T&amp; x<font
color="#FF0000">, const T&amp; y</font>)
更正：(const T&amp; x)
感謝：jaulueng
日期：2003/02/20

■p404,L11;  p406,L15; p408,L15; p410,L-9; p412,L-4; p414,L-5
  p416,L-10; p418,L-4; p421,L4;  p422,L-7; p424,L15; p426,L8（中譯本筆誤）
原文：ada<font
color="#FF0000">tp</font>or
更正：ada<font color="#0000FF">pt</font>or
感謝：jaulueng
日期：2003/02/20

■p406,L11; p408,L11（補充）
原文：R (X::*)
更正：R (X::*)<font
color="#0000FF">()</font>
說明：這是 pointer to member function 的語法。最後加上一個 () 比較更清楚些
感謝：jaulueng
日期：2003/02/20

■p413,L9（中譯本筆誤）
原文：<font
color="#FF0000">const_</font>mem_fun
更正：mem_fun
感謝：jaulueng
日期：2003/02/20

■p414,L-9; p416,L-14（補充）
原文：R (X::*) const
更正：R (X::*)<font
color="#0000FF">()</font> const
說明：這是 pointer to const member function 的語法。最後加上一個 () 比較更清楚些
感謝：jaulueng
日期：2003/02/20

■p418,L-8（中譯本筆誤）
原文：R (X::*)(A)
更正：R (X::*)(A) <font
color="#0000FF">const</font>
感謝：jaulueng
日期：2003/02/20

■p418,L-12（中譯本筆誤）
原文：R (X::*f)(A)
更正：R (X::*f)(A) <font
color="#0000FF">const</font>
感謝：jaulueng
日期：2003/02/20

■p418,L3; p420,L9（中譯本筆誤）
原文：<font
color="#FF0000">non-</font>const member function
更正：const member function
感謝：jaulueng
日期：2003/02/20

■p422,L-12; p424,L10（中譯本筆誤）
原文：如果 <font
color="#FF0000">f</font> 的型別
更正：如果 <font color="#0000FF">F </font>的型別
感謝：jaulueng
日期：2003/02/20

■p422,L-4; p424,L12（中譯本筆誤）
原文：第<font
color="#FF0000">一</font>引數
更正：第<font color="#0000FF">二</font>引數
感謝：jaulueng
日期：2003/02/20

■p426,L9（中譯本筆誤）
原文：pointer_to_<font
color="#FF0000">unary</font>_function
更正：pointer_to_<font color="#0000FF">binary</font>_function
感謝：jaulueng
日期：2003/02/20

■p428,L4（中譯本筆誤）
原文：建構時以 <font
color="#FF0000">object</font> 做為其底部的一個 function object，
更正：建構時以 <font
color="#0000FF">pred </font>做為其底部的一個 function object，
感謝：jjhou
日期：2003/02/20

■p428,L8（英文版筆誤）
原文：通常不需要寫 unary_negate&lt;Pred&gt;(<font
color="#FF0000">f</font>)，而應該寫成 not1(<font color="#FF0000">f</font>)。
更正：通常不需要寫 unary_negate&lt;Pred&gt;(<font
color="#0000FF">pred</font>)，而應該寫成 not1(<font color="#0000FF">pred</font>)。
感謝：jaulueng
日期：2003/02/20

■p429,L16（中譯本筆誤）
原文：(p)<font
color="#FF0000">，</font>
更正：(p)<font color="#0000FF">。</font>
感謝：jaulueng
日期：2003/02/20

■p429,L-13（中譯本筆誤）
原文：建構時以 <font
color="#FF0000">object </font>做為其底部的一個 function object，
更正：建構時以<font
color="#0000FF"> pred </font>做為其底部的一個 function object，
感謝：jjhou
日期：2003/02/20

■p429,L-10（英文版筆誤）
原文：通常不需要寫 binary_negate&lt;Pred&gt;(<font
color="#FF0000">f</font>)，而應該寫成 not2(<font color="#FF0000">f</font>)。
更正：通常不需要寫 binary_negate&lt;Pred&gt;(<font
color="#0000FF">pred</font>)，而應該寫成 not2(<font color="#0000FF">pred</font>)。
感謝：jaulueng
日期：2003/02/20

■p429,L-1（中譯本筆誤）
原文：wptr == ' '
更正：<font
color="#0000FF">*</font>wptr == ' '
感謝：jaulueng
日期：2003/02/20

■p432 下（補充。英文版遺漏）
<font
color="#408080">讀者來函：
少了 member function operator()，建議新增以下兩行敘述</font>
<font
color="#0000FF">result_type unary_compose::operator()(const argument_type&amp;) const
function call 運算子。  (描述於 Adaptable Unary Function)</font>

侯捷回覆：您的閱讀真是仔細，資料亦十分完善。謝謝。
感謝：jaulueng
日期：2003/02/20

■p434 下（補充。英文版遺漏）
<font
color="#408080">讀者來函：
少了 member function operator()，建議新增以下三行敘述</font>
<font
color="#0000FF">result_type binary_compose::operator()(const argument_type&amp; x) const
function call 運算子。 x 必須可以轉換成 UnaryFunction2 的引數型別。
    (描述於 Adaptable Unary Function)</font>
    
侯捷回覆：您的閱讀真是仔細，資料亦十分完善。謝謝。
感謝：jaulueng
日期：2003/02/20

■p434,L10（中譯本筆誤）
原文：BinaryFunction<font
color="#FF0000">1</font>::result_type
更正：BinaryFunction::result_type
感謝：jaulueng
日期：2003/02/20

■p434,L17（英文版筆誤）
原文：BinaryFunction::<font
color="#FF0000">argument</font>_type
更正：BinaryFunction::<font color="#0000FF">result</font>_type
感謝：jaulueng
日期：2003/02/20

■p440,L17（中譯本筆誤）
原文：使用 re<font
color="#FF0000">vers</font>e() 的理由
更正：使用 re<font color="#0000FF">serv</font>e() 的理由
感謝：jaulueng
日期：2003/02/20

■p441,L5;p446,L12;p453,L1（中譯本筆誤）
更正：此處的 vector::insert()、list::insert()、slist::insert() 的回返型別
      皆應為 <font
color="#0000FF">void</font> 而不是書上的 <font color="#FF0000">iterator</font>
感謝：jaulueng
日期：2003/02/20

■p447,L6（中譯本處理錯誤）
原文：...。<font
color="#FF0000">如果 pos == i 或 pos == ++i，此函式...所謂 null operation）。</font>複雜度：O(1)。
更正：...。複雜度：O(1)。 
感謝：jaulueng
日期：2003/02/20

■p447,L-17（補強）
原文：size()-1 次<font
color="#FF0000">相</font>等測試。
更正：size()-1 次<font color="#0000FF">對</font>等測試<font
color="#0000FF">（以 p 為之）</font>。
感謝：jaulueng
日期：2003/02/20

■p448,L16; p455,L-12（中譯本筆誤）
原文：...<font
color="#FF0000">的</font>是否相等。
更正：...是否相等。
感謝：jaulueng
日期：2003/02/20

■p453,L-13（中譯本筆誤）
原文：<font
color="#FF0000">iterator</font> slist::insert_after(iterator pos, size_type n, const T&amp; x)
更正：<font
color="#0000FF">void</font> slist::insert_after(iterator pos, size_type n, const T&amp; x)
感謝：jaulueng
日期：2003/02/20

■p453,L-16（中譯本筆誤）
原文：<font
color="#FF0000">iterator</font> slist::insert_after(iterator pos, InputIterator f, InputIterator l)
更正：<font
color="#0000FF">void</font> slist::insert_after(iterator pos, InputIterator f, InputIterator l)
感謝：jaulueng
日期：2003/02/20

■p453,L-14（英文版筆誤）
原文：與 <font
color="#FF0000">last-first</font> 成線性關係。
更正：與 <font color="#0000FF">l-f </font>成線性關係。
感謝：jaulueng
日期：2003/02/20

■p454,L10（中譯本筆誤）
原文：void slist::splice_after(iterator pos, iterator <font
color="#FF0000">pref</font>)
更正：void slist::splice_after(iterator pos, iterator <font
color="#0000FF">prev</font>)
感謝：jaulueng
日期：2003/02/20

■p454,L11（中譯本筆誤）
原文：將 <font
color="#FF0000">pref</font> 之後的那個元素...
更正：將 <font color="#0000FF">prev</font> 之後的那個元素...
感謝：jaulueng
日期：2003/02/20

■p454,L-5（補充）
原文：size()-1 次<font
color="#FF0000">相</font>等測試。
更正：size()-1 次<font color="#0000FF">對</font>等測試<font
color="#0000FF">（以 p 為之）</font>。
感謝：jaulueng
日期：2003/02/20

■p455,L-6（英文版錯誤）
原文：...線性時間內於<font
color="#FF0000">開頭或</font>中間處安插或移除元素。
更正：...線性時間內於中間處安插或移除元素。
說明：deque 開頭處的安插或移除動作，需 amortized const-time。見 p455,L-5。
感謝：jaulueng
日期：2003/02/20

■p456,L16（英文版錯誤）
原文：... deque 才提供（例如在常數時間內於開頭<font
color="#FF0000">或尾端</font>做安插動作），
更正：... deque 才提供（例如在常數時間內於開頭做安插<font
color="#0000FF">或移除</font>動作），
說明：vector 也提供在常數時間內於尾端做安插或移除動作。所以那不是 deque 的專利。
感謝：jaulueng
日期：2003/02/20

■p460,L10（中譯本筆誤）
原文：<font
color="#FF0000">iterator</font> deque::insert(
更正：<font color="#0000FF">void</font> deque::insert(
感謝：jaulueng
日期：2003/02/20

■p472,L-8;p493,L-2（英文版筆誤）
原文：pair&lt;const_iterator,const_iterator&gt;...  
更正：函式最後需加上一個 <font
color="#0000FF">const</font>（才能與其上一個函式形成多載化）
感謝：jaulueng
日期：2003/02/20

■p477,L-11（中譯本筆誤）
原文：iteratr multiset::insert
更正：iterat<font
color="#0000FF">o</font>r multiset::insert
感謝：jaulueng
日期：2003/02/20

■p490,L3（中譯本筆誤）
原文：hash_map 的 <font
color="#FF0000">hash_</font>mapped type（對映型別）
更正：hash_map 的 mapped type（對映型別）
感謝：jaulueng
日期：2003/02/20

■p490,L4（中譯本筆誤）
原文：<font
color="#FF0000">hash_</font>mapped_type
更正：mapped_type
感謝：jaulueng
日期：2003/02/20

■p494,L13（中譯本筆誤）
原文：hash_multiset&lt;<font
color="#FF0000">&lt;</font>Key,
更正：hash_multiset&lt;Key,
感謝：jaulueng
日期：2003/02/20

■p505,L12;p507,L-2（中譯本筆誤）
原文：con<font
color="#FF0000">s</font>tainer adaptor
更正：container adaptor
感謝：jaulueng
日期：2003/02/20

■p526,L-2（中譯本筆誤）
原文：I<font
color="#FF0000">n</font>terator 介面改變
更正：Iterator 介面改變
感謝：jaulueng
日期：2003/02/20


※ 以下 5 個建議都與 STL Concepts 相關。它們都不是筆誤；改動它們便是改變原作。
這使我頗為躊躇。暫且先放在這兒 :)

<font
color="#408080">■p366,L-6
原文：(描述於 Input   Iterator)
建議：(描述於 Forward Iterator)
說明：因為 Forward Iterator 才隸屬於 Default Constructible。
感謝：jaulueng
日期：2003/02/20

■p370,L5
原文：*i = t。（描述於 Output Iterator）
建議：*i = t。
說明：同頁 L-4 有說明，也就是說 operator* 不一定要有傳回值，
      p99,L-6 有更詳細的說明，if and only if 老師決定不堪此誤，
      則同頁 p370,L8 應該新增此敘述 -&gt; （描述於 Output Iterator）
同理，p359,L14、L16 的 （描述於 Output Iterator） 也請老師斟酌之 :)
感謝：jaulueng
日期：2003/02/20

■p425,L8
原文：Adaptable Unary Function (p.114)。
建議：Adaptable Unary Function (p.114)、Default Constructible (p.84)。
說明：因同頁最下面(L-3) 有成員 default constructor，
      而此描述於 Default Constructible 這個 concept 中，
      若老師同意我的看法，則請一併修改以下 -&gt;
感謝：jaulueng
日期：2003/02/20

■p425,L-13
原文：並未定義於 Adaptable Unary Function 需求條件中，
建議：並未定義於 Adaptable Unary Function、Default Constructible 需求條件中，
感謝：jaulueng
日期：2003/02/20

■p425,L-1
原文：null。
建議：null。    （描述於 Default Constructible）
感謝：jaulueng
日期：2003/02/20</font></pre>

<pre>■p50,L-7（中譯本筆誤）
原文：<font FACE="新細明體">是的，</font><font
FACE="Footlight MT Light,Book Antiqua" size="2">function call</font><font
FACE="新細明體"> <font color="#FF0000">建構</font>子</font><font size="2"> </font><font
FACE="Courier New" size="2">operator()</font><font FACE="新細明體">可以...</font>
更正：<font
FACE="新細明體">是的，</font><font FACE="Footlight MT Light,Book Antiqua" size="2">function call</font><font
FACE="新細明體"> <font color="#0000FF">運算</font>子</font><font size="2"> </font><font
FACE="Courier New" size="2">operator()</font><font FACE="新細明體">可以...</font>
感謝：jjhou
日期：2003/03/08</pre>

<pre>■p76,L3;p146,L15;p305,L-9,L-8(兩處);p306,L12;p308,L16;p311,L5;p313,L14（誤譯）
原文：<font
FACE="新細明體">二<font color="#FF0000">元</font>搜尋</font>
更正：<font
FACE="新細明體">二<font color="#0000FF">分</font>搜尋</font>
感謝：jjhou
日期：2003/03/08</pre>

<pre>■pxi,p305, 13.2.1標題（誤譯）
原文：<font FACE="新細明體">二<font
color="#FF0000">元</font>搜尋法（Binary Search）</font>
更正：<font
FACE="新細明體">二<font color="#0000FF">分</font>搜尋法（Binary Search）</font>
感謝：jjhou
日期：2003/03/08</pre>

<pre>■p93,L-11（誤譯）
原文：<font FACE="新細明體">Identity（<font
color="#FF0000">自身</font>性）</font>
更正：<font FACE="新細明體">Identity（<font
color="#0000FF">同一</font>性）</font>
感謝：jjhou
日期：2003/03/08</pre>

<pre>↑以上為第一刷（1st printing）更正（已修正於第二刷紙本）。</pre>

<pre>======================================================</pre>

<pre>以下暫請讀者自行更正：
（注意，Lm 表示第 m 行，L-n 表示倒數第 n 行）</pre>

<pre>■p321,L-7（筆誤）
原文：若且惟若 [first2,last2) 中的每個元素在 [first1,last<font
color="#FF0000">2</font>) 中存在等價元素
更正：若且惟若 [first2,last2) 中的每個元素在 [first1,last<font
color="#0000FF">1</font>) 中存在等價元素
感謝：zcyu
日期：2005.01.07

■p326,p329,p332,範例中的以下兩行（原書筆誤）
原文：
  const int N3 = sizeof(A3);
  const int N4 = sizeof(A4);
更正：
  const int N3 = sizeof(A3)<font
color="#0000FF"> / sizeof(int)</font>;
  const int N4 = sizeof(A4)<font color="#0000FF"> / sizeof(int)</font>;
感謝：zcyu
日期：2005.01.07<font
color="#408080">

</font>
--- the end</pre>
</body>
</html>
