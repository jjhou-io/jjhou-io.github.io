<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<meta content="text/html; charset=big5" http-equiv="Content-Type">
<meta content="Microsoft FrontPage 3.0" name="GENERATOR">
<title>巨細靡遺 井然有序</title>
</head>

<body background %22bgColor=-#ffffff%22%22 tppabs="http://jjhou.boolan.com/bgColor=%22#ffffff%22" text="#000000">

<hr>

<h2 align="center"><big>鉅細靡遺 井然有序</big></h2>

<h3 align="center"><small><font color="#800000">《C++ 標準程式庫》侯捷譯序</font></small></h3>

<p align="center"><img src="the-cpp-standard-library-c.jpg" tppabs="http://jjhou.boolan.com/the-cpp-standard-library-c.jpg" width="256" height="342"
alt="the-cpp-standard-library-c.jpg (10735 bytes)"></p>

<hr>

<blockquote>
  <font FACE="細明體" SIZE="2"><p ALIGN="JUSTIFY"></font><font FACE="細明體" size="3">自從</font><font
  size="3">1998<font FACE="細明體">年</font><font FACE="Book Antiqua"><i>C++ Standard</i></font><font
  FACE="細明體">定案以後，</font>C++ <font FACE="細明體">程式庫便有了大幅擴充。原先為大家所熟知、標準規格定案前蘊釀已久的</font>STL<font
  FACE="細明體">（</font>Standard Template Library<font FACE="細明體">，標準模板程式庫），不再被單獨對待，而是被納入整個</font>C++ 
  <font FACE="細明體">標準程式庫（</font>Standard Library<font FACE="細明體">）。同時，原有的程式庫（如</font>iostream<font
  FACE="細明體">）也根據泛型技術（</font>generics<font FACE="細明體">）在內部上做了很大的修改。可以說，</font><font
  FACE="Book Antiqua"><i>C++ Standard</i></font><font FACE="細明體">的發佈對</font><font
  FACE="Book Antiqua">C++ </font><font FACE="細明體">社群帶來了翻天覆地的大變動</font> 
  —&nbsp; <font FACE="細明體"><font FACE="細明體">不是來自語言本身，而是來自標準程式庫。這個變動，影響</font><font
  FACE="Book Antiqua">C++ </font><font FACE="細明體">程式編寫風格至鉅，</font><font
  FACE="Book Antiqua">C++</font><font FACE="細明體">之父</font><font
  FACE="Book Antiqua">Bjarne Stroustrup</font><font FACE="細明體">並因此寫了一篇文章：</font><font
  FACE="Book Antiqua"><i>Learning Standard C++ as a New Language</i></font><font
  FACE="細明體">（載於</font>C/C++ User's Journal, 1999/05）。</p>
  <p ALIGN="JUSTIFY">我個人於1998<font FACE="細明體">年開始潛心研究泛型技術和</font>STL<font
  FACE="細明體">，本書英文版《</font><font FACE="Book Antiqua"><i><b>The C++ 
  Standard Library</b></i></font><font FACE="細明體">》甫一出版便成為我學習</font>C++ 
  <font FACE="細明體">標準程式庫的最重要案頭工具之一。小有心得之後，我寫過數篇相關技術文章，從來離不開本書的影響和幫助。我曾經把</font>STL<font
  FACE="細明體">（代表泛型技術目前最被廣泛運用的一個成熟產品，也是</font>C++ 
  標準程式庫的絕大成份）的學習比喻為三個階段（或層次）：</p>
  <ul>
    <li>第一境界：熟用STL</li>
    <font FACE="細明體">
    <li>第二境界：瞭解泛型技術的內涵與</font>STL<font FACE="細明體">的學理乃至實作</li>
    <li>第三境界：擴充</font>STL</li>
  </ul>
  <p ALIGN="JUSTIFY">不論哪一個階段，你都能夠從本書獲得不同程度的幫助。<font
  FACE="新細明體"></p>
  <p>第一階段（對最大多數程式員有立竿見影之效），我們需要一本全面而詳盡的教本，附帶多量而設計良好的範例，帶領我們認識十數個</font>STL<font
  FACE="新細明體">容器（</font>containers<font FACE="新細明體">）、數十個</font>STL<font
  FACE="新細明體">演算法（</font>algorithms<font FACE="新細明體">）、許許多多的迭代器（</font>iteartors<font
  FACE="新細明體">）、配接器（</font>adapters<font FACE="新細明體">）、仿函式（</font>functors<font
  FACE="新細明體">）…的各種特性和用途。這些為數繁多的組件必須經過良好的編排組織和索引，才能成就一本效果良好、富教育性又可供長久查閱的案頭工具書。</font></p>
  </font></font><font FACE="細明體" SIZE="2"><p ALIGN="JUSTIFY"></font><font
  FACE="細明體" size="3">在這一階段裡，本書表現極為優異。書中運用許多圖表，對所有</font><font
  size="3">STL<font FACE="細明體">組件的成員做了極其詳盡的整理。更值得稱道的是書中交叉參考（</font>cross 
  reference<font FACE="細明體">）做得非常好，在許多關鍵地點告訴讀者當下可參見哪一章哪一節哪一頁，對於閱讀和學習帶來很大的幫助（本中文版以頁頁對譯方式保留了所有交叉參考和索引）。</p>
  <p ALIGN="JUSTIFY">第二階段（從</font>STL<font FACE="細明體">的運用晉升至泛型技術的學習），我們需要一些關鍵的</font>STL<font
  FACE="細明體">源碼（或偽碼</font>, pseudo code<font FACE="細明體">），幫助我們理解關鍵的資料結構、關鍵的編程技術。認識這些關鍵源碼（或偽碼）同時也有助提昇第一階段的運用深度（學會使用一樣東西，卻不知道它的道理，不高明<font
  FACE="Wingdings">J</font> <font color="#FF0000">註1</font>）。</p>
  <p ALIGN="JUSTIFY">本書很多地方都提供了C++ 
  標準程式庫的關鍵源碼。不全面，但很關鍵。</p>
  <font FACE="新細明體" SIZE="3" COLOR="#0000ff"><sup><p></sup></font><font
  color="#FF0000">註1</font>：</font></font><font FACE="細明體" color="#408080"
  size="3">乍見之下令人錯愕的一句話。看電視需要先了解電視的原理嗎？呵呵，話講白就沒意思了。這句話當然是對技術人員說的。</font><font
  size="3"><font FACE="細明體"></p>
  <p ALIGN="JUSTIFY">第三階段（成為一位泛型技術專家；打造自己的</font>STL<font
  FACE="細明體">相容組件），我們需要深入了解</font>STL</font><font
  FACE="細明體" size="3">的設計理念和組織架構</font><font size="3"
  FACE="細明體" color="#FF0000">（註2）</font><font size="3"><font FACE="細明體">，並深入（且全面地）了解</font>STL<font
  FACE="細明體">實作手法</font></font><font size="3" FACE="細明體" color="#FF0000">（註3）</font><font
  size="3"><font FACE="細明體">。是的，不入虎穴，不能得虎子；徹底了解</font>STL<font
  FACE="細明體">如何被打造出來之後，你才能寫出和</font>STL<font
  FACE="細明體">水乳交融、完美整合的自定組件（</font>user-defined 
  components<font FACE="細明體">）。</font></font><font FACE="新細明體"></p>
  <p>本書對第三階段的學習也有相當幫助。雖然沒能提供全面的</font>STL<font
  FACE="新細明體">源碼並分析其技術（那需要另外</font>800<font
  FACE="新細明體">頁<font FACE="Wingdings">J</font> 
  ），卻提供了為數不少的訂製型組件實作範例：</font>p191, p213<font
  FACE="新細明體">提供了一個執行期指定排序準則並運用不同排序準則的實例，</font>p219<font
  FACE="新細明體">提供一個自定容器（雖然只是個簡單的包覆類別），</font>p222<font
  FACE="新細明體">提供一個「</font><font FACE="Lucida Sans" size="3">reference</font><font
  FACE="新細明體">語意」示範作法，</font> p285<font FACE="新細明體">提供一個針對迭代器而設計的泛型演算法，</font>p288<font
  FACE="新細明體">提供一個用於關聯式容器的訂製型</font><font
  FACE="Lucida Sans" size="3">inserter</font><font FACE="新細明體">，</font>p294<font
  FACE="新細明體">有一個自定的排序準則，</font>p441<font FACE="新細明體">有一個自定的（安全的）</font>stack<font
  FACE="新細明體">，</font>p450<font FACE="新細明體">有一個自定的（安全的）</font>queue<font
  FACE="新細明體">，</font>p504<font FACE="新細明體">有一個自定的</font>traits 
  class for string<font FACE="新細明體">，</font> p614<font FACE="新細明體">有一個自定的</font>stream<font
  FACE="新細明體">操控器，</font>p663<font FACE="新細明體">有一個自定的</font>stream<font
  FACE="新細明體">緩衝區，</font>p735<font FACE="新細明體">有一個自定的記憶體配置器（</font>allocator<font
  FACE="新細明體">）。</font></p>
  <p><font size="3" FACE="細明體" color="#FF0000">註</font><font FACE="細明體"
  size="3"><font color="#FF0000">2</font>：</font><font FACE="新細明體" color="#408080">這方面我推薦你看《</font><font
  FACE="Book Antiqua" size="3" color="#408080"><i>Generic Programming and the STL - Using 
  and Extending the C++ Standard Template Library</i></font><font color="#408080"><font
  FACE="新細明體">》</font>, by Matthew H. Austern, Addison Wesley 1998<font
  FACE="新細明體">。詳見稍後說明。中譯本《泛型程式設計與</font>STL<font
  FACE="新細明體">》</font>,<font FACE="新細明體">侯捷</font>/<font
  FACE="新細明體">黃俊堯合譯</font>, <font FACE="新細明體">碁峰</font>, 2001<font
  FACE="新細明體">。</font></font></p>
  <p><font FACE="細明體" size="3" color="#FF0000">註</font><font FACE="細明體"
  size="3"><font color="#FF0000">3</font>：</font><font color="#408080"><font
  FACE="新細明體">這方面我推薦你看《</font>STL<font FACE="新細明體">源碼剖析</font>, 
  </font><font FACE="Book Antiqua" size="3" color="#408080"><i>The Annotated STL Sources</i></font><font
  color="#408080"><font FACE="新細明體">》</font>by <font FACE="新細明體">侯捷</font>, 
  <font FACE="新細明體">碁峰</font>, 2002<font FACE="新細明體">。詳見稍後說明。</font></font></p>
  <font FACE="細明體" SIZE="2"><p ALIGN="JUSTIFY"></font><font FACE="細明體" size="3">除了眾所矚目的</font><font
  size="3">STL<font FACE="細明體">，本書也涵蓋一般不被歸類為</font>STL<font
  FACE="細明體">的</font>String<font FACE="細明體">程式庫，以及一般不被視為關鍵的</font>IOStream<font
  FACE="細明體">和</font>Locale<font FACE="細明體">程式庫</font></font><font
  size="3" FACE="細明體" color="#FF0000">（註4）</font><font size="3"><font
  FACE="細明體">。三部分互有關連，以</font>IOStream<font FACE="細明體">為主幹。在</font>GUI<font
  FACE="細明體">（圖形使用介面）和</font>application framework<font
  FACE="細明體">（應用程式框架）當道的今天，</font>IOStream<font
  FACE="細明體">提供的輸出輸入可能對大部份人失去了價值，但如果你希望開拓</font>OO<font
  FACE="細明體">技術視野，</font>IOStream<font FACE="細明體">是一顆沉睡的珠寶。</p>
  <p ALIGN="JUSTIFY"></font></font><font size="3" FACE="細明體" color="#FF0000">註</font><font
  FACE="細明體" size="3"><font color="#FF0000">4</font>：</font><font size="3"><font
  FACE="細明體"><font color="#408080"><font FACE="新細明體">這方面</font>僅<font
  FACE="新細明體">見的專著是《</font><font FACE="Book Antiqua"><i>Standard C++ 
  IOStreams and Locales - Advanced Programmer's and Reference</i></font><font
  FACE="新細明體">》</font>, by Angelika Langer and Klaus Kreft, Addison Wesley 2000<font
  FACE="新細明體">。</font></font></p>
  <p ALIGN="CENTER"><font FACE="Wingdings">v</font> </font><font FACE="Wingdings">v</font> <font
  FACE="Wingdings">v</font> <font FACE="細明體"></p>
  <p ALIGN="JUSTIFY">泛型技術不僅在</font>C++ <font FACE="細明體">被發揚光大，在</font>Java<font
  FACE="細明體">上也有發展</font></font><font size="3" FACE="細明體"
  color="#FF0000">（註5）</font><font size="3"><font FACE="細明體">，在</font>C# <font
  FACE="細明體">上亦被眾人期待。從目前的勢頭看，泛型技術（</font>Generics<font
  FACE="細明體">）或許是物件導向（</font>Object Oriented<font FACE="細明體">）技術以來程式編寫方面的又一個巨大衝擊。新一代</font>C++ 
  <font FACE="細明體">標準程式庫</font></font><font size="3" FACE="細明體"
  color="#FF0000">（註6）</font><font size="3"><font FACE="細明體">將採用更多更複雜更具威力的泛型技術，提供給</font>C++ 
  <font FACE="細明體">社群更多更好更具復用價值的組件。</p>
  <p ALIGN="JUSTIFY"></font></font><font size="3" FACE="細明體" color="#FF0000">註</font><font
  size="3" FACE="細明體"><font color="#FF0000">5</font>：</font><font size="3"
  FACE="細明體" color="#408080">(1) <i>GJ : A Generic Java</i>, by Philip Wadler, Dr. 
  Dobb's Journal February 2000. (2) <i>JSR- 000014 : Adding Generics to the Java Programming 
  Language</i>, <br>
  http://jcp.org/aboutJava/communityprocess/review/jsr014/index.html</font><font size="3"
  FACE="細明體"></p>
  <p ALIGN="JUSTIFY"></font><font FACE="細明體" size="3" color="#FF0000">註</font><font
  size="3" FACE="細明體"><font color="#FF0000">6</font>：</font><font color="#408080"><font
  size="3" FACE="新細明體">請參考</font><font FACE="細明體" size="3">http://www.boost.org/，</font><font
  size="3" FACE="新細明體">此物據稱將成為下一代</font></font><font size="3"
  FACE="細明體" color="#408080"> C++</font><font size="3"><font FACE="細明體"><font
  color="#408080"><font FACE="新細明體">標準。</font></font></p>
  <p ALIGN="JUSTIFY">不論你要不要、想不想、有沒有興趣在你的程式編寫過程中直接用上泛型技術，至少，在</font>C++ 
  <font FACE="細明體">程式編寫過程中你已經不可或缺於泛型技術帶來的成熟產品：</font>C++ 
  <font FACE="細明體">標準程式庫。只要你具備</font>C++ <font FACE="細明體">語言基礎，本書便可以帶領你漂亮地運用</font>C++ 
  <font FACE="細明體">標準程式庫，漂亮地提昇你的編程效率和程式品質。</font></font><font
  FACE="新細明體"></p>
  <p>面對陌生，程式員最大的障礙在於心中的怯弱。</font>To be or not to 
  be, that is the question! <font FACE="新細明體">不要像哈姆雷特一樣猶豫不決。面對光明的技術，必須果敢。</font></p>
  <font FACE="細明體" SIZE="2"><p ALIGN="CENTER"></font><font FACE="Wingdings" size="3">v</font><font
  FACE="細明體" size="3"> </font><font size="3"><font FACE="Wingdings">v</font> <font
  FACE="Wingdings">v</font> <font FACE="細明體"></p>
  <p ALIGN="JUSTIFY">關於術語的處理，本書大致原則如下：</p>
  <ol>
    </font>
    <li>STL<font FACE="細明體">各種資料結構名稱皆不譯，例如</font>array, 
      vector, list, deque, hast table, map, set, stack, queue, tree…<font FACE="細明體">。雖然其中某些已有約定俗成的中文術語，但另一些沒有既標準又被普遍運用的中文名稱，強譯之讀者瞠目以對，部分譯部分不譯則閱讀時詞性平衡感不佳（例如「面對</font><font
      FACE="華康中黑體">向量</font><font FACE="細明體">和</font><b>deque</b><font
      FACE="細明體">兩種容器</font>…<font FACE="細明體">」就不如「面對</font><b>vector</b><font
      FACE="細明體">和</font><b>deque</b><font FACE="細明體">兩種容器</font>…<font
      FACE="細明體">」讀起來順暢）。因此，資料結構名稱全部不譯。直接呈現這些簡短的英文術語，可能營造更突出的視覺效果，反而有利閱讀。技術書籍的翻譯不是為了建立全中文化閱讀環境，我們的讀者水平也不可能受制於這些英文單字。<br>
    </li>
    </font>
    <li>STL<font FACE="細明體">六大組件的英文名稱原打算全部保留，但由於處處出現，對版面的中英文比例形成視覺威脅，因此全部採用以下譯名：</font><b>container</b><font
      FACE="華康中黑體">容器</font></font><font FACE="細明體" SIZE="2">，</font><font
      size="3"><b>algorithm</b><font FACE="華康中黑體">演算法</font><font
      FACE="細明體">，</font><b>iterator</b><font FACE="華康中黑體">迭代器</font><font
      FACE="細明體">，</font><b>adapter</b><font FACE="華康中黑體">配接器</font><font
      FACE="細明體">，</font><b>functor</b><font FACE="華康中黑體">仿函式</font></font><font
      size="3" FACE="細明體" color="#FF0000">（註7）</font><font size="3"><font
      FACE="細明體">，</font><b>allocator</b><font FACE="華康中黑體">配置器</font><font
      FACE="細明體">。<br>
    </li>
    <li>任何一個被保留的英文關鍵術語，其第一次（或前數次）出現時儘可能帶上中文名稱。同樣地，任何關鍵的中文術語，我也會時而讓它中英並陳。</font></font><font
      size="3" FACE="細明體"></li>
  </ol>
  <p></font><font size="3" FACE="細明體" color="#FF0000">註</font><font size="3"
  FACE="細明體"><font color="#FF0000">7</font>：</font><font size="3"><font
  FACE="細明體"><font FACE="新細明體">原書大部份時候使用</font><b>function 
  object</b><font FACE="華康中黑體">函式物件</font><font FACE="新細明體">一詞，為求精簡及突出，中文版全部改用其另一個名稱</font><b>functor</b><font
  FACE="華康中黑體">仿函式</font><font FACE="新細明體">（見第</font>8<font
  FACE="新細明體">章譯註）。</font></p>
  <p ALIGN="CENTER"><font FACE="Wingdings">v</font> </font><font FACE="Wingdings">v</font> <font
  FACE="Wingdings">v</font> <font FACE="細明體"></p>
  <p ALIGN="JUSTIFY">關於編排，本書原則如下：</p>
  <ol>
    <li>全書按英文版頁次編排，並因而得以保留原書索引。索引詞條皆不譯。<br>
    </li>
    <li>中文版採用之程式碼字體（</font>Courier New 8.5<font FACE="細明體">）比文本字體（細明體</font>9.5<font
      FACE="細明體">）小，英文版之程式碼字體卻比其文本字體大，且行距寬。因此中文版遇有大篇幅程式列表，為保持和英文版頁次相應，便會出現較多留白。根據我個人對書籍的經驗，去除這些留白的最後結果亦不能為全書節省五頁十頁；填滿每一處空白卻喪失許多立即可享的好處，智者不取<font
      FACE="Wingdings">J</font> 。</li>
  </ol>
  <p ALIGN="CENTER"><a name="5-milestones"><font FACE="Wingdings">v</font> </font><font
  FACE="Wingdings">v</font> <font FACE="Wingdings">v</font></a> <font FACE="細明體"></p>
  <p ALIGN="JUSTIFY">一旦你從本書獲得了對</font>C++ <font FACE="華康中黑體">標準程式庫</font><font
  FACE="細明體">運用層面的全盤掌握與實踐經驗之後，可能希望對</font>STL<font
  FACE="細明體">原理乃至實作技術做更深的研究，或甚至對泛型編程（</font>Generic 
  Programming<font FACE="細明體">）產生無比狂熱。在眾多相關書籍之中，下面是我認為非常值得繼續進修的四本書：</font></font></p>
  <ol>
    <font FACE="細明體" SIZE="2">
    <li></font><font FACE="細明體" size="3">《</font><font FACE="Book Antiqua" size="3"
      color="#0000FF"><i>Generic Programming and the STL - Using and Extending the C++ Standard 
      Template Library</i></font><font FACE="細明體" size="3">》</font><font size="3">, by 
      Matthew H. Austern, Addison Wesley 1998<font FACE="細明體">。本書第一篇（前五章）談論</font>STL<font
      FACE="細明體">的設計哲學、程式庫背後的嚴密架構和嚴謹定義。其中對於</font>STL<font
      FACE="細明體">之異於一般程式庫，有許多重要立論。其餘部分（第二篇、第三篇）是</font>STL<font
      FACE="細明體">的完整規格（分別從</font>concepts<font FACE="細明體">的角度和</font>components<font
      FACE="細明體">的角度來闡述），並附範例程式。<br>
    </li>
    <li>《<font color="#0000FF">STL源碼剖析, <font FACE="Book Antiqua"><i>The Annotated STL 
      Sources</i></font></font>》by 侯捷, 碁峰, 2002。本書剖析 STL實作技法，詳實揭示並註解STL六大組件的底層實作，並以公認最嚴謹的SGI（Silicon 
      Graphics Inc.）STL版本為剖析對象。附許多精彩分析圖，對於高度精巧的記憶體配置策略、各種資料結構、各種演算法、乃至極為「不可思議」的配接器（adapter）實作手法，都有深入的剖析。<br>
    </li>
    <li>《</font></font><font FACE="細明體" color="#0000FF" size="3"><i>Effective STL</i></font><font
      FACE="細明體" size="3">》, by Scott Meyers, Addison Wesley 2001。本書定位為STL的深層運用。在深層運用的過程中，你會遇到一些難解的問題和效率的考量，你需要知道什麼該做、什麼該避免。本書提供50個專家條款。請注意，深層運用和效率調校，可能需要讀者先對底部機制有相當程度的了解。<br>
    </li>
    <li>《<font color="#0000FF"><i>Modren C++ Design</i></font>》by Andrei Alexandrescu, 
      Addison Wesley 2001。將泛型技術發揮到淋漓盡致、令人目瞪口獃的一本書籍。企圖將泛型技術和設計樣式（design 
      patterns）結合在一起。領先時代開創先河的一本書。</font><font size="3"><font
      FACE="細明體"></li>
  </ol>
  <p><img src="generic-programming-and-stl.jpg" tppabs="http://jjhou.boolan.com/generic-programming-and-stl.jpg" width="134" height="168"
  alt="generic-programming-and-stl.jpg (26611 bytes)"> <img src="tass.jpg" tppabs="http://jjhou.boolan.com/tass.jpg" width="136"
  height="168" alt="tass.jpg (33378 bytes)"> <img src="meyers3.jpg" tppabs="http://jjhou.boolan.com/meyers3.jpg" width="134" height="168"
  alt="meyers3.jpg (31544 bytes)"> <img src="modern-cpp-design.jpg" tppabs="http://jjhou.boolan.com/modern-cpp-design.jpg" width="134" height="168"
  alt="modern-cpp-design.jpg (39141 bytes)"></p>
  <p ALIGN="CENTER"><font FACE="Wingdings">v</font> </font><font FACE="Wingdings">v</font> <font
  FACE="Wingdings">v</font> <font FACE="細明體"></p>
  <p ALIGN="JUSTIFY">本書由我和孟岩先生共同完成。孟岩在大陸技術論壇以</font>C++/OO/Generics</font><font
  FACE="細明體" size="3">馳名，見解深雋文筆不凡。我很高興和他共同完成這部作品。所謂合譯，我們兩人對全書都有完整的參與（而非你一半我一半的對拆法），最終由我定稿。本書同時發行繁體版和簡體版，基於兩岸計算機術語的岐異性，簡體版由孟岩負責必要轉換。</font><font
  size="2" FACE="細明體"></p>
  </font><font FACE="華康中黑體" SIZE="2"><p ALIGN="JUSTIFY"></font><font
  FACE="華康中黑體" size="3">侯捷</font><font size="3"> 2002/05/23 <font
  FACE="細明體">于新竹</font></font><font FACE="Courier New" size="2"></p>
  <p>http://www.jjhou.com</font><font FACE="細明體" size="2">（繁體網站）<br>
  </font><font FACE="Courier New" size="2">http://jjhou.csdn.net</font><font
  FACE="細明體" size="2">（簡體網站）<br>
  </font><font FACE="Courier New" size="2">jjhou@jjhou.com</font><font FACE="細明體"
  size="2">（個人電子郵箱）</font></p>
</blockquote>
</body>
</html>
