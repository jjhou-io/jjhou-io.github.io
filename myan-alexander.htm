<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<meta content="text/html; charset=gb2312" http-equiv="Content-Type">
<meta content="Microsoft FrontPage 4.0" name="GENERATOR">
<title>STL之父访谈录</title>
</head>

<body background %22bgColor=-#ffffff%22%22 tppabs="http://jjhou.boolan.com/bgColor=%22#ffffff%22" text="#000000">

<p>  </p>

<hr>

<h2 align="center"><font color="#800000">STL 之父访谈录</font></h2>

<h3 align="center"><font color="#800000">作者 Al Stevens<br> 
译者 孟岩</font></h3> 

<blockquote>
  <p align="center">侯捷注：本文系北京《程序员》杂志 2001/02  
  的文章。可读性高，技术饱满。<br>
  承译者<font color="#000000">孟岩先生与</font>《程序员》<font color="#000000">杂志负责人蒋涛先生应允，<br>
  转载於此以飨台湾读者，非常感谢。<br>
  <br>
  未得孟岩先生与蒋涛先生二人之同意，任何人请勿将此文再做转载。<br>
  <br>
  以下</font><font color="#0000FF">蓝色</font><font color="#000000">为提问，黑色为回答。</font><font
  color="#FF0000">红色</font><font color="#000000">为译注，</font><font
  color="#FF00FF">紫色</font><font color="#000000">为侯捷个人认为宜再斟酌之处。<br>
  </font><font color="#8080FF">浅蓝色</font><font color="#000000">是侯捷个人阅读时的神秘标记。<br>
  <br>
  本繁体文系直接转码，并未将大陆惯用术语转换为台湾惯用术语。</font></p>
</blockquote>

<hr>

<blockquote>
  <p>1995年3月，Dr.Dobb's Journal特约记者, 着名技术书籍作家Al Stevens采访了STL创始人Alexander  
  Stepanov. 这份访谈纪录是迄今为止对於STL发展历史的最完备介绍,  
  侯捷先生在他的STL有关文章里推荐大家阅读这篇文章.  
  因此我将该文全文翻译如下.</p>
  <p><br>
  <br>
  <font color="#0000FF">Q: 您对於generic programming进行了长时间的研究, 
  请就此谈谈.<br>
  </font><br>
  A: 我开始考虑有关GP的问题是在7O年代末期,  
  当时我注意到有些算法并不依赖于数据结构的特定实现，而只是依赖于该结构的几个基本的语义属性.  
  於是我开始研究大量不同的算法，结果发现大部份算法可以用这种方法从特定实现中抽象出来,  
  而且效率无损. 对我来说, 效率是至关重要的, <font color="#FF00FF">要是一种算法抽象在具现化之后性能不佳</font>,  
  那可不够棒.<br>
  <br>
  当时我认为这项研究的正确方向是创造一种编程语言.  
  我和我的两个朋友一起开始干起来. 一个是现在的纽约州立大学教授Deepak  
  Kapur, 另一个是伦塞里尔技术学院教授David Musser.  
  当时我们三个在通用电器公司研究中心工作. 我们开始设计一种叫Tecton的语言.  
  该语言有一种我们称为&quot;通用结构&quot;的东西,  
  其实不过是一些形式类型和属性的集合体, 人们可以用它来描述算法.  
  例如一些数学方面的通用结构充许人们在其上定义一个代数操作,  
  精化之, 扩充之, 做各种各样的事.<br> 
  <br>
  虽然有很多有趣的创意, 但最终该项研究没有取得任何实用成果,  
  因为Tecton语言是函数型语言. 我们信奉Backus的理念，相信自己能把编程从von  
  Neumann风格中解放出来，而且不想使用<font color="#8080FF">副效应</font>,  
  这一点限制了我们的能力, 因为有大量的算法需要利用诸如&quot;状态&quot;,  
  &quot;副效应&quot;等观念。 <br>
  <br>
  我在70年代末期在Tecton上面所认识到了一个有趣的问题:  
  被广泛接受的ADT观念有着根本性的缺陷. 人们通常认为ADT的特点是只暴露对象行为特徵,  
  而将实现隐藏起来. 一项操作的复杂度被认为是与实现相关的属性,  
  所以抽象的时候应予忽略. 我则认识到, <font color="#8080FF">在考虑一个(抽象)操作时,  
  复杂度(或者至少是一般观念上的复杂度)必须被同时考虑在内. 
  这一点现在已经成了GP的核心理念之一</font>.<br>
  <br>
  例如一个抽象的栈stack类型, 仅仅保证你push进去的东西可以随後被pop出来是不够的,  
  同样极端重要的是, 不管stack有多大, 你的push操作必须能在常数时间内完成.  
  如果我写了一个stack, 每push一次就慢一点, 那谁都不会用这个烂玩艺.<br> 
  <br>
  我们是要把实现和界面分开, 但不能完全忽略复杂度. 复杂度必须是,  
  而且也确实是横陈于模块的使用者与实现者之间的不成文契约. ADT观念的引入是为了允许软件模块相互可替换.  
  但除非那个模块的操作复杂度与这个模块类似,  
  否则你肯定不愿意真的去互换.  
  如果我用另外一个模块替换原来的模块,  
  并提供完全相同的接口和行为, 但就是复杂度不同,  
  那麽用户肯定不高兴. 就算我费尽口舌介绍那些抽象实现的优点,  
  他肯定还是不乐意用. 所以说复杂度必须被认为是接口的一部份.<br> 
  <br>
  1983年左右,  
  我转往纽约布鲁克林综合技术大学任教。开始研究的是图的算法,  
  主要的合作伙伴是现在IBM的Aaron Kershenbaum.  
  他在图和网络算法方面是个专家, 我使他相信<font color="#8080FF">高序(high  
  order)</font>的思想和GP能够应用在图的算法中.  
  他支持我与他合作开始把这些想法用于实际的网络算法.  
  某些图的算法太复杂了, 只进行过理论分析, 从来没有实现过.  
  他企图建立一个包含有高序的通用组件的工具箱,  
  这样某些算法就可以实现了. 我决定使用Lisp语言的一个变种Scheme语言来建立这样一个工具箱.  
  我们俩建立了一个巨大的库, 展示了各种编程技术.  
  网络算法是首要目标. 不久当时还在通用电器的David Musser加了进来,  
  开发了更多的组件, 一个非常大的库. 这个库供大学里的本科生使用,  
  但从未商业化. 在这项工作中, 我了解到副效应是很重要的,  
  不利用副效应, 你根本没法进行图操作. 你不能每次修改一个节点(vertex)  
  时都在图上兜圈子. 所以,  
  当时得到的经验是在实现通用算法时可以把高序技术和副效应结合起来.  
  副效应不总是坏的, 只有在被错误使用时才是.<br> 
  <br>
  1985年夏, 我回到通用电器讲授有关高序程序设计的课程.  
  我展示了在构件复杂算法时这项技术的应用. 有一个听课的人叫陈迩,  
  当时是信息系统实验室的主任. 他问我是否能用Ada语言实现这些技术,  
  形成一个工业强度的库, 并表示可以提供支持.  
  要知道我当时只是个穷助教, 所以尽管对於Ada一无所知, 我还是回答&quot;好的&quot;.  
  我跟Dave Musser一起建立这个Ada库. 这是很重要的一个时期, 从象Scheme那样的动态类型语言(dynamically  
  typed language)转向Ada这样的强类型语言, 使我认识到了强类型的重要性.  
  谁都知道强类型有助于<font color="#8080FF">纠错</font>. 我则发现在Ada的通用编程中,  
  <font color="#8080FF">强类型是获取设计思想的有力工具</font>.  
  它不仅是查错工具, 而且是思想工具.  
  这项工作给了我对於组件空间进行正交分解的观念. 我认识到,  
  软件组件各自属於不同的类别. <font color="#8080FF">OOP的狂热支持者认为一切都是对象.  
  但我在Ada通用库的工作中认识到, 这是不对的</font>.  
  二分查找就不是个对象, 它是个算法. 此外, 我还认识到,  
  通过将组件空间分解到几个不同的方向上, 我们可以减少组件的数量,  
  更重要的是, 我们可以提供一个设计产品的概念框架.<br> 
  <br>
  随後, 我在贝尔实验室C++组中得到一份工作, 专事库研究.  
  他们问我能不能用C++做类似的事. 当然，我那时还不懂C++, 但当然,  
  我说我行. 可结果是，我不行, 因为1987年时, C++中还没有模板,  
  这玩艺在通用编程中是个必需品. 结果只好用继承来获取通用性,  
  那显然不理想.<br>
  <br>
  直到现在C++继承机制也不大用在通用编程中, 我们来说说为什麽.  
  很多人想用继承实现数据结构和容器类, 结果几乎全部一败涂地. C++的继承机制及与之相关的编程风格有着戏剧性的局限.  
  用这种方式进行通用编程, 连“<font color="#FF00FF">等式判断”</font>这类的小问题都解决不了.  
  如果你以X类作为基类, 设计了一个虚函数operater==, 接受一个X类对象,  
  并由X派生类Y, 那麽Y的operator==是在拿Y类对象与 X类对象做比较.  
  以动物为例, 定义animal类, 派生giraffe(长颈鹿)类. 定义一个成员函数  
  mate(), 实现与另一个哺乳动物的交配操作, 返回一个animal对象.  
  现在看看你的派生类giraffe, 它当然也有一个mate()方法,  
  结果一个长颈鹿同一个动物交配, 返回一个动物对象. 这成何体统?  
  当然, 对於C++程序员来说, 交配函数没那麽重要, 可是operator==就很重要了.<br> 
  <br>
  对付这种问题, 你得使用模板. 用模板机制, 一切如愿. <br> 
  <br>
  尽管没有模板, 我还是搞出来一个巨大的算法库, 後来成了Unix System  
  Laboratory Standard Component Library的一部份. 在贝尔, 我从象Andrew Koenig,  
  Bjarne Stroustrup<font color="#FF0000">(Andrew Koenig, 前ISO C++标准化委员会编辑;  
  Bjarne Stroustrup, C++之父 -- 译者)</font>这些专家身上学到很多东西.  
  我认识到C/C++的伟大之处, 它们的一些成功之处是不能被忽略的.  
  特别是我发现指针是个好东东. 我不是说空悬的指针,  
  或是指向栈的指针，我是说指针这个一般观念。地址的观念被广泛使用  .  
  不可能不使用指针的观念，没有指针我们甚至没法描述并行算法，<br>
  <br>
  我们现在来探讨一下为什麽说C是一种伟大的语言. 通常人们认为C成为编程利器并且获得如此成功,  
  是因为UNIX是用C写的.  
  我不同意。我们说语言是计算机体系结构的抽象，而计算机的体系结构是长时间发展演变的结果,  
  不是哪一个聪明的人创造的.  
  事实上是广大程序员在解决实际问题的过程中提出的要求推动了那些天才提出这些体系.  
  计算机经过多次进化, 现在只需要处理字节地址索引的内存,  
  线性地址空间和指针.  
  这个进化结果是对於人们要求解决问题的自然反映. Dennis Ritchie  
  天才的作品<font color="#8080FF">C, 正反映了演化了30年的计算机的最小模型</font>.  
  C当时并不是什麽利器. 但是当计算机被用来处理各种问题时,  
  作为最小抽象模型的C成了一种非常强大的语言,  
  在各个领域解决各种问题时都非常高效. 这就是C可移植性的奥秘, C是所有计算机的最佳抽象模型,  
  而且这种抽象确确实实是建立在实际的计算机,  
  而不是假想的计算机上的. <font color="#8080FF">人们可以比较容易的理解C背後的机器模型,  
  比理解Ada和Scheme语言背後的机器模型要容易的多</font>。C的成功是因为C做了正确的事,  
  不是因为UNIX和 AT&amp;T的极力鼓吹。<br> 
  <br>
  <font color="#8080FF">C++的成功是因为Bjarne Stroustrup以C为出发点来改进C, 
  虽然引入了更多的编程技术, 但始终保持在C所定义的机器模型框架之内, 
  而不是闭门造车地自己搞出一个新的机器模型来</font>. C的机器模型非常简单.  
  你拥有内存, 对象保存在那里面, 你又有指向连续内存空间的指针,  
  很好理解. C++保留了这个模型, 不过大大扩展了内存中对象的范畴,  
  毕竟C的数据类型太有限了, 它允许你建立新的类型结构,  
  但不允许你定义属於类型方法. 这限制了类型系统的能力. C++把C的机器模型扩展为真正类型系统.<br> 
  <br>
  1988年我到惠普实验室从事通用库开发工作，但实际上好几年我都是在作磁盘驱动器，很有趣但跟  
  GP毫不相关. 92年我终於回到了GP领域, 实验室主任Bill Worley建立了一个算法研究项目,  
  由我负责. 那时候C++已经有模板了. 我发现Bjarne的模板设计方案是非常天才的.  
  在贝尔时, 我叁加过有关模板设计的几个早期的讨论, 跟Bjarne吵得很凶,  
  我认为C++的模板设计应该尽可能向Ada的通用方案看齐.  
  我想可能我吵得太凶了, 结果Bjarne决定坚决拒绝我的建议.  
  那时候好多人都觉得最好只有模板类，而我当时就认识到在C++中有必要设置模板函数机制。<font
  color="#8080FF">不过我觉得一个模板函数在使用之前必须先显式实例化, 
  跟Ada似的. Bjarne死活不听我的, 
  他把模板函数设计成可以用重载机制来隐式实例化. 
  後来这个特别的技术在我的工作中变得至关重要, 
  我发现它容许我做很多在Ada中不可能的任务. 非常高兴Bjarne当初没听我的</font>. 
  <br>
  <br>
  <font color="#0000FF">Q: 您是什麽时候第一次构思STL的, 最初的目的是什麽?<br>
  </font><br>
  A: 92年那个项目建立时由8个人, 渐渐地人越来越少, 最後剩下俩,  
  我和李梦, 而且李小姐是这个领域的新手.  
  在她的专业研究中编译器是主要工作, 不过她接受了GP研究的想法,  
  并且坚信此项研究将带给软件开发一个大变化,  
  要知道那时候有这个信念的认可是寥寥无几. 没有她,  
  我可不敢想像我能搞定STL, 毕竟 STL标示两个人的名字:Stepanov和Lee.  
  我们写了一个庞大的库, 庞大的代码量, 庞大的数据结构组件,  
  函数对象, 适配器类, 等等。可是虽然有很多代码,  
  却没有文档，因为我们的工作被认为是一个验证性项目,  
  其目的是搞清楚到底能不能在使算法尽可能通用化的前提下仍然具有很高的效率.  
  我们花了很多时间来比较, 结果发现, 我们算法不仅最通用,  
  而且效率与手写代码一样高效, <font color="#8080FF">这种程序设计风格在性能上是不打折扣的</font>!  
  这个库在不断成长, 但是很难说它是什麽时候成为一个&quot;项目&quot;的.  
  STL的诞生是好几件事情的机缘巧合才促成的.<br>
  <br>
  <font color="#0000FF">Q: 什麽时候, 什麽原因促使您决定建议使STL成为ANSI/ISO标准C++一部份的?<br>
  </font><br>
  A: 1993年夏, Andy Koenig跑到斯坦福来讲C++课,  
  我把一些有关的材料给他看, 我想他当时确实是很兴奋. 他安排我9月到圣何塞给C++标准委员会做一个演讲.  
  我演讲的题目是&quot;C++程序设计的科学&quot;, 讲得很理论化,  
  要点是存在一些C++的基本元素所必须遵循的, 有关基本操作的原则.  
  我举了一些例子, 比如构造函数, 赋值操作, 相等操作。作为一种语言,  
  C++没有什麽限制. 你可以用operator==()来做乘法。  
  但是相等操作就应该是相等操作。它要有<font color="#8080FF">自反性</font>,  
  A == A；它要有<font color="#8080FF">对称性</font>, A == B 则 B == A; 它还要有<font 
  color="#8080FF">传递性</font>. 作为一个数学公理,  
  相等操作对於其他操作是非常基本的。构造函数和相等操作之间的联系就有公理性的东西在里边.  
  你用拷贝构造函数生成了一个新对象,  
  那麽这个对象和原来那个就应该是相等的. C++是没有做强行要求,  
  但是这是我们都必须遵守这个规则. 同样的,  
  赋值操作也必须产生相等的对象. 我展示了一些基本操作的&quot;公理&quot;,  
  还讲了一点迭<font color="#8080FF">代子(iterator),</font> 
  以及一些通用算法怎样利用迭代子来工作.  
  我觉得那是一个两小时的枯燥演讲, 但却非常受欢迎.  
  不过我那时并没有想过可能把这个东西塞在标准里, <font color="#8080FF">它毕竟是太过先进的编程技术,  
  大概还不适于出现在现实世界里</font>,  
  恐怕那些做实际工作的人对它没什麽兴趣.<br>
  <br>
  我是在9月做这个演讲的, 直到次年(1994年)1月, 我都没往ANSI标准上动过什麽脑筋.  
  1月6日, 我收到Andy Koenig的一封信(他那时是标准文档项目编辑),  
  信中说如果我希望STL成为标准库的一部份, 可以在1月25日之前提交一份建议到委员会.  
  我的答复是:&quot;Andy, 你发疯了吗?&quot;, 他答复道:&quot;不错,  
  是的我发疯了, 为什麽咱们不疯一次试试看?&quot;<br> 
  <br>
  当时我们有很多代码, 但是没有文档, 更没有正式的建议书.  
  李小姐和我  得每星期工作80小时,  
  终于在期限之前写出一份正式的建议书. 当是时也, 只有Andy一个人知道可能会发生些什麽.  
  他是唯一的支持者, 在那段日子里他确实提供了很多帮助.  
  我们把建议寄出去了, 然後就是等待.  
  在写建议的过程中我们做了很多事. <font color="#8080FF">当你把一个东西写下来,  
  特别是想到你写的可能会成为标准, 你就会发现设计中的所有纰漏</font>.  
  寄出标准後,我们不得不一段一段重写了库中间的代码,  
  以及几百个组件, 一直到3  
  月份圣迭戈会议之前。此後我们又重新修订了建议书,  
  因为在重新写代码的过程中, 我们又发现建议书中间的很多瑕疵.<br> 
  <br>
  <font color="#0000FF">Q: 您能描述一下当时委员会里的争论吗? 
  建议一开始是被支持呢, 还是反对?<br>
  </font><br>
  A: 我当时无法预料会发生些什麽. 我做了一个报告, 反响很好.  
  但当时有许多反对意见. 主要的意见是: 这是一份庞大的建议,  
  而且来得太晚, 前一次会议上已经做出决议, 不再接受任何大的建议.  
  而这个东西是有史以来最大的建议, 包括了一大堆新玩艺.  
  投票的结果很有趣, 压倒多数的意见认为应对建议进行再考虑,  
  并把投票推迟到下次会议, 就是後来众所周知的<font color="#8080FF">滑铁卢会议</font>.<br> 
  <br>
  Bjarne Stroustrup成了STL的强有力支持者.  
  很多人都通过建议  更改和修订的方式给予了帮助。Bjarne乾脆跑到这来跟我们一起工作了一个礼拜。Andy更是无时无刻的帮助我们。C++是一种复杂的语言，不是总能搞得清楚确切的含义的。差不多每天我都要问Andy和Bjarne  
  C++能不能干这干那。我得把特殊的荣誉归于Andy， 是他提出把STL作为C++标准库的一部份；而Bjarne也成了委员会中  
  STL的主要鼓吹者。其他要感谢的人还有：标准库小组的负责人Mike  
  Vilot；Rogue Wave公司的 Nathan Myers<font color="#FF0000">(Rogue Wave是Boland  
  C++Builder中STL方案的提供商      译者)</font>，Andersen咨询公司的Larry  
  Podmolik。确实有好多人要致谢。<br>
  <br>
  <font color="#FF00FF">在圣迭戈提出的STL是使用当时的C++写的，</font>我们被要求用新的ANSI/ISO  
  C++语言特性重写STL，这些特性中有一些是尚未实现的。为了正确使用这些新的  未实现的C++特性，Bjarne和Andy花了无以计数的时间来帮助我们。<br> 
  <br>
  人们希望容器独立於内存模式，这有点过份，因为语言本身并没有包括内存模式。所以我们得要想出一些机制来抽象内存模式。在STL的早期版本里，我们假定容器的容积可以用size_t类型来表示，迭代子之间的距离可以用ptrdiff_t来表示。现在有人对我们说，你为什麽不抽象的定义这些类型？这个要求比较高，连语言本身都没有抽象定义这些类型，而且C/C++数组还不能被这些类型定义所限定。我们发明了一个机制称作&quot;allocator&quot;，封装了内存模式的信息。这个机制深刻地影响了库中间的每一个组件。你可能疑惑：内存模式和算法或者容器类接口有什麽关系？事实上如果你使用size_t这样的东西，你就无法使用  
  T* 对象，因为存在不同的指针类型(近指针  远指针  巨指针等等)。你也就不能使用<font 
  color="#8080FF">引用</font>，因为内存模式不同的话，会产成不同的引用类型。这样，为了实用，标准库一定会产生庞大的分支。<br>
  <br>
  另外一件重要的事情是扩展我们原先的关联类型数据结构。这比较容易一些，但是<font
  color="#8080FF">作为标准的东西总是很困难的，因为我们做的东西人们会使用很多年</font>。从容器的观点看，STL做了十分清楚的二分法设计。所有的容器类被分成两种：顺序的和关联的，就好像常规的内存和按内容寻址的内存一般。这些容器的语义十分清楚。<br>
  <br>
  当我到滑铁卢以後，Bjarne用了不少时间来安慰我不要太在意成败与否，因为虽然看上去似乎不会成功，但是我们毕竟做到了最好。我们尽力试过了，所以应该坦然面对。成功的期望很低。我们估计大部份的意见将反对。但是事实上，确实有一些反对意见，但不占上风。滑铁卢投票的结果让人大跌眼镜，80%赞成，20%反对。所有人都预期会有一场恶战，一场大论战。结果虽然确实有争论，但投票是压倒性的。<br>
  <br>
  <font color="#0000FF">Q: STL对於1994年2月发行的ANSI/ISO C++工作文件中的类库有何影响？<br>
  <br>
  </font>A: STL被放进了滑铁卢会议的工作文件里。STL文档被分解成若干部份，放在了文件的不同部份中。Mike  
  Vilot负责此事。我并没有过多地叁与编辑工作，甚至也不是C++委员会的成员。不过每次有关STL的建议都由我来考虑。委员会考虑还是满周到的。<br>
  <br>
  <font color="#0000FF">Q: 
  委员会後来又做了一些有关模板机制的改动，哪些影响到了STL？<br>
  <br>
  </font>A: 在STL被接受之前，有两个变化影响到了我们修订STL。其一是模板类增加了<font 
  color="#8080FF">包含模板函数</font>的能力。STL广泛地使用了这个特性来允许你建立各种容纳容器的容器。一个单独的构造函数就能让你建立一个能容纳list或其他容器的vector。还有一个模板构造函数，从迭代子构造容器对象，你可以用一对迭代子当作叁数传给它，这对迭代子之间的元素都会被用来构造新的容器类对象。另一个STL用到的新特性是<font
  color="#8080FF">把模板自身当作模板叁数传给模板类</font>。这项技术被用在刚刚提到的allocator中。<br>
  <br>
  <font color="#0000FF">Q: 那麽STL影响了模板机制吗？<br>
  </font><br>
  A: 在弗基山谷的会议中，Bjarne建议给模板增加一个“<font color="#8080FF">局部特殊化”(partial  
  specialization)</font>的特性。这个特性可以让很多算法和类效率更高，但也会带来代码体积上的问题。我跟Bjarne在这个建议上共同研究了一段时间，<font
  color="#8080FF">这个建议就是为了使STL更高效而提出的</font>。我们来解释一下什麽是“局部特殊化”。你现在有一个模板函数  
  swap( T&amp;, T&amp; )，用来交换两个叁数。但是当T是某些特殊的类型叁数时，你想做一些特殊的事情。例如对於swap(  
  int&amp;, int&amp; )，你想用一种特别的操作来交换数据。这一点在没有局部特殊化机制的情况下是不可能的。有了局部特殊化机制，你可以声明一个模板函数如下：<br> 
  <br>
  template &lt;class T&gt; void swap( vector&lt;T&gt;&amp;, vector&lt;T&gt;&amp; );<br> 
  <br>
  这种形式给vector容器类的swap操作提供了一种特别的办法。从性能的角度讲，这是非常重要的。如果你用通用的形式去交换vector，会使用三个赋值操作，vector被复制三次，时间复杂度是线性的。然而，如果我们有一个局部特殊化的swap版本专门用来交换两个vector，你可以得到一个时间复杂度为常数的，非常快的操作，只要移动vector头部的两个指针就OK。这能让vector上的sort算法运行得更快。<font
  color="#8080FF">没有局部特殊化的话</font>，让某一种特殊的vector，例如vector&lt;int&gt;运行得更快的唯一办法是让程序员自己定一个特殊的swap函数，这行得通，但是<font color="#8080FF">加重了程序员的负担</font>。在大部份情况下，局部特殊化机制能够让算法在某些通用类上表现得更高效。你有最通用的swap，不那麽通用的swap，更不通用的swap，完全特殊的swap这麽一系列重载的swap，然後你使用局部特殊化，编译器会自动找到最接近的那个swap。再看一个有关copy的例子。现在我们的copy就是通过迭代子一个一个地拷贝。使用模板特殊化可以定义一个模板函数：<br>
  <br>
  template &lt;class T&gt; T** copy( T**, T**, T** );<br> 
  <br>
  这可以用memcpy高效地拷贝一系列指针来实现，因为是指针拷贝，我们可以不必担心构造对象和析构对象的<font
  color="#8080FF">开销</font>。这个模板函数可以定义一次，然後供整个库使用，而且用户不必操心。我们使用局部特殊化处理了一些算法。这是个重要的改进，据我所知在弗基山谷会议上得到了好评，将来会成为标准的一部份。<br>
  <br>
  <font color="#0000FF">Q: 除了标准类库外，STL对那一类的应用程序来说最有用处？<br>
  </font><br>
  A: 我希望STL能够引导大家学习<font color="#8080FF">一种新的编程风格</font>：通用编程。我相信这种风格适用于任何种类的应用程序。这种风格就是：用最通用的方式来写算法和数据结构。这些结构所要求的语义特性应该能够被清楚地归类和分类，而这些归类分类的原则应该是任何对象都能满足的。理解和发展这种技术还要很长时间，STL不过是这个过程的起点。<br> 
  <br>
  我们最终会对通用的组件有一个标准的分类，这些组件具有精心定义的接口和复杂度。<font
  color="#8080FF">程序员们将不必在微观层次上编程</font>。你再也不用去写一个二分查找算法。就是在现在，STL也已经提供了好几个通用的二分查找算法，凡是能用二分查找算法的场合，都可以使用这些算法。算法所要求的前提条件很少：你只要在代码里使用它。我希望所有的组件都能有这麽一天。<font
  color="#8080FF">我们会有一个标准的分类，人们不用再重复这些工作。</font><br>
  <br>
  这就是Douglas McIlroy的梦想，他在1968年关於“构件工厂”的那篇着名文章中所提出来的东西<font 
  color="#FF0000">(M.Douglas McIlroy博士现在在贝尔实验室计算机科学研究中心工作，那篇文章的题目是Mass 
  Produced Software Components, 现在还可以在http://cm.bell-labs.com/cm/cs/who/doug/components.txt找到这篇论文    译者)</font>。STL就是这种“构件工厂”的一个范例。当然，还需要有主流的力量介入这种技术的发展之中，光靠研究机构不行，工业界应该想程序员提供组件和工具，帮助他们找到所需的组件，把组件粘合到一起，然後确定复杂度是否满足预期要求。<br>
  <br>
  <font color="#0000FF">Q: STL没有实现一个持久化(persistent)对象容器模型。map和multimap似乎是比较好的候选者，它们可以把对象按索引存入持久对象数据库。您在此方向上做了什麽工作吗，或者对这类实现有何评论？<br>
  </font><br>
  A：很多人都注意到这个问题。<font color="#8080FF">STL没实现持久化是有理由的</font>。STL在当时已经是能被接受的最巨大的库了。再大一点的话，我认为委员会肯定不会接受。当然持久化是确实是人们提出的要求。在设计STL，特别是<font
  color="#8080FF">设计allocator时，Bjarne认为这个封装了内存模式的组件可以用来封装持久性内存模式</font>。Bjarne的洞察秋毫非常的重要和有趣，好几个对象数据库公司正在盯着这项技术。1994年10月我叁加了Object  
  Database Management Group的一个会议，我做了一个<font color="#FF00FF">关於STL的</font>演说。他们非常感兴趣，想让他们正在形成中的组件库的接口与STL一致，但不包括allocator在内。不过该集团的某些成员仔细分析了allocator是否能够被用来实现持久化。<font
  color="#8080FF">我希望与STL接口一致的组件对象持久化方案能在接下来的一年里出现。</font><br>
  <br>
  <font color="#0000FF">Q：set，multiset，map和multimap是用红黑树实现的，您试过用其他的结构，比如B*树来实现吗？<br>
  </font><br>
  A：我不认为B*树适用于内存中的数据结构，不过当然这件事还是应该去做的。应该对许多其他的数据结构，比如跳表(skip  
  list)  伸展树(splay tree)  半平衡树(half-balanced tree)等，也实现STL容器的标准接口。应该做这样的研究工作，因为STL提供了一个很好的框架，可以用来比较这些结构的性能。结口是固定的，基本的复杂度是固定的，现在我们就可一个对各种数据结构进行很有意义的比较了。在数据结构领域里有很多人用各种各样的接口来实现不同的数据结构，我希望他们能用STL框架来把这些数据结构变成通用的。<font 
  color="#FF0000">（译者注：後来在Stepanov和Matthew Austern等人的SGI STL中增补了哈希结构hash  单链表slist和巨型字符串rope三种容器，为了实现STL对象持久化，将来可能会增补B+树。红黑树查找操作的时间复杂度为O(logN), 
  而理想hash结构为O(1)。</font>）<br>
  <br>
  <font color="#0000FF">Q：有没有编译器厂商跟您一起工作来把STL集成到他们的产品中去？<br>
  </font><br>
  A：是的，我接到了很多厂家的电话。Borland公司的Peter Becker出的力特别大。他帮助我实现了对应Borland编译器的所有内存模式的allocator组件。Symantec打算为他们的Macintosh编译器提供一个STL实现。Edison设计集团也很有帮助。我们从大多数编译器厂商都得到了帮助。<font 
  color="#FF0000">（译者注：目前常见的STL版本有：Borland C++Builder使用的Rogue 
  Wave STL；Visual C++使用的 Dinkumware STL；GNU C++和SGI IRIX C++使用的SGI STL。SGI 
  STL是Stepanov叁与开发的，一直得到推崇，俄罗斯人Boris Fomitchev甚至发动了一个基於SGI 
  STL的自由项目 STLport，旨在把SGI STL移植到各种主流编译环境中，请叁见http://www.stlport.org 
  和http://www.sgi.com/technology/STL）</font><br>
  <br>
  <font color="#0000FF">Q：STL包括了对MS-DOS的16位内存模式编译器的支持，不过当前的重点显然是在32位上线性内存模式(flat 
  model)的操作系统和编译器上。您觉得这种面向内存模式的方案以後还会有效吗？<br>
  </font><br>
  A：抛开Intel的体系结构不谈，内存模式其实是一个对象，封装了有关指针的信息：这个指针的整型尺寸和距离类型是什麽，相关的引用类型是什麽，等等。如果我们想利用各种内存，比如持久性内存，共享内存等等，抽象化的工作就非常重要了。<font
  color="#8080FF">STL的一个很漂亮的特性是整个库中唯一与机器类型相关的部份    代表真实指针，真实引用的组件    被封装到大约16行代码里，其他的一切，容器  算法等等，都与机器无关</font>。从移植的观点看，所有及其相关的东西，象是地址记法，指针等等，都被封装到一个微小的，很好理解的机制里面。这样一来，allocator对於STL而言就不是那麽重要了，至少不像对於基本数据结构和算法的分解那麽重要。<br>
  <br>
  <br>
  <font color="#0000FF">Q：ANSI/ISO C标准委员会认为像内存模式这类问题是平台相关的，没有对此做出什麽具体规定。C++委员会会不会采取不同的态度？为什麽？<br>
  </font><br>
  A：我认为STL在内存模式这一点上跟C++标准相比是超前的。C和C++之间有着显着的不同。C++有构造函数和new操作符来对付内存模式问题，而且它们是语言的一部份。现在看来当时如果能让new操作符像STL容器使用allocater那样来工作就好了。不过现在问题的重要性不像STL出现之前那麽米明显了，因为在大多数场合，STL数据结构将让new失业。大部份人不再需要分配一个数组，因为STL在做这类事情上更为高效。要知道我对效率的迷信是无以复加的，可我在我的代码里从不使用new，汇编代码表明其效率<br>
  比使用new时更高。随着 STL的广泛使用，new会逐渐淡出江湖。而且STL永远都会记住回收内存，因为当一个容器，比如vector退出<font 
  color="#8080FF">作用域</font>时，它的析构函数被调用，会把容器里的所有东西都析构。你也不必再担心内存泄漏了。STL可以戏剧性地降低对於垃圾收集机制的需求。使用STL容器，你可以为所欲为，不用关心内存的管理，自有STL构造函数和析构函数来对付。<br>
  <br>
  <br>
  <font color="#0000FF">Q：C++标准库子委员会正在制订标准名空间（namespace）和异常处理机制。STL类会有名空间吗，会抛出异常吗？<br>
  </font><br>
  A：是的。该委员会的几个成员正在考虑这件事，他们的工作非常出色。<br>
  <br>
  <font color="#0000FF">Q：现在的STL跟最终作为标准的STL会有多大不同？委员会会不会干预某些变化，新的设计会不会被严格地控制起来？<br>
  </font><br>
  A：多数人的意见看起来是不希望对STL做任何重要的改变。<br>
  <br>
  <font color="#0000FF">Q：在成为标准之前，程序员们怎样获得一些STL经验？<br>
  </font><br>
  A：他们可以从butler.hpl.hp.com/stl当下STL头文件，在Borland和IBM或其他足够强劲的的编译器中使用它。学习这种编程技术的唯一途径是编程，看看范例，试着用这种技术来编程。<br>
  <br>
  <font color="#0000FF">Q：您正在和P. J. Plauger合作一本STL的书。那本书的重点是什麽？什麽时候面世？<br>
  </font><br>
  A：计划95年夏天面世，重点是对STL实现技术的详解，跟他那本标准C库实现和标准C++库实现的书类似。他是这本书的第一作者。该书可以作为STL的叁考手册。我希望跟Bjarne合作另写一本书，在C++/STL背景下介绍语言与库的交互作用。<br>
  <br>
  好多工作都等着要做。为了STL的成功，人们需要对这种编程技术进行更多的试验性研究，更多的文章和书籍应该对此提供帮助。要准备开设此类课程，写一些入门指南，开发一些工具帮助人们漫游STL库。STL是一个框架，应该有好的工具来帮助使用这个框架。<font
  color="#FF0000">（译者注：他说这番话时，并没有预计到在接下来的几年里会发生什麽。由於Internet的大爆炸和Java  VB  Delphi等语言的巨大成功，工业界的重心一下子从经典的软件工程领域转移到Internet上。再加上标准C++直到98年才制订，完全符合要求的编译器直到现在都还没有出现，STL并没有立刻成为人们心中的关注焦点。他提到的那本书也迟迟不能问世，直到前几天（2001年元旦之後），这本众人久已期盼的书终於问世，由P.  
  J. Plauger, Alexander Stepanov, Meng Lee, David Musser四大高手联手奉献，Prentice Hall出版。不过该书主要关注的是STL的实现技术，不适用于普通程序员。另外就P. J. Plauger做一个简介：其人是标准C中stdio库的早期实现者之一，91年的一本关於标准C库的书使他名满天下。他现在是Dinkumware公司总裁，C/C++  
  Use's Journal的主编，与Microsoft保持良好的，甚至是过份亲密的关系，Visual  
  C++中的STL和其他的一些内容就是出自他的那只生花妙笔。http://www.dinkumware.com。）</font><br>
  <br>
  <font color="#0000FF">Q：通用编程跟OOP之间有什麽关系？<br>
  </font><br>
  A：<font color="#8080FF">什麽是OOP的基本思想呢？把组件的实现和接口分开，并且让组件具有多态性</font>。一句话，<font
  color="#8080FF">通用编程是OOP这个基本思想的自然延续</font>。不过，两者还是有根本的不同。OOP强调在程序构造中语言要素的语法。你必须得继承，使用类，使用对象，对象传递消息。而GP不关心你继承或是不继承，它的开端是分析产品的分类，有些什麽种类，他们的行为如何。就是说，<font
  color="#8080FF">两件东西相等</font>意味着什麽？怎样正确地定义相等操作？并不像想的那麽简单，你往深处份析就会发现“相等”这个一般观念意味着两个对象的部份，或者至少基本部份是相等的，据此我们就可以有一个通用的相等操作。再说对象的种类。假设存在一个顺序序列和一组对於顺序序列的操作。那麽这些操作的语义是什麽？从复杂度权衡的角度看，我们应该向用户提供什麽样的顺序序列？该种序列上存在那些操作？那种排序是我们需要的？只有对这些组件的概念型分类搞清楚了，我们才能提到实现的问题：使用模板  继承还是宏？使用什麽语言和技术？GP的基本观点是把抽象的软件组件和它们的行为用标准的分类学分类，出发点就是要建造真实的  高效的和不取决于语言的算法和数据结构。当然最终的载体还是语言，没有语言没法编程。STL使用C++，你也可以用Ada来实现，用其他的语言来实现也行，结果会有所不同，但基本的东西是一样的。到处都要用到二分查找和排序，而这就是人们正在做的。对於容器的语义，不同的语言会带来轻微的不同。但是基本的区别很清楚是GP所依存的语义，以及语义分解。例如，我们决定需要一个组件swap，然後指出这个组件在不同的语言中如何工作。显然重点是语义以及语义分类。而OOP所强调的（我认为是过份强调的）是清楚的定义类之间的层次关系。OOP告诉了你如何建立层次关系，却没有告诉你这些关系的实质。（<font 
  color="#FF0000">这段不太好理解，有一些术语可能要过一段时间才会有合适的中文翻译    译者）</font><br>
  <br>
  <font color="#0000FF">Q：您对STL和GP的未来怎麽看?<br>
  </font><br>
  A：我刚才提到过，程序员们的梦想是拥有一个标准的组件仓库，其中的组件都具有良好的  易于理解的和标准的接口。为了达成这一点，GP需要有一门专门的科学来作为基础和支柱。STL在某种程度上开始了这项工作，它对於某些基本的组件进行了语义上的分类。我们要在这上面下更多的功夫，<font 
  color="#8080FF">目标是要将软件工程从一种手工艺技术转化为工程学科</font>。这需要一门对於基本概念的分类学，以及一些关於这些基本概念的定理，这些定理必须是容易理解和掌握的，每一个程序员即使不能很清楚的知道这些定理，也能正确地使用它。很多人根本不知道交换律，但只要上过学的人都知道2+5等於5+2。我希望所有的程序员都能学习一些基本的语义属性和基本操作：<font color="#8080FF">赋值</font>意味着什麽？<font
  color="#8080FF">相等</font>意味着什麽？怎样建立数据结构，等等。<br>
  <br>
  当前，C++是GP的最佳载体。我试过其他的语言，最後还是C++最理想地达成了抽象和高效的统一。但是我觉得可能设计出一种语言，集成C和很多C++的卓越思想，而又更适合于GP。它没有C++的一些缺陷，特别是不会像C++一样庞大。STL处理的东西是概念。什麽是迭代子？不是类，不是类型，是概念。说得更正式一些，这是Bourbaki所说的结构类型（structure  
  type），是逻辑学家所说的理念（theory），或是类型理论学派的人所说的种类（sort），这种东西在C++里没有语言层面上的对应物<font
  color="#FF0000">（原文是incarnation，直译为肉身    译者）</font>，但是可以有。你可以拥有一种语言，使用它你可以探讨概念，精化概念，最终用一种非常“程序化”的手段把它们转化为类。当然现在就有一些语言<font
  color="#FF00FF">能处理种类（sorts）</font>，但是当你想排序（sort）时它们没什麽用处。我们能够有一种语言，用它我们能定义叫做foward  
  iterator（前向迭代子）的东西，在STL里这是个概念，没有C++对应物。然後我们可以从forword  
  iterator中发展出bidirectional iterator（双向迭代子），再发展出random  
  iterator。可能设计一种语言大为简化GP，我完全相信该语言足够高效，其机器模型与C/C++充份接近。我完全相信能够设计出一种语言，一方面尽可能地靠近机器层面以达成绝对的高效，另一方面能够处理非常抽象化的实体。我认为该语言的抽象性能够超过C++，同时又与底层的机器之间契合得天衣无缝。<font
  color="#8080FF">我认为GP会影响到语言的研究方向</font>，我们会有适于GP的实用语言。从这些话中你应该能猜出我下一步的计划。<br>
  <br>
  mengyan&nbsp;译于2001年1月<br>
  <br>
  <br>
  </p>
</blockquote>
</body>
</html>