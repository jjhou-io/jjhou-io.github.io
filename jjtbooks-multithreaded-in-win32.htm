<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<meta content="text/html; charset=big5" http-equiv="Content-Type">
<meta content="Microsoft FrontPage 3.0" name="GENERATOR">
<title>《Win32 多緒程式設計》繁體版</title>
</head>

<body background %22bgColor=-#ffffff%22%22 tppabs="http://jjhou.boolan.com/bgColor=%22#ffffff%22" text="#000000">

<hr>

<h2 align="center"><strong><small><small><font color="#808080">四刷 3600 冊&nbsp;</font><font
color="#0000FF">&nbsp;</font></small></small></strong></h2>

<h2 align="center"><font color="#800000">《Win32 多緒程式設計》<br>
<small>Multithreaded Applications in Win32</small></font></h2>

<h2 align="center"><font color="#800000"><small>侯捷 譯</small></font></h2>

<p align="center"><img src="jim.jpg" tppabs="http://jjhou.boolan.com/jim.jpg" width="235" height="288" alt="jim.jpg (16257 bytes)"></p>

<p align="center"><a href="errata-multithreaded-in-win32.htm" tppabs="http://jjhou.boolan.com/errata-multithreaded-in-win32.htm" target="main">繁體版 
勘誤</a></p>

<hr>

<blockquote>
  <p><a name="【基本資料】"><font color="#FF0000">【基本資料】</font></a><br>
  <br>
  書名：<font color="#0000FF">Win32 多緒程式設計</font><br>
  出版：碁峰，1997.08<br>
  ISBN：957-566-075-7<br>
  頁數： 16 章，453 頁<br>
  定價：NT$ 640.0<br>
  <br>
  原著：<font color="#0000FF">Multithreaded Applications in Win32</font><br>
  原著作者：Jim Beveridge &amp; Robert Wiener <br>
  原著出版：Addison Wesley, 1997<br>
  原著ISBN：0-201-44234-5<br>
  原著定價：US$ 39.95<br>
  </p>
  <p><a name="【譯序】"><font color="#FF0000">【譯序】</font></a></p>
  <font FACE="華康特粗黑體" SIZE="6"><p ALIGN="CENTER">敘緒之序 絮絮如絮</font><font
  FACE="華康中黑體" SIZE="2"></p>
  <p ALIGN="CENTER">（譯</font><font SIZE="2"> </font><font FACE="華康中黑體"
  SIZE="2">序）</p>
  </font><font FACE="華康仿宋體" SIZE="1"><p ALIGN="JUSTIFY"></font><font size="3">作者在本書第一章的第一句話讓我沉思良久。他說：『電腦工業界每有新的技術問世，人們總是不遺餘力地去擔憂「它是不是夠重要」。公司行號虎視眈眈地注意其競爭對手，直到對方採用並宣揚這技術有多麼重要，才開始急急趕上。不論這技術是不是真的很重要，每一個人都想盡辦法讓終端用戶感覺「真的很重要」。終端用戶終於真的覺得需要它了 
  -- 即使他們完全不瞭解那是什麼東東。』</p>
  <p ALIGN="JUSTIFY">執行緒（thread）大約就是其一吧。OS/2 和 Windows NT 以及 
  Windows 95 上市時，一再強調其強制性多工（preemptive multitasking）的多執行緒（multithreaded）環境。霎時間線頭到處飛舞，電腦科學裡十分高深的名詞也在街巷里弄之間傳播了開來，頗有點 
  &quot;Nerual Fuzzy&quot; 洗衣機的味道。</p>
  <p ALIGN="JUSTIFY">這倒也算好事。沒有把「執行緒」搞清楚是怎麼回事，對終端用戶而言或許還沒有關係，但是對搞技術的人可就不妙。執行緒絕對可以提昇程式的執行效率？所以儘量多產生執行緒來幫助程式工作？任何種類的程式都可以獲得多執行緒的好處？錯！錯！錯！這種似是而非的觀念可能把你的程式帶往一種更壞（而不是更好）的境界。　</p>
  <p ALIGN="JUSTIFY">執行緒並不是新東西，只是它藉著 Windows 
  的龐大裝機量，第一次廣泛進入個人電腦的世界，帶給我們巨大的刺激。執行緒並不難產生，要它們分工可以，但要它們合作就得相當花心思了。執行緒不一定帶來好處，運用不好它會在執行效率上懲罰你。</p>
  <p ALIGN="JUSTIFY">執行緒是 Win32 作業系統和 Win32 
  程式設計上不可或缺的重要環節，每一本重量級的書籍都不會忽略這個題目（請參考附錄Ｂ）。但是這些書多半僅以一章（有的甚至是一節）來介紹這個題目。不夠，真的不夠。我們缺乏一本兼具理論並重實際的多緒程式設計書籍。這本書很早就在 
  Addison Welsey 
  的書目上引起我的注意。它的內容，的確兼具理論並重實際。它的輕薄短小，也在大部頭書當道的今天，讓做為讀者的我心情輕鬆不少。不過，執行緒這個主題是不可能讓我們輕鬆的，同步控制、執行緒通訊、資料一致性...，讀這本書還是請你安裝一下自己的精神。</p>
  <p ALIGN="JUSTIFY">對於這本翻譯書，我有以下幾點說明：</p>
  <p ALIGN="JUSTIFY">1. 
  譯本中的範例程式碼直接取自書附碟片中的實例。如果與原書內容稍有出入，那是因為作者最後又做的一點點小變動。我想，以碟片內容為主會比較實際。通常在差異之處我會以譯註的方式告訴你。</p>
  <p ALIGN="JUSTIFY">2. 
  這本譯作保留了相當多的原文技術名詞。這是一種嘗試，主要是考慮到這本書的潛在讀者。如果不講原文名詞，可能他們反而要倒譯回去，那麼本書就適得其反了。許多地方我不厭其煩地在中文名詞後面加上原文名詞，為的也是同樣的原因。</p>
  <p ALIGN="JUSTIFY">「執行緒」這項技術非常重要，當支援多處理器（CPU）的作業系統逐漸普及，當多處理器的 
  PC 
  也逐漸普及，我相信「執行緒」是每一位技術人員都必須擁有的技術。即使是現在，「執行緒」能夠提高程式的反應度，也是高級技術人員應該追求的技術。</p>
  <p>侯俊傑 1997.01.30 于新竹</font></p>
  <p>　</p>
  <p><a name="【導讀】"><font color="#FF0000">【導讀】</font></a></p>
  <font FACE="華康特粗黑體" SIZE="6"><p ALIGN="CENTER">前言</font><font
  FACE="華康仿宋體" SIZE="1"></p>
  </font><font SIZE="1"><p ALIGN="JUSTIFY"></font><font size="3">1992 <font FACE="細明體">年，我參加了第二屆的</font> 
  Microsoft Professional Developers Conference<font FACE="細明體">，當時</font> Win32 <font
  FACE="細明體">首次對大量觀眾展示。這是一個重大的事件，其中有許多蠱魅的新技術第一次亮相。觀眾不斷地對展示的東西喝采。當我看到這些新技術，我身上</font> 
  Unix <font FACE="細明體">的那一部份說『時候到了』，而</font> Windows 3.1 <font
  FACE="細明體">的那一部份則是高呼『哈利路亞』。</p>
  <p ALIGN="JUSTIFY">五年過去了，好幾版</font> Windows NT <font FACE="細明體">問世了。我愈是深入此書，愈是瞭解</font>1992 
  <font FACE="細明體">年的那場盛宴之中我的瞭解多麼貧乏。我聽過許多「睿智」的話，像是「為</font> 
  MDI <font FACE="細明體">程式的每一個視窗準備一個執行緒」之類，事實上根本錯誤。有些技術（諸如</font> 
  overlapped I/O<font FACE="細明體">）很明顯地被曲解。</p>
  <p ALIGN="JUSTIFY">當我鑽研此書，我發現許多其他書籍和文章從頭到尾描述了各式各樣的</font> 
  Win32 <font FACE="細明體">函式，卻很少著墨在如何使用它們，或如何搭配其他函式使用。某些函式，例如</font> 
  MsgWaitForMultipleObjects()<font FACE="細明體">，是</font> Win32 <font
  FACE="細明體">程式的運轉中心，卻幾乎沒有任何範例程式正確使用過它。在我所發現的文件給了我太多的挫敗之後，我決定儘可能以實務導向的方式完成此書，如此一來你就能看到那些</font> 
  Win32 <font FACE="細明體">函式一起合作的情景。</p>
  <p ALIGN="JUSTIFY">這本書的讀者群很廣，</font>Win16 <font FACE="細明體">和</font> 
  Unix <font FACE="細明體">上的程式開發者欲移轉到</font> Win32<font
  FACE="細明體">，或是有經驗的</font> Win32 <font FACE="細明體">程式開發者，都是我的對象。你會發現一些不曾看過的問答，像是「為什麼</font> 
  _beginthreadex() <font FACE="細明體">真的很重要」等等。程式範例從基本層面到同步機制，到多緒</font> 
  COM <font FACE="細明體">和</font> ISAPI <font FACE="細明體">應用程式，都有。</p>
  <p ALIGN="JUSTIFY">這是一本可以讓你上手實驗「</font>Win32 <font
  FACE="細明體">執行緒」的書。我描述了基礎觀念，如果你需要更理論性的知識，你得多看點其他資料。執行緒的大部份問題都已經被像</font> 
  Dijkstra <font FACE="細明體">和</font> Courtois <font FACE="細明體">那樣的人在</font> 
  25 <font FACE="細明體">年前就解決掉了。他們的論文直到今天還適用。</p>
  <p ALIGN="JUSTIFY">如果你對那些只挑軟柿子吃而故意忽略困難部份的書籍感到絕望，我希望本書能夠讓你絕地逢生。某些章節是經過了長時間的實驗、多篇相關文章（來自雜誌、期刊、</font>Microsoft 
  Knowledge Base<font FACE="細明體">）的閱讀、眾多原始碼的剖析之後，萃鍊而得。像「執行緒與</font> 
  C runtime <font FACE="細明體">函式庫以及</font> MFC <font FACE="細明體">的關係」這種主題，我保證你會從中獲得許多閃亮寶石。</p>
  <p ALIGN="JUSTIFY">許多程式員對於執行緒是既期待又怕受傷害。</font>Unix 
  <font FACE="細明體">的人嘲笑它，因為行程（</font>process<font
  FACE="細明體">）看起來就已經不錯了。</font>Win16 <font FACE="細明體">的人也嘲笑它，因為</font> 
  PeekMessage() <font FACE="細明體">也運作得很好嘛！我寫這本書時首要認識的一個關鍵問題就是：如果有任何一個人在乎所謂的執行緒，他為的是什麼？</p>
  <p ALIGN="JUSTIFY">如果你開發的是伺服器（</font>server<font FACE="細明體">）產品，你就應該對執行緒深深在乎，因為</font> 
  I/O completion ports <font FACE="細明體">使用它。</font>I/O completion ports <font
  FACE="細明體">是唯一能夠搭配</font> Win32 sockets <font FACE="細明體">或</font> 
  named pipes <font FACE="細明體">完成高效率</font> I/O <font FACE="細明體">的方法。請你「跑」到第６章看個明白（用走的太慢了）。</p>
  <p ALIGN="JUSTIFY">如果你開發的是</font> Web <font FACE="細明體">產品，</font>IIS<font
  FACE="細明體">（</font>Internet Information Server<font FACE="細明體">）的擴充軟體也是靠多執行緒</font> 
  DLLs <font FACE="細明體">完成。這種技術的背景觀念散佈於整本書，而第</font>16<font
  FACE="細明體">章告訴你如何施行那些觀念。</p>
  <p ALIGN="JUSTIFY">本書第一篇的程式是以</font> C <font FACE="細明體">完成，</font>C++ 
  <font FACE="細明體">的份量很少。從第二篇開始我們就往</font> C++ <font
  FACE="細明體">移動了。一如我在第９章所說，</font>C++ <font
  FACE="細明體">是大勢所趨，不論你是否使用</font> MFC<font FACE="細明體">。如果你的</font> 
  C++ <font FACE="細明體">根基不穩，我希望你特別注意一下第９章。</font></font><font
  FACE="華康粗圓體" size="6"></p>
  <p></font><font FACE="華康粗圓體" size="4" color="#0000FF">誰應該讀這本書</font><font
  FACE="細明體" size="3"></p>
  <p ALIGN="JUSTIFY">凡是</font><font size="3"> C/C++ <font FACE="細明體">程式開發人員，並有</font> 
  Windows <font FACE="細明體">程式設計經驗（不論是</font> Win16 <font
  FACE="細明體">或</font>Win32<font FACE="細明體">），企圖對執行緒、核心物件、</font>overlapped 
  I/O in Win32 <font FACE="細明體">獲得更堅實之認識者，本書就是針對你們而寫的。本書談的是</font> 
  API <font FACE="細明體">函式的使用、你會遭遇的問題、以及</font> Windows 
  <font FACE="細明體">架構對其用途的影響。</p>
  <p ALIGN="JUSTIFY">讀過本書之後，你將有能力分析哪裡是執行緒可以發揮效用的地方，哪裡是你應該閃躲它們的地方。幾乎整本書的重點都放在產生真正可用的程式。神秘手法以及不安全的設計已經被我排除了。</font></p>
  <p ALIGN="JUSTIFY">Unix <font FACE="細明體">程式員將會發現，</font>Win32 <font
  FACE="細明體">和</font> Unix <font FACE="細明體">之間有著基礎觀念上的差異。</font></font><font
  FACE="華康粗圓體" size="6"></p>
  <p></font><font FACE="華康粗圓體" size="4" color="#0000FF">本書架構</font><font
  FACE="細明體" size="3"></p>
  <p ALIGN="JUSTIFY">本書的第一篇，「上路吧，執行緒」，為你建立必要的基礎，包括執行緒的啟動和結束、核心物件、激發和未激發狀態的意義、同步機制及其用途。有經驗的</font><font
  size="3"> Win32 <font FACE="細明體">程式員或許可以跳過這一部份。不過第６章所討論的主題（諸如</font> 
  I/O completion ports<font FACE="細明體">），是非常重要的題目，而且總的來說，其文件非常貧乏。</p>
  <p ALIGN="JUSTIFY">本書的第二篇，「多緒程式設計的工具與策略」，介紹</font> 
  C runtime <font FACE="細明體">函式庫和</font> MFC <font FACE="細明體">對執行緒的支援、如何在</font> 
  USER <font FACE="細明體">和</font> GDI <font FACE="細明體">的限制之下施行多執行緒、如何產生一個</font> 
  DLL<font FACE="細明體">、如何對多緒程式除錯。這一部份的許多資訊來自於我們的研究和實作經驗。</p>
  <p ALIGN="JUSTIFY">本書的第三篇，「真實世界中的多緒應用程式」，談論如何組織一個程式，使它有效支援多執行緒。本篇示範兩個真實世界中的應用軟體，第一個是個</font> 
  freethreaded OLE automation server<font FACE="細明體">，第二個是</font> ISAPI <font
  FACE="細明體">程式，是個</font> IIS<font FACE="細明體">（</font>Internet 
  Information Server<font FACE="細明體">）擴充軟體，示範如何和</font> JET <font
  FACE="細明體">資料庫交談。</font></font><font FACE="華康粗圓體" size="6"></p>
  <p></font><font FACE="華康粗圓體" size="4" color="#0000FF">關於範例程式</font><font
  FACE="細明體" size="3"></p>
  <p ALIGN="JUSTIFY">整本書中我用了許多文字模式程式來示範觀念。有些人不喜歡這種選擇，但我相信一個</font><font
  size="3"> 50~100 <font FACE="細明體">行的程式絕對比一個有著訊息迴路、資源檔案、視窗函式</font>...<font
  FACE="細明體">並且超過</font> 750 <font FACE="細明體">行的</font> Windows <font
  FACE="細明體">程式更能夠集中讀者的目光。讀這本書不會看到太多與使用者介面相關的東西。我相信本書的範例程式以其目前的形態對你會比較有幫助。</p>
  <p ALIGN="JUSTIFY">面對這些範例程式，我使用多方的錯誤檢驗。雖然這些檢驗導至程式碼看起來有些雜亂，但是錯誤檢驗對於生產一個真正的應用軟體很重要，對於一本書也很重要。</font></font><font
  FACE="華康粗圓體" size="6"></p>
  <p></font><font color="#0000FF" FACE="華康粗圓體" size="4">相關閱讀</font><font
  FACE="細明體" size="3"></p>
  <p ALIGN="JUSTIFY">有兩樣東西是任何時候你嘗試寫任何</font><font size="3"> 
  Win32 <font FACE="細明體">程式時應該要準備的。第一樣東西是</font> 
  Microsoft Developer Network<font FACE="細明體">。其光碟片內含不可置信的巨量技術資料，包括</font> 
  Microsoft Knowledge Base<font FACE="細明體">、編譯器和</font> Win32 <font
  FACE="細明體">的完整手冊、以及</font> Microsoft Systems Journal<font
  FACE="細明體">。</p>
  <p ALIGN="JUSTIFY">第二樣東西是</font> Jeffrey Richter <font FACE="細明體">的一本卓越書籍：</font><i><b>Advanced</b></i> 
  <i><b>Windows</b></i> <i><b>NT </b></i>: <i>The Developers Guide to the Win32 API for 
  Windows NT 3.5 and Windows NT</i><font FACE="細明體">（</font>Microsoft Press<font
  FACE="細明體">，</font>1995<font FACE="細明體">）。雖然其中遺漏了某些</font> 
  NT 3.51 <font FACE="細明體">的新東西，但其他方面非常有價值。</p>
  <p ALIGN="JUSTIFY">譯註：</font>Jeffrey <font FACE="細明體">的書已出至第３版，名為</font> 
  <i><b>Advanced Windows </b>Third Edition</i>. <font FACE="細明體">它的小標題寫著：</font>for 
  Windows 95 &amp; Windows NT 4.0<font FACE="細明體">。</font></font></p>
  <p>　</p>
  <p><a name="【目錄】"><font color="#FF0000">【目錄】</font></a></p>
  <p>常見問答集（Frequently Asked Questions）<br>
  前言<br>
  <br>
  <font color="#0000FF">第一篇 上路吧，執行緒</font><br>
  <br>
  第１章 為什麼要「千頭萬緒」<br>
  一條曲折的路<br>
  與執行緒共枕<br>
  為什麼終端用戶也需要多緒多工<br>
  Win32 基礎<br>
  Context Switching<br>
  Race Conditions（競速狀態）<br>
  Atomic Operations（不可分割的動作）<br>
  執行緒之間如何通訊<br>
  好消息與壞消息<br>
  <br>
  <font color="#0000FF">第２章 執行緒的第一次接觸</font><br>
  產生一個執行緒<br>
  使用多個執行緒的結果<br>
  核心物件（Kernel Objects）<br>
  執行緒結束碼（Exit Code）<br>
  結束一個執行緒<br>
  錯誤處理<br>
  背景列印（Background Printing）<br>
  成功的秘訣<br>
  <br>
  <font color="#0000FF">第３章 快跑與等待<br>
  　　　　看似閒暇卻忙碌（Busy Waiting）</font><br>
  效能監視器（Performance Monitor）<br>
  等待一個執行緒的結束<br>
  叮咚：被激發的物件（Signaled Objects）<br>
  等待多個物件<br>
  在一個 GUI 程式中等待<br>
  提要<br>
  <br>
  <font color="#0000FF">第４章 同步控制（Synchronization）</font><br>
  Critical Sections（關鍵區域、臨界區域）<br>
  死結（Deadlock）<br>
  哲學家吃飯問題（The Dining Philosophers）<br>
  互斥器（Mutexes）<br>
  號誌（Semaphores）<br>
  事件（Event Objects）<br>
  從 Worker 執行緒中顯示輸出<br>
  Interlocked Variables<br>
  提要：關於同步機制（Synchronization Mechanisms）<br>
  <br>
  <font color="#0000FF">第５章 不要讓執行緒成為脫韁野馬</font><br>
  乾淨地中止一個執行緒<br>
  執行緒優先權（Thread Priority）<br>
  初始化一個執行緒<br>
  提要<br>
  <br>
  <font color="#0000FF">第６章 Overlapped I/O，在你身後變戲法</font><br>
  Win32 檔案操作函式<br>
  被激發的 File Handles<br>
  被激發的 Event Objects<br>
  非同步程序呼叫（Asynchronous Procedure Calls，APCs）<br>
  對檔案做 Overlapped I/O 的缺點<br>
  I/O Completion Ports<br>
  對 Sockets 使用 Overlapped I/O<br>
  提要<br>
  <br>
  第二篇 多緒程式設計的工具與手法<br>
  <br>
  <font color="#0000FF">第７章 資料一致性（Data Consistency）</font><br>
  認識 volatile 關鍵字<br>
  Referential Integrity<br>
  The Readers/Writers Lock<br>
  我需要鎖定嗎？<br>
  Lock Granularity<br>
  提要<br>
  <br>
  <font color="#0000FF">第８章 使用 C Run-time Library</font><br>
  什麼是 C Runtime Library 多緒版本<br>
  選擇一個多緒版本的 C Runtime Library<br>
  以 C Runtime Library 啟動執行緒<br>
  哪一個好：CreateThread() 抑或 _beginthreadex()？<br>
  避免 stdio.h<br>
  一個安全的多緒程式<br>
  結束行程（Process）<br>
  為什麼你應該避免 _beginthread()<br>
  提要<br>
  <br>
  <font color="#0000FF">第９章 使用 C++</font><br>
  處理有問題的 _beginthreadex() 函式原型<br>
  以一個物件啟動一個執行緒<br>
  建立比較安全的 Critical Sections<br>
  建立比較安全的 Locks<br>
  建立可交替授受（Interchangeable）的 locks<br>
  異常情況（Exceptions）的處理<br>
  提要<br>
  <br>
  <font color="#0000FF">第10章 MFC 中的執行緒</font><br>
  在 MFC 中啟動一個 Worder 執行緒<br>
  安全地使用 AfxBeginThread() 的傳回值<br>
  在 MFC 中啟動一個 UI 執行緒（User Interface Thread）<br>
  和 MFC 物件共處<br>
  MFC 的同步控制<br>
  MFC 對於 MsgWaitForMultipleObjects() 的支援<br>
  提要<br>
  <br>
  <font color="#0000FF">第11章 GDI 與視窗管理</font><br>
  執行緒的訊息佇列<br>
  訊息如何周遊列國<br>
  GUI 效率問題<br>
  以 Worker 執行緒完成多緒版 MDI 程式<br>
  多個上層視窗（Top Level Windows）如何是好？<br>
  執行緒之間的通訊<br>
  NT 的影子執行緒（shadow thread）<br>
  關於 &quot;Cancel&quot; 對話盒<br>
  鎖住 GDI 物件<br>
  提要<br>
  <br>
  <font color="#0000FF">第12章 除錯</font><br>
  使用 Windows NT<br>
  有計劃地對付錯誤<br>
  Bench Testing<br>
  執行緒對話窗<br>
  運轉記錄（Logging）<br>
  Memory Trails<br>
  硬體除錯暫存器<br>
  科學方法<br>
  提要<br>
  <br>
  <font color="#0000FF">第13章 行程之間的通訊（Interprocess Communication）</font><br>
  以訊息佇列權充資料轉運中心<br>
  使用共享記憶體（Shared Memory）<br>
  使用指標指向共享記憶體（Shared Memory）<br>
  較高層次的行程通訊（IPC）<br>
  提要<br>
  <br>
  <font color="#0000FF">第14章 建造 DLLs</font><br>
  DLL 的通告訊息（Notifications）<br>
  通告訊息（Notifications）的問題<br>
  DLL 進入點的依序執行（Serialization）特性<br>
  MFC 中的 DLL 通告訊息（Notifications）<br>
  餵食給 Worker 執行緒<br>
  執行緒區域儲存空間（Thread Local Storage，TLS）<br>
  _declspec(thread)<br>
  資料的一致性<br>
  提要<br>
  <br>
  第三篇 真實世界中的多緒應用程式<br>
  <br>
  <font color="#0000FF">第15章 計劃一個應用程式</font><br>
  多執行緒的理由<br>
  要執行緒還是要行程？<br>
  多緒程式的架構<br>
  評估既有程式碼的適用性<br>
  對 ODBC 做計劃<br>
  他人開發的函式庫（Third-Party Libraries）<br>
  提要<br>
  <br>
  <font color="#0000FF">第16章 ISAPI</font><br>
  Web 伺服器及其工作原理<br>
  ISAPI<br>
  IS2ODBC 範例程式<br>
  提要<br>
  <br>
  <font color="#0000FF">第17章 OLE，ActiveX，COM</font><br>
  COM 的執行緒模型（COM Threading Models）<br>
  AUTOINCR 範例程式<br>
  提要<br>
  <br>
  附錄Ａ MTVERIFY 巨集<br>
  附錄Ｂ 更多的資訊</p>
</blockquote>

<hr>

<p>　</p>
</body>
</html>
