<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<meta content="text/html; charset=big5" http-equiv="Content-Type">
<meta content="Microsoft FrontPage 3.0" name="GENERATOR">
<title>《Refactoring》中文版 繁體</title>
</head>

<body background %22bgColor=-#ffffff%22%22 tppabs="http://jjhou.boolan.com/bgColor=%22#ffffff%22" text="#000000">

<hr>

<p align="center"><font color="#0000FF">四刷 0500 冊 (2007/01)&nbsp;&nbsp;<br>
三刷 0500 冊 (2005/11)&nbsp;&nbsp;<br>
二刷 1000 冊 (2003/11)&nbsp;&nbsp;<big><big><br>
</big></big>一刷 2000 冊 (2003/08)&nbsp;&nbsp;</font></p>

<h2 align="center"><font color="#804040">《重構》<br>
<small><small>— 改善既有程式的設計</small></small> <small><small>— </small></small></font></h2>

<p align="center"><font color="#804040">（繁體版）</font></p>

<h2 align="center"><small><font color="#800000">Refactoring<small> - Improving the Design 
of Existing Code</small></font></small></h2>

<h2 align="center"><font color="#800000"><small>侯捷 / 熊節 譯</small></font></h2>

<p align="center"><img src="refactoring-b5.jpg" tppabs="http://jjhou.boolan.com/refactoring-b5.jpg" alt="refactoring-b5.jpg (82283 bytes)"
width="283" height="359"></p>

<p align="center"><a target="main" href="refactoring-b5-full.jpg" tppabs="http://jjhou.boolan.com/refactoring-b5-full.jpg">封面封底全圖</a></p>

<p align="center">英文版勘誤 ：<a href="javascript:if(confirm(%27http://www.refactoring.com/errata.html  \n\nThis file was not retrieved by Teleport Ultra, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?%27))window.location=%27http://www.refactoring.com/errata.html%27" tppabs="http://www.refactoring.com/errata.html"
target="_blank">http://www.refactoring.com/errata.html</a></p>

<p align="center"><a href="errata-refactoring.txt.htm" tppabs="http://jjhou.boolan.com/errata-refactoring.txt.htm" target="main">繁體中文版勘誤</a></p>

<p align="center">侯捷推薦相關書籍：《<a
href="jjtbooks-refactoring-to-patterns.htm" tppabs="http://jjhou.boolan.com/jjtbooks-refactoring-to-patterns.htm" target="main"><font color="#0000FF">Refactoring 
to Patterns</font></a>》,《Design Patterns》</p>

<hr>

<blockquote>
</blockquote>

<p>□中譯書名：重構 — 改善既有程式的設計<br>
□適合對象：高階程式員<br>
□內容特色：將如何重構既有系統的步驟系統化地加以整理和描述。使用Java語言。<br>
□製作特色：含 index，網片輸出，<strong><font color="#000000">精裝</font></strong>，<font
color="#FF0000">紅</font><font color="#0000FF">藍</font>白書籤絲條。</p>

<p><font color="#000000">開放</font>檔案如下：<font color="#000000">（請注意，預覽品與正式出版品之間可能會有微小差異）</font></p>
<div align="left">

<table borderColorDark="#000000" width="509" borderColorLight="#cc3300" border="1">
<TBODY>
  <tr>
    <td width="301" bgColor="#c0c0c0"><font color="#000000">檔名</font></td>
    <td width="104" bgColor="#c0c0c0"><font color="#000000">內容</font></td>
    <td width="86" bgColor="#c0c0c0"><font color="#000000">大小 bytes</font></td>
  </tr>
  <tr>
    <td width="301"><a target="main" href="refactoring-ch1-ch6.pdf" tppabs="http://jjhou.boolan.com/refactoring-ch1-ch6.pdf">refactoring-ch1-ch6.pdf</a><br>
    <br>
    不需密碼即可開啟。<br>
    <font color="#000000">檔案含書籤（目錄連結）<br>
    <br>
    </font><font color="#FF0000">請注意</font><font color="#000000">：本書之所有 
    refactoring name 和<br>
    bad smells 皆保留原文不譯。<br>
    </font></td>
    <td width="104">譯序 by 侯捷<br>
    譯序 by 熊節<br>
    目錄<br>
    原序<br>
    前言<br>
    1~6章<br>
    索引</td>
    <td width="86">2,151,797<br>
    </td>
  </tr>
  <tr>
    <td width="301"><a href="efile-refactor-chap01.zip" tppabs="http://jjhou.boolan.com/efile-refactor-chap01.zip" target="main">efile-refactoring-chap01.zip</a><br>
    <br>
    </td>
    <td width="104">第一章<br>
    程式源碼（by 侯捷）</td>
    <td width="86">9,855</td>
  </tr>
</TBODY>
</table>
</div>

<p>如欲下載，請將滑鼠移至上述 hyperlink，按右鍵，再選<font
color="#000000">【另存目標...】</font>即可。</p>

<p>　</p>
<font FACE="華康粗圓體" LANG="ZH-TW" COLOR="#ffffff">

<p ALIGN="left"></font><a name="foreword-by-jjhou"><font face="華康粗圓體"
lang="ZH-TW" size="6">譯序</font><font FACE="Footlight MT Light,Times New Roman">by</font><font
FACE="華康粗圓體" LANG="ZH-TW">侯捷</a></p>
</font><font FACE="華康粗明體" LANG="ZH-TW" SIZE="5">

<p ALIGN="JUSTIFY"></font><font FACE="華康粗明體" LANG="ZH-TW" size="6">看</font><font
FACE="細明體" LANG="ZH-TW" size="3">過鐵路道班工人嗎？提著手持式砸道機，機身帶著鈍鈍扁扁的鑽頭，在鐵道上、枕木間賣力地「砍劈鑽鑿」。他們在做什麼？他們在使路基上的碎石塊（道碴）因持續劇烈的震動而翻轉方向、滑動位置，甚至震碎為更小石塊填滿縫隙，以求道碴更緊密契合，提供鐵道更安全更強固的體質。</p>

<p ALIGN="JUSTIFY">當「重構」（</font><font size="3">refactoring<font
FACE="細明體" LANG="ZH-TW">）映入眼簾，我的大腦牽動「道班工人</font>+<font
FACE="細明體" LANG="ZH-TW">電動砸道機</font>+<font FACE="細明體" LANG="ZH-TW">枕木道碴」這樣一幅聯想畫面。「重構」一詞非常清楚地說明了它自身的意義和價值：在不破壞可察功能的前提下，藉由搬移、提煉、打散、凝聚…，改善事物的體質。很多人認同這樣一個信念：「非常的建設需要非常的破壞」，但是現役的應用軟體、構築過半的專案、運轉中的系統，容不得推倒重來。這時候，在不破壞可察功能的前提下改善體質、強化當前的可讀性、為將來的擴充性和維護性做準備、乃至於在過程中找出潛伏的「臭蟲」，就成了大受歡迎的穩步前進的良方。</p>

<p ALIGN="JUSTIFY">做為一個程式員，任誰都有看不順眼手上程式碼的經驗</font> 
<font FACE="細明體" LANG="ZH-TW">程式碼來自你鄰桌那個菜鳥，或三個月前的自己。面臨此境，有人選擇得過且過；然而根據我對「程式員」人格特質的了解，更多人盼望插手整頓。挽起袖子劍及履及，其勇可嘉其慮未縝。過去或許不得不暴虎憑河，忍受風險。現在，有了嚴謹的重構準則和嚴密的重構手法，「穩定中求發展」終於有了保障。</p>

<p ALIGN="JUSTIFY">是的，把重構的概念和想法逐一落實在嚴謹的準則和嚴密的手法之中，正是這本《</font><font
FACE="Book Antiqua" COLOR="#0000ff"><i>Refactoring</i></font><font FACE="細明體"
LANG="ZH-TW">》的最大貢獻。重構</font>?! <font FACE="細明體" LANG="ZH-TW">呵呵，上進的程式員每天的進行式，從來不新鮮，但要強力保證「維持程式原有的可察功能，不帶進新臭蟲」，重構就不能是一項靠著天份揮灑的藝術，必須是一項工程。</p>
</font><font FACE="華康中黑體" LANG="ZH-TW">

<p ALIGN="JUSTIFY"></font></font><font face="華康中黑體" lang="ZH-TW" size="3">■</font><font
size="3"><font FACE="華康中黑體" LANG="ZH-TW">我對本書的看法</p>
</font><font FACE="細明體" LANG="ZH-TW">

<p ALIGN="JUSTIFY">初初閱讀本書，屢屢感覺書中所列的許多重構目標過於平淡，重構步驟過於瑣屑。這些我們平常也都做、習慣大氣揮灑的動作，何必以近乎枯燥的過程小步前進？然後，漸漸我才體會，正是這樣的小步與緩步前進，不過激，不躁進，再加上完整的測試配套（是的，測試之於重構極其重要），才是「不帶來破壞，不引入臭蟲」的最佳保障。我個人其實不敢置信有誰能夠乖乖地按步遵循實現本書所列諸多被我（從人的角度）認為平淡而瑣屑的重構步驟。我個人認為，本書的最大價值，除了呼籲對軟體品質的追求態度，以及對重構「工程性」的認識，最終最重要的價值還在於：建立起吾人對於「目前和未來之自動化重構工具」的基本理論和實作技術上的認識與信賴。人類眼中平淡瑣屑的步驟，正是自動化重構工具的基礎。機器缺乏人類的「大局觀」智慧，機器需要的正是切割為一個一個極小步驟的指令。一板一眼，一次一點點，這正是機器所需要的，也正是機器的專長。</p>

<p ALIGN="JUSTIFY">本書第</font>14<font FACE="細明體" LANG="ZH-TW">章提到，</font>Smalltalk<font
FACE="細明體" LANG="ZH-TW">開發環境已含自動化重構工具。我並非</font>Smalltalk 
guy<font FACE="細明體" LANG="ZH-TW">，我沒有用過這些工具。基於技術的飛快滾動（或我個人的孤陋寡聞），或許如今你已經可以在</font>Java, 
C++ <font FACE="細明體" LANG="ZH-TW">等物件導向編程環境中找到這一類自動化重構工具。</p>

<p ALIGN="JUSTIFY">軟體技術圈內，重構（</font>refactoring<font FACE="細明體"
LANG="ZH-TW">）常常被拿來與設計範式（</font>design patterns<font
FACE="細明體" LANG="ZH-TW">）並論。書籍市場上，《</font><font
FACE="Book Antiqua" COLOR="#0000ff"><i>Refactoring</i></font><font FACE="細明體"
LANG="ZH-TW">》也與《</font><font FACE="Book Antiqua" COLOR="#0000ff"><i>Design 
Patterns</i></font><font FACE="細明體" LANG="ZH-TW">》齊名。</font>GoF<font
FACE="細明體" LANG="ZH-TW">曾經說『</font><font FACE="華康仿宋體" LANG="ZH-TW"
COLOR="#800080">設計範式為重構提供了目標</font><font FACE="細明體"
LANG="ZH-TW">』，但本書作者</font>Martin<font FACE="細明體" LANG="ZH-TW">亦言『</font><font
FACE="華康仿宋體" LANG="ZH-TW" COLOR="#800080">本書並沒有提供助你完成所有知名範式的重構手法，甚至連 
GoF 的23個知名範式都沒有能夠全部涵蓋。</font><font FACE="細明體"
LANG="ZH-TW">』我們可以從這些話中理解技術的方向，以及書籍所反映的侷限。我並不完全贊同</font>Martin<font
FACE="細明體" LANG="ZH-TW">所言『</font><font FACE="華康仿宋體" LANG="ZH-TW"
COLOR="#800080">哪怕你手上有一個糟糕的設計或甚至一團混亂，你也可以藉由重構將它加工成設計良好的程式碼。</font><font
FACE="細明體" LANG="ZH-TW">』但我十分同意</font>Martin<font FACE="細明體"
LANG="ZH-TW">說『</font><font FACE="華康仿宋體" LANG="ZH-TW" COLOR="#800080">你會發現所謂設計不再是一切動作的前提，而是在整個開發過程中逐漸浮現出來。</font><font
FACE="細明體" LANG="ZH-TW">』我比較擔心，閱歷不足的程式員在讀過本書後可能發酵出「先動手再說，死活可重構」的心態，輕忽了事前優秀設計的重要性。任何技術上的說法都必須有基本假設；雖然重構（或更向上說</font>XP<font
FACE="細明體" LANG="ZH-TW">，</font>eXtreme Programming<font FACE="細明體"
LANG="ZH-TW">）的精神的確是「不妨先動手」，但若草率行事，代價還是很高的。重型開發和輕型開發各有所長，各有應用，世間並無萬應靈藥，任何東西都不能極端。過猶不及，皆不可取！</p>

<p ALIGN="JUSTIFY">當然，「重構工程」與「自動化重構工具」可為我們帶來相當大幅度的軟體品質提昇，這一點我毫無異議，並且非常期待<font
FACE="Wingdings">J</font> 。</p>
</font><font FACE="華康中黑體" LANG="ZH-TW">

<p ALIGN="JUSTIFY"></font></font><font face="華康中黑體" lang="ZH-TW" size="3">■</font><font
size="3"><font FACE="華康中黑體" LANG="ZH-TW">關於本書製作</p>
</font><font FACE="細明體" LANG="ZH-TW">

<p ALIGN="JUSTIFY">本書在翻譯與製作上保留了所有壞味道（</font>bad smell<font
FACE="細明體" LANG="ZH-TW">）、重構（</font>refactoring<font FACE="細明體"
LANG="ZH-TW">）、設計範式（</font>design patterns<font FACE="細明體"
LANG="ZH-TW">）的英文名稱，並表現以特殊字型；只在封面內頁、目錄、小節標題中相應地給出一個根據字面或技術意義而做的中文譯名。各種「壞味道」名稱儘量就其意義選用負面字眼，如泥團、夸夸、過長、過大、過多、情結、偏執、驚悚、狎暱、純稚、冗員…。這些其實都是助憶之用，與茶餘飯後的談資（以及讀者批評的根據<font
FACE="Wingdings">J</font> ）。</p>

<p ALIGN="JUSTIFY">原書各小節並無序號。為便利參考、檢索或討論時的方便，我為譯本加上了序號。</p>

<p ALIGN="JUSTIFY">本書保留相當份量的英文術語，時而英中並陳（英文為主，中文為輔）。這麼做的考量是，本書讀者不可能不知道</font>class, 
final, reference, public, package…<font FACE="細明體" LANG="ZH-TW">這些簡短的、與</font>Java<font
FACE="細明體" LANG="ZH-TW">編程息息相關的用詞。另一方面，我確實認為，中文書內保留經過挑選的某些英文術語，有利於整體閱讀效果。</p>

<p ALIGN="JUSTIFY">兩個需要特別說明的用詞是</font>Java<font FACE="細明體"
LANG="ZH-TW">編程界慣用的</font> &quot;field&quot; <font FACE="細明體"
LANG="ZH-TW">和</font> &quot;method&quot;<font FACE="細明體" LANG="ZH-TW">。它們相當於</font>C++ 
<font FACE="細明體" LANG="ZH-TW">的</font> &quot;data member&quot; <font
FACE="細明體" LANG="ZH-TW">和</font> &quot;member function&quot;<font FACE="細明體"
LANG="ZH-TW">。由於出現次數實在頻繁，為降低中英夾雜程度，我把它們分別譯為「欄位」和「函式」 
如果將</font> &quot;method&quot; <font FACE="細明體" LANG="ZH-TW">譯為「方法」，恐怕術語突出性不高。此外，本書將「創造建立新物件」的</font> 
&quot;create&quot; <font FACE="細明體" LANG="ZH-TW">動作譯為「創建」。「</font></font><font
FACE="Lucida Sans" size="2">static</font><font FACE="細明體" LANG="ZH-TW" size="3">欄位與</font><font
FACE="Lucida Sans" size="2">instance</font><font FACE="細明體" LANG="ZH-TW" size="3">欄位」、「</font><font
FACE="Lucida Sans" size="2">reference</font><font FACE="細明體" LANG="ZH-TW" size="3">物件與</font><font
FACE="Lucida Sans" size="2">value</font><font FACE="細明體" LANG="ZH-TW" size="3">物件」等等則保留部分英文，並選用如上的特殊字型。凡此總總，相信一進入書中您很快可以感受本書術語風格。</p>

<p ALIGN="JUSTIFY">本書還有諸多地方採中英並陳（中文為主，英文為輔）方式，意在告訴讀者，我們（譯者）深知自己的不足與侷限，惟恐造成您對中譯名詞的誤解或不習慣，所以附上原文。</p>

<p ALIGN="JUSTIFY">中文版（本書）已將英文版截至</font><font size="3">2003/06/18<font
FACE="細明體" LANG="ZH-TW">為止之勘誤，修正於紙本。</p>
</font><font FACE="華康中黑體" LANG="ZH-TW">

<p ALIGN="JUSTIFY"></font></font><font face="華康中黑體" lang="ZH-TW" size="3">■</font><font
size="3"><font FACE="華康中黑體" LANG="ZH-TW">一點點感想</p>
</font>

<p ALIGN="JUSTIFY">Martin Fowler<font FACE="細明體" LANG="ZH-TW">表現於原書的寫作風格是：簡潔，愛用代名詞和略稱。這使得讀者往往需要在字面上揣度推敲。我期盼（並相信）經過技術意義的反芻、中英術語的並陳、中文表述的努力，中文版（本書）在閱讀時間和理解時間和記憶深度上，較之英文版，能夠為以華文為母語的讀者提高</font>10<font
FACE="細明體" LANG="ZH-TW">倍以上的成效。</p>

<p ALIGN="JUSTIFY">本書由我和熊節先生合譯。熊節負責第一個</font>pass<font
FACE="細明體" LANG="ZH-TW">，我負責後繼工作。中文版（本書）為讀者帶來的閱讀和理解上的效益，熊節居於首功</font> 
<font FACE="細明體" LANG="ZH-TW">雖說做的是第一個</font>pass<font
FACE="細明體" LANG="ZH-TW">，我從初稿品質便可看出他多次反覆推敲和文字琢磨的刻痕。至於整體風格、中英術語的選定、版面的呈現、乃至於全盤技術內涵的表現，如果有任何差錯，責任都是我的<font
FACE="Wingdings">J</font> 。</p>

<p ALIGN="JUSTIFY">做為一個資訊技術教育者，以及一個資訊技術傳播者，我在超過</font>10<font
FACE="細明體" LANG="ZH-TW">年的寫譯歷程中，觀察了不同級別的技術書品在讀書市場上的興衰起伏。這些適可反映大環境下技術從業人員及學子們的某些面向和取向。我很高興看到我們的中文技術書籍（著譯皆含）從早期盈盈滿滿的初階語言用書，逐漸進化到中高階語言用書、作業系統、技術內核、程式庫</font></font><font
FACE="Courier New" size="2">/</font><font FACE="細明體" LANG="ZH-TW" size="3">框架、再至設計</font><font
FACE="Courier New" size="2">/</font><font FACE="細明體" LANG="ZH-TW" size="3">分析、軟體工程。我很高興看到這樣的變化。我很高興看到《</font><font
FACE="Book Antiqua" COLOR="#0000ff" size="3"><i>Design Patterns</i></font><font
FACE="細明體" LANG="ZH-TW" size="3">》、《</font><font FACE="Book Antiqua"
COLOR="#0000ff" size="3"><i>Refactoring</i></font><font FACE="細明體" LANG="ZH-TW"
size="3">》、《</font><font FACE="Book Antiqua" COLOR="#0000ff" size="3"><i>Agile</i></font><font
size="3">…<font FACE="細明體" LANG="ZH-TW">》、《</font><font FACE="Book Antiqua"
COLOR="#0000ff"><i>UML</i></font>…<font FACE="細明體" LANG="ZH-TW">》、《</font><font
FACE="Book Antiqua" COLOR="#0000ff"><i>XP</i></font>…<font FACE="細明體" LANG="ZH-TW">》之類的書在中文書籍市場中現身，並期盼它們有豐富的讀者。</p>

<p ALIGN="JUSTIFY">中文版（本書）支援網站有一個「術語</font> <font
FACE="細明體" LANG="ZH-TW">英中繁簡」對照表。如果您有需要，歡迎訪問，網址如下，並歡迎給我任何意見。謝謝。</font></font><font
FACE="細明體" LANG="ZH-TW" SIZE="2"></p>
</font><font FACE="華康中黑體" LANG="ZH-TW" SIZE="2">

<p ALIGN="JUSTIFY"></font><font FACE="華康中黑體" LANG="ZH-TW" size="3">侯捷</font><font
size="3"> 2003/06/18 <font FACE="細明體" LANG="ZH-TW">于臺灣</font>.<font
FACE="細明體" LANG="ZH-TW">新竹</font></font><font FACE="細明體" LANG="ZH-TW"
SIZE="2"></p>
</font><font size="2">

<p>jjhou@jjhou.com<font FACE="細明體" LANG="ZH-TW">（電子郵箱）<br>
</font>http://www.jjhou.com<font FACE="細明體" LANG="ZH-TW">（繁體）（術語對照表</font>http://www.jjhou.com/terms.htm<font
FACE="細明體" LANG="ZH-TW">）<br>
</font>http://jjhou.csdn.net<font FACE="細明體" LANG="ZH-TW">（簡體）（術語對照表</font>http:// 
jjhou.csdn.net/terms.htm<font FACE="細明體" LANG="ZH-TW">）</p>
</font></font><font FACE="細明體" LANG="ZH-TW" SIZE="2">

<p ALIGN="JUSTIFY">　</p>

<p ALIGN="JUSTIFY"></font><font FACE="細明體" LANG="ZH-TW" size="4">英文版目錄</font><font
FACE="細明體" LANG="ZH-TW" SIZE="2"></p>
</font>

<h4><font FACE="細明體" LANG="ZH-TW" SIZE="2"><a name="toc">Table Of Contents</a><!-- --></font></h4>
<!-- -->

<p><b>1. Refactoring, a First Example. </b><br>
The Starting Point. <br>
The First Step in Refactoring. <br>
Decomposing and Redistributing the Statement Method. <br>
Replacing the Conditional Logic on Price Code with Polymorphism. <br>
Final Thoughts. <b></p>
</b>

<p><br>
<b>2. Principles in Refactoring. </b><br>
Defining Refactoring. <br>
Why Should You Refactor? <br>
When Should You Refactor? <br>
What Do I Tell My Manager? <br>
Problems with Refactoring. <br>
Refactoring and Design. <br>
Refactoring and Performance. <br>
Where Did Refactoring Come From? <br>
<br>
<b>3. Bad Smells in Code. </b><br>
Duplicated Code. <br>
Long Method. <br>
Large Class. <br>
Long Parameter List. <br>
Divergent Change. <br>
Shotgun Surgery. <br>
Feature Envy. <br>
Data Clumps. <br>
Primitive Obsession. <br>
Switch Statements. <br>
Parallel Inheritance Hierarchies. <br>
Lazy Class. <br>
Speculative Generality. <br>
Temporary Field. <br>
Message Chains. <br>
Middle Man. <br>
Inappropriate Intimacy. <br>
Alternative Classes with Different Interfaces. <br>
Incomplete Library Class. <br>
Data Class. <br>
Refused Bequest. <br>
Comments. <br>
<br>
<b>4. Building Tests. </b><br>
The Value of Self-testing Code. <br>
The JUnit Testing Framework. <br>
Adding More Tests. <br>
<br>
<b>5. Toward a Catalog of Refactorings. </b><br>
Format of the Refactorings. <br>
Finding References. <br>
How Mature Are These Refactorings? <br>
<br>
<b>6. Composing Methods. </b><br>
Extract Method. <br>
Inline Method. <br>
Inline Temp. <br>
Replace Temp with Query. <br>
Introduce Explaining Variable. <br>
Split Temporary Variable. <br>
Remove Assignments to Parameters. <br>
Replace Method with Method Object. <br>
Substitute Algorithm. <br>
<br>
<b>7. Moving Features Between Objects. </b><br>
Move Method. <br>
Move Field. <br>
Extract Class. <br>
Inline Class. <br>
Hide Delegate. <br>
Remove Middle Man. <br>
Introduce Foreign Method. <br>
Introduce Local Extension. <br>
<br>
<b>8. Organizing Data. </b><br>
Self Encapsulate Field. <br>
Replace Data Value with Object. <br>
Change Value to Reference. <br>
Change Reference to Value. <br>
Replace Array with Object. <br>
Duplicate Observed Data. <br>
Change Unidirectional Association to Bidirectional. <br>
Change Bidirectional Association to Unidirectional. <br>
Replace Magic Number with Symbolic Constant. <br>
Encapsulate Field. <br>
Encapsulate Collection. <br>
Replace Record with Data Class. <br>
Replace Type Code with Class. <br>
Replace Type Code with Subclasses. <br>
Replace Type Code with State/Strategy. <br>
Replace Subclass with Fields. <br>
<br>
<b>9. Simplifying Conditional Expressions. </b><br>
Decompose Conditional. <br>
Consolidate Conditional Expression. <br>
Consolidate Duplicate Conditional Fragments. <br>
Remove Control Flag. <br>
Replace Nested Conditional with Guard Clauses. <br>
Replace Conditional with Polymorphism. <br>
Introduce Null Object. <br>
Introduce Assertion. <br>
<br>
<b>10. Making Method Calls Simpler. </b><br>
Rename Method. <br>
Add Parameter. <br>
Remove Parameter. <br>
Separate Query from Modifier. <br>
Parameterize Method. <br>
Replace Parameter with Explicit Methods. <br>
Preserve Whole Object. <br>
Replace Parameter with Method. <br>
Introduce Parameter Object. <br>
Remove Setting Method. <br>
Hide Method. <br>
Replace Constructor with Factory Method. <br>
Encapsulate Downcast. <br>
Replace Error Code with Exception. <br>
Replace Exception with Test. <br>
<br>
<b>11. Dealing with Generalization. </b><br>
Pull Up Field. <br>
Pull Up Method. <br>
Pull Up Constructor Body. <br>
Push Down Method. <br>
Push Down Field. <br>
Extract Subclass. <br>
Extract Superclass. <br>
Extract Interface. <br>
Collapse Hierarchy. <br>
Form Template Method. <br>
Replace Inheritance with Delegation. <br>
Replace Delegation with Inheritance. <br>
<br>
<b>12. Big Refactorings. </b><br>
Tease Apart Inheritance. <br>
Convert Procedural Design to Objects. <br>
Separate Domain from Presentation. <br>
Extract Hierarchy. <br>
</p>

<p><b>13. Refactoring, Reuse, and Reality. </b><br>
A Reality Check. <br>
Why Are Developers Reluctant to Refactor Their Programs? <br>
A Reality Check (Revisited). <br>
Resources and References for Refactoring. <br>
Implications Regarding Software Reuse and Technology Transfer. <br>
A Final Note. <br>
References. <br>
<br>
<b>14. Refactoring Tools. </b><br>
Refactoring with a Tool. <br>
Technical Criteria for a Refactoring Tool. <br>
Practical Criteria for a Refactoring Tool. <br>
Wrap Up. <br>
<br>
<b>15. Putting It All Together. </b></p>

<p><b>References. </b><br>
<b>List of Soundbites. </b><br>
<b>List of Refactorings. </b><br>
<b>Index</b><br>
</p>
</body>
</html>
