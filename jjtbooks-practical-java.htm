<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>

<head>
<meta content="text/html; charset=big5" http-equiv="Content-Type">
<meta content="Microsoft FrontPage 3.0" name="GENERATOR">
<title>《Practical Java》中文版 繁體</title>
</head>

<body background %22bgColor=-#ffffff%22%22 tppabs="http://jjhou.boolan.com/bgColor=%22#ffffff%22" text="#000000">

<hr>

<h2 align="center"><strong><font color="#0000FF"><small><small>一刷 2000 冊 (2003/08)&nbsp;&nbsp;</small></small></font></strong></h2>

<h2 align="center"><font color="#800000">《Practical Java》<br>
<small>中文版 （繁體）</small></font></h2>

<h2 align="center"><font color="#800000"><small>侯捷 / 劉永丹 譯</small></font></h2>

<p align="center"><img src="practical-java-b5.jpg" tppabs="http://jjhou.boolan.com/practical-java-b5.jpg"
alt="practical-java-b5.jpg (69294 bytes)" width="294" height="358"></p>

<p align="center"><a target="main" href="practical-java-b5-full.jpg" tppabs="http://jjhou.boolan.com/practical-java-b5-full.jpg">封面封底全圖</a></p>

<p align="center">本書範例&nbsp; <a href="PracticalJavaCode.zip" tppabs="http://jjhou.boolan.com/PracticalJavaCode.zip" target="main">PraticalJavaCode.zip</a></p>

<p align="center"><a href="errata-practical-java.txt.htm" tppabs="http://jjhou.boolan.com/errata-practical-java.txt.htm" target="main">繁體中文版勘誤</a></p>

<hr>

<blockquote>
</blockquote>

<p>□中譯書名（暫名）：Practical Java 中文版<br>
□適合對象：中高階 Java 程式員。<br>
□製作特色：與原文本頁頁對譯，含 index，網片輸出，<font
color="#000000">平裝</font>。<br>
□內容特色：68 條 Java編程準則與注意事項</p>

<p><font color="#000000">開放</font>檔案如下：</p>
<div align="left">

<table border="1" borderColorDark="#000000" borderColorLight="#cc3300" width="509">
<TBODY>
  <tr>
    <td bgColor="#c0c0c0" width="285"><font color="#000000">檔名</font></td>
    <td bgColor="#c0c0c0" width="120"><font color="#000000">內容</font></td>
    <td bgColor="#c0c0c0" width="86"><font color="#000000">大小 bytes</font></td>
  </tr>
  <tr>
    <td width="285"><a target="main" href="practical-java-chap1-3.pdf" tppabs="http://jjhou.boolan.com/practical-java-chap1-3.pdf">practical-java-chap1-3.pdf</a><p>不需密碼即可開啟。<br>
    <font color="#000000">檔案含簡略書籤（目錄連結）</font></td>
    <td width="120">扉頁、譯序、目錄、細目、前言、致謝、1-3章</td>
    <td width="86">　</td>
  </tr>
  <tr>
    <td width="285"><a href="PracticalJavaCode.zip" tppabs="http://jjhou.boolan.com/PracticalJavaCode.zip" target="main">PraticalJavaCode.zip</a></td>
    <td width="120">本書範例源碼<br>
    （原作者提供）</td>
    <td width="86">139,288</td>
  </tr>
</TBODY>
</table>
</div>

<p>不需密碼即可開啟。<font color="#000000">檔案不含書籤（目錄連結）</font>。</p>

<p>如欲下載，請將滑鼠移至上述 hyperlink，按右鍵，再選<font
color="#000000">【另存目標...】</font>即可。</p>

<p>　</p>
<font FACE="華康粗圓體" LANG="ZH-TW" SIZE="6" COLOR="#ffffff">

<p ALIGN="left"></font><font FACE="華康粗圓體" LANG="ZH-TW" SIZE="6"><a
name="foreword-by-jjhou">譯序</a><br>
</font><font FACE="Footlight MT Light,Book Antiqua">by </font><font FACE="華康粗圓體"
LANG="ZH-TW">侯捷</p>
</font><font FACE="細明體" LANG="ZH-TW" SIZE="2">

<p ALIGN="JUSTIFY"></font><font FACE="細明體" LANG="ZH-TW" size="3">面對</font><font
size="3">Java<font FACE="細明體" LANG="ZH-TW">，可從兩方面看待，一是語言，一是平台。本書談的是</font>Java<font
FACE="細明體" LANG="ZH-TW">語言，以下我所言種種，也是指</font>Java<font
FACE="細明體" LANG="ZH-TW">語言。</p>
</font>

<p ALIGN="JUSTIFY">Java<font FACE="細明體" LANG="ZH-TW">是一門優秀的物件導向編程語言（</font>Object 
Oriented Programming Language, OOPL<font FACE="細明體" LANG="ZH-TW">）。什麼是「物件導向」？如何才稱得上「優秀」？前者可定量定性，客觀；後者往往流於個人感受，主觀！所以雖然物件導向語言有著幾近一致的條件和門檻</font></font><font
FACE="細明體" LANG="ZH-TW" size="3">（<font color="#FF0000">註1</font>）（封裝、繼承、多型</font><font
size="3">…<font FACE="細明體" LANG="ZH-TW">），孰優孰劣卻是各人心中一把尺。儘管如此，無人可以否認</font>Java<font
FACE="細明體" LANG="ZH-TW">語言在</font>OOP<font FACE="細明體" LANG="ZH-TW">（物件導向編程）上擁有良好的特性和優越的表現。</p>

<p ALIGN="JUSTIFY"></font></font><font face="細明體" lang="ZH-TW" color="#FF0000"
size="3">註1：</font><font FACE="新細明體" LANG="ZH-TW" color="#408080" size="3">我常憶起網絡論壇上時可與聞的一種怪誕態度。有一派人士主張，</font><font
size="3" color="#408080" face="細明體" lang="ZH-TW">OO是一種思想，一種思考模式，任何語言都能夠實現它，因而侈言「C或assembly語言也能OO」。任何語言各有用途，這是完全正確的；OO是一種思維，這話也是對的。任何語言都能夠實現OO，這話對某些人也許是對的，對99.9999%的人是錯的。以non-OO語言實現OO思維，非但達成度極低，也非人人能為。Edmund 
Hillary（艾德蒙 希拉瑞）能達到的高度，你未必達得到 — </font><font
FACE="新細明體" LANG="ZH-TW" color="#408080" size="3">事實上你通常達不到。（註：Edmund 
Hillary是第一位登上聖母鋒的地球人，1953</font><font size="3"><font
FACE="細明體" LANG="ZH-TW"><font color="#408080"><font FACE="新細明體"><font
FACE="新細明體">年英格蘭遠征隊員。）</font></font></font></p>

<p ALIGN="JUSTIFY">我所謂良好的</font>OOP<font FACE="細明體" LANG="ZH-TW">特性，指的是</font>Java<font
FACE="細明體" LANG="ZH-TW">提供了許多讓程式員得以輕鬆表達物件導向技術與思維的語言關鍵字（</font>keywords<font
FACE="細明體" LANG="ZH-TW">）如</font>class, abstract, interface, extends, 
implements, public, protected, private, final, static, finalize…<font FACE="細明體"
LANG="ZH-TW">，又提供條理清晰結構分明的檔案組織方式如</font>package, 
import<font FACE="細明體" LANG="ZH-TW">，又擁有嚴謹而靈活的動態型別系統（</font>dynamic 
type system<font FACE="細明體" LANG="ZH-TW">）使得以提供</font>RTTI<font
FACE="細明體" LANG="ZH-TW">和</font>Reflection<font FACE="細明體" LANG="ZH-TW">機制，並擁有一個優秀、涵蓋面廣、擴充性強的標準程式庫（</font>Java 
Libraries<font FACE="細明體" LANG="ZH-TW">）。</p>

<p ALIGN="JUSTIFY">這些優秀的語言構件（</font>constructs<font FACE="細明體"
LANG="ZH-TW">）雖然好用易用，但不論就技術面或應用面或效率考量，還是有許多隱微細節散佈其中，例如</font>object 
creation, object initialization, Cloneable, Serializable, Equality, Immutability, 
Multithreading (Synchronization), Exception Handling…<font FACE="細明體" LANG="ZH-TW">，在在需要</font>Java<font
FACE="細明體" LANG="ZH-TW">程式員深入認識與理解。</p>

<p ALIGN="JUSTIFY">市面上</font>Java<font FACE="細明體" LANG="ZH-TW">書籍極多，專注於「編程主題式探討」並「以獨立條款呈現」的書籍比較少。這類書籍面向中高階讀者，不僅選題必須饒富價值、探討必須極為深刻，各主題最好還獨立以利選擇閱讀，卻又最好彼此前後呼應環環相扣，並附良好交叉索引，予讀者柳暗花明的強烈衝擊。此種「專題條款」式的表現風格，在</font>Scott 
Meyers<font FACE="細明體" LANG="ZH-TW">的《</font><font FACE="Book Antiqua"><i>Effective 
C++</i></font><font FACE="細明體" LANG="ZH-TW">》和《</font><font
FACE="Book Antiqua"><i>More Effective C++</i></font><font FACE="細明體" LANG="ZH-TW">》二書面世之後獲得許多讚揚，也引來許多追隨。</p>

<p ALIGN="JUSTIFY">《</font><font FACE="Book Antiqua"><i>Practical Java</i></font><font
FACE="細明體" LANG="ZH-TW">》和《</font><font FACE="Book Antiqua"><i>Effective Java</i></font><font
FACE="細明體" LANG="ZH-TW">》二書，對前述重要而基礎的技術細微處有著詳盡、深刻、實用的介紹和剖析和範例，又以獨立條款之姿展現，在內容的紮實度、可讀性、易讀性上表現均十分良好。為此，秉持並承繼我為</font>C++ 
<font FACE="細明體" LANG="ZH-TW">社群翻譯《</font><font FACE="Book Antiqua"><i>Effective 
C++</i></font><font FACE="細明體" LANG="ZH-TW">》、《</font><font
FACE="Book Antiqua"><i>More Effective C++</i></font><font FACE="細明體" LANG="ZH-TW">》的態度和機緣，我很開心再次由我負責，將《</font><font
FACE="Book Antiqua"><i>Practical Java</i></font><font FACE="細明體" LANG="ZH-TW">》和《</font><font
FACE="Book Antiqua"><i>Effective Java</i></font><font FACE="細明體" LANG="ZH-TW">》二書中譯本呈獻給</font>Java 
<font FACE="細明體" LANG="ZH-TW">社群。</p>

<p ALIGN="JUSTIFY">考慮本書讀者應已具備</font>Java<font FACE="細明體"
LANG="ZH-TW">編程基礎，對於各種英文術語已有良好的接受度，我在書中保留了許多英文術語，時而中英並陳，包括</font>class, 
object, interface, reference, instance, array, vector, stack, heap…<font
FACE="細明體" LANG="ZH-TW">，也包括涉及</font>Java<font FACE="細明體"
LANG="ZH-TW">關鍵字的一些用語如</font>private, public, protected, static, 
abstract…<font FACE="細明體" LANG="ZH-TW">，不勝枚舉（下頁另有一個扼要說明）。本書努力在字型變化上突顯不同類形的術語，以利讀者閱讀。本書支援網站有一個「術語<font
FACE="Wingdings">&nbsp;</font> 英中繁簡」對照表，歡迎訪問，網址如下。</p>

<p ALIGN="JUSTIFY">《</font><font FACE="Book Antiqua"><i>Practical Java</i></font><font
FACE="細明體" LANG="ZH-TW">》由劉永丹先生和我合力完成。永丹做前期初譯工作，我負責後繼的文字修潤、技術檢閱、大局風貌。永丹技術紮實，文字用心。沒有他的協助，本書不可能在這個時間以這樣的品質面世。謝謝永丹。</p>

<p ALIGN="JUSTIFY">本書每一章起始處都有作者匠心獨具收集的一些文摘語錄。我們雖勉力譯出，恐見識不足，貽笑大方，故均留下原文和出處，庶幾不誤讀者。</p>
</font><font FACE="華康中黑體" LANG="ZH-TW">

<p ALIGN="JUSTIFY">侯捷</font> 2003/07/08 <font FACE="細明體" LANG="ZH-TW">于臺灣</font>.<font
FACE="細明體" LANG="ZH-TW">新竹</p>
</font></font><font size="2">

<p>jjhou@jjhou.com<font FACE="細明體" LANG="ZH-TW">（電子郵箱）<br>
</font>http://www.jjhou.com<font FACE="細明體" LANG="ZH-TW">（繁體）（術語對照表</font>http://www.jjhou.com/terms.htm<font
FACE="細明體" LANG="ZH-TW">）<br>
</font>http://jjhou.csdn.net<font FACE="細明體" LANG="ZH-TW">（簡體）</font> <font
FACE="細明體" LANG="ZH-TW">（術語對照表</font>http:// jjhou.csdn.net/terms.htm<font
FACE="細明體" LANG="ZH-TW">）</p>
</font></font><font size="3" FACE="細明體" LANG="ZH-TW">

<p ALIGN="JUSTIFY">p.s. <font FACE="新細明體">本書已就英文版截至</font>2003/07/08<font
FACE="新細明體">之勘誤表修正於紙本。</font></p>

<p ALIGN="JUSTIFY"><font color="#0000FF">■本書術語翻譯與保留之大致原則：</font></p>
</font><font FACE="細明體" LANG="ZH-TW" SIZE="2">

<dir>
  </font><font size="3" FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">※</font><font
  size="3"> <font FACE="細明體" LANG="ZH-TW">廣被大眾接受之術語，無需額外說明，不在此列。例如繼承（</font>inheritance<font
  FACE="細明體" LANG="ZH-TW">）、封裝（</font>encapsulation<font FACE="細明體"
  LANG="ZH-TW">）、多型（</font>polymorphism<font FACE="細明體" LANG="ZH-TW">）。</p>
  <p ALIGN="JUSTIFY">※</font> <font FACE="細明體" LANG="ZH-TW">本書保留與</font>Java<font
  FACE="細明體" LANG="ZH-TW">關鍵字相關之術語不譯，例如</font>class, 
  interface, private, public, protected, static, final, abstract, synchronized, serializable…<font
  FACE="細明體" LANG="ZH-TW">。</p>
  <p ALIGN="JUSTIFY">※</font> <font FACE="細明體" LANG="ZH-TW">本書保留資料結構名稱不譯，例如</font>array, 
  vector, list, map, set, stack, heap…<font FACE="細明體" LANG="ZH-TW">。</font>&quot;<b>collection</b>&quot; 
  <font FACE="細明體" LANG="ZH-TW">譯為「群集」。</p>
  <p ALIGN="JUSTIFY">※</font> &quot;<b>class</b>&quot; <font FACE="細明體" LANG="ZH-TW">及其所衍生之各種名詞如</font>subclass, 
  superclass, immutable class, mutable class, base class, derived class<font
  FACE="細明體" LANG="ZH-TW">等皆保留不譯（時而英中並陳）。</font>&quot;<b>object</b>&quot; 
  <font FACE="細明體" LANG="ZH-TW">大多數時候譯為「物件」，時而保留。</font>&quot;<b>object 
  reference</b>&quot; <font FACE="細明體" LANG="ZH-TW">保留不譯，</font>&quot;<b>reference</b>&quot; 
  <font FACE="細明體" LANG="ZH-TW">亦不譯。</p>
  <p ALIGN="JUSTIFY">※</font> &quot;<b>type</b>&quot; <font FACE="細明體" LANG="ZH-TW">譯為「型別」。</font>&quot;<b>parameter</b>&quot; 
  <font FACE="細明體" LANG="ZH-TW">譯為「參數」，</font>&quot;<b>argument</b>&quot; 
  <font FACE="細明體" LANG="ZH-TW">譯為「引數」。</font>&quot;<b>delegate</b>&quot;, 
  &quot;<b>delegation</b>&quot; <font FACE="細明體" LANG="ZH-TW">譯為「委託」，</font>&quot;<b>aggregate</b>&quot;, 
  &quot;<b>aggregation</b>&quot; <font FACE="細明體" LANG="ZH-TW">譯為「聚合」。</font>&quot;<b>composition</b>&quot; 
  <font FACE="細明體" LANG="ZH-TW">譯為「複合」。</p>
  <p ALIGN="JUSTIFY">※</font> <font FACE="細明體" LANG="ZH-TW">動詞</font> &quot;<b>create</b>&quot; 
  <font FACE="細明體" LANG="ZH-TW">譯為「創建」或「建立」，描述物件之初次誕生。動詞</font> 
  &quot;<b>refer</b>&quot; <font FACE="細明體" LANG="ZH-TW">譯為「指涉」或「指向」或「引用」。動詞</font> 
  &quot;<b>dereference</b>&quot; <font FACE="細明體" LANG="ZH-TW">譯為「提領」。動詞</font> 
  &quot;<b>override</b>&quot; <font FACE="細明體" LANG="ZH-TW">譯為「覆寫」。動詞</font> 
  &quot;<b>overload</b>&quot; <font FACE="細明體" LANG="ZH-TW">譯為「重載」。</p>
  <p ALIGN="JUSTIFY">※</font> <font FACE="細明體" LANG="ZH-TW">本書將</font>Java 
  class &quot;<b>methods</b>&quot; <font FACE="細明體" LANG="ZH-TW">譯為函式，因為它等價於其他編程語言之</font> 
  &quot;function&quot;<font FACE="細明體" LANG="ZH-TW">。若直譯為「方法」，行文缺乏術語突出感，恐影響閱讀流暢；若不譯，過於頻繁出現又恐影響版面觀感。</p>
  <p ALIGN="JUSTIFY">※</font> <font FACE="細明體" LANG="ZH-TW">本書將</font>Java 
  class &quot;<b>fields</b>&quot; <font FACE="細明體" LANG="ZH-TW">譯為欄位，等價於</font>C++ 
  <font FACE="細明體" LANG="ZH-TW">語言之</font> &quot;data member&quot;<font
  FACE="細明體" LANG="ZH-TW">。</p>
  <p ALIGN="JUSTIFY">※</font> <font FACE="細明體" LANG="ZH-TW">本書將</font> &quot;<b>clone</b>&quot; 
  <font FACE="細明體" LANG="ZH-TW">譯為「克隆」（這一用詞在中國大陸極為普遍），映照</font> 
  &quot;<b>copy</b>&quot; <font FACE="細明體" LANG="ZH-TW">之於「拷貝」。非單純保留</font> 
  &quot;clone&quot; <font FACE="細明體" LANG="ZH-TW">是因為它時常做為動詞並頻繁出現，而我對術語的保留態度是儘量只考慮名詞（偶有形容詞）。</p>
  <p ALIGN="JUSTIFY">※「</font></font><font FACE="Lucida Sans" size="2">static</font><font
  FACE="細明體" LANG="ZH-TW" size="3">欄位與</font><font FACE="Lucida Sans" size="2">instance</font><font
  FACE="細明體" LANG="ZH-TW" size="3">欄位」、「</font><font FACE="Lucida Sans"
  size="2">reference</font><font FACE="細明體" LANG="ZH-TW" size="3">物件與</font><font
  FACE="Lucida Sans" size="2">value</font><font FACE="細明體" LANG="ZH-TW" size="3">物件」、「</font><font
  FACE="Lucida Sans" size="2">reference</font><font FACE="細明體" LANG="ZH-TW" size="3">型別與</font><font
  FACE="Lucida Sans" size="2">primitive</font><font FACE="細明體" LANG="ZH-TW" size="3">型別」等等術語保留部分英文，並使用特殊字型。</p>
  <p ALIGN="JUSTIFY">※</font><font size="3"> <font FACE="細明體" LANG="ZH-TW">本書支援網站有一個「術語英中繁簡」對照表，歡迎訪問，網址見上頁。</p>
  <p ALIGN="JUSTIFY">※</font> <font FACE="細明體" LANG="ZH-TW">術語翻譯有許多兩難之處，祈願讀者體諒；譯者勉力求取各方平衡，並儘可能於突兀處中英並陳。</p>
</dir>
</font>

<p ALIGN="JUSTIFY">-- <font FACE="細明體" LANG="ZH-TW">侯捷</font></font><font
FACE="細明體" LANG="ZH-TW" SIZE="2"></p>

<p ALIGN="JUSTIFY">　</p>
</font>

<p ALIGN="JUSTIFY">　</p>
<font FACE="華康粗圓體" LANG="ZH-TW" SIZE="6" COLOR="#ffffff">

<p ALIGN="left"></font><font FACE="華康粗圓體" LANG="ZH-TW" SIZE="7">細目<br>
</font><font color="#0000FF"><font FACE="細明體" LANG="ZH-TW" size="3">理論上，理論和實際並沒有區別；實際上，它們是有區別的。</font><br>
<i><font size="3">In theory, there is no difference between theory and practice. But, in 
practice, there is.</font></i><br>
<font size="2">Jan L.A. van de Snepscheut</font></font><font
FACE="Footlight MT Light,Book Antiqua"></p>
</font><font FACE="華康中黑體" LANG="ZH-TW">

<p ALIGN="JUSTIFY"></font><big><font color="#0000FF" FACE="華康中黑體" LANG="ZH-TW">一般技術（</font><font
color="#0000FF">General Techniques<font FACE="華康中黑體" LANG="ZH-TW">） </font></font></big></p>
<font FACE="細明體" LANG="ZH-TW" size="3">

<p ALIGN="JUSTIFY">實踐</font><font size="3">1<font FACE="細明體" LANG="ZH-TW">：引數是以傳值（</font></font><font
FACE="Lucida Sans" size="2">by value</font><font FACE="細明體" LANG="ZH-TW" size="3">）而非傳址（</font><font
FACE="Lucida Sans" size="2">by reference</font><font FACE="細明體" LANG="ZH-TW"
size="3">）方式傳遞 </font><font size="3"></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">所有</font>Java objects<font
  FACE="細明體" LANG="ZH-TW">都透過</font>object reference<font FACE="細明體"
  LANG="ZH-TW">而被取用。常見的一個誤解是</font>Java<font FACE="細明體"
  LANG="ZH-TW">以</font></font><font FACE="Lucida Sans" size="2">by reference</font><font
  FACE="細明體" LANG="ZH-TW" size="3">方式傳遞引數。事實上所有引數都以</font><font
  FACE="Lucida Sans" size="2">by value</font><font FACE="細明體" LANG="ZH-TW" size="3">方式傳遞。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font><font size="3">2<font FACE="細明體" LANG="ZH-TW">：對不變的</font>data<font
FACE="細明體" LANG="ZH-TW">和</font>object reference<font FACE="細明體"
LANG="ZH-TW">使用</font></font><font FACE="Courier New" SIZE="2">final</font><font
size="3"> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">為了讓</font>data<font
  FACE="細明體" LANG="ZH-TW">或</font>object reference<font FACE="細明體"
  LANG="ZH-TW">成為不變量，請使用</font></font><font FACE="Courier New" SIZE="2">final</font><font
  FACE="細明體" LANG="ZH-TW" size="3">。注意，</font><font FACE="Courier New"
  SIZE="2">final</font><font FACE="細明體" LANG="ZH-TW" size="3">僅僅令</font><font
  size="3">object reference<font FACE="細明體" LANG="ZH-TW">自身成為不變量，並不限制它所指向之物件的改變。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>3<font FACE="細明體" LANG="ZH-TW">：預設情況下所有</font>non-</font><font
FACE="Courier New" SIZE="2">static</font><font FACE="細明體" LANG="ZH-TW" size="3">函式都可被覆寫（</font><font
size="3">overridden<font FACE="細明體" LANG="ZH-TW">） </font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">預設情況下，所有</font>non-</font><font
  FACE="Courier New" SIZE="2">static</font><font FACE="細明體" LANG="ZH-TW" size="3">函式都可以被</font><font
  size="3">subclass<font FACE="細明體" LANG="ZH-TW">覆寫。但如果加上關鍵字</font></font><font
  FACE="Courier New" SIZE="2">final</font><font FACE="細明體" LANG="ZH-TW" size="3">，便可防止被</font><font
  size="3">subclass<font FACE="細明體" LANG="ZH-TW">覆寫。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>4<font FACE="細明體" LANG="ZH-TW">：慎重選擇</font>arrays<font
FACE="細明體" LANG="ZH-TW">和</font></font><font FACE="Lucida Console" SIZE="2">Vector</font><font
size="3">s </p>

<dir>
  <p ALIGN="JUSTIFY">arrays<font FACE="細明體" LANG="ZH-TW">和</font>vectors<font
  FACE="細明體" LANG="ZH-TW">是常見的容器類別（</font>storage classes</font><font
  FACE="細明體" LANG="ZH-TW" size="3">）。選用它們之前應該先瞭解它們的功用和特性。</p>
  </font><font size="4" FACE="細明體" LANG="ZH-TW">
</dir>
</font><font FACE="細明體" LANG="ZH-TW" size="3">

<p ALIGN="JUSTIFY">實踐</font><font size="3">5<font FACE="細明體" LANG="ZH-TW">：多型（</font>polymorphism<font
FACE="細明體" LANG="ZH-TW">）優於</font></font><font FACE="Courier New" SIZE="2">instanceof</font><font
size="3"> </p>

<dir>
  </font><font FACE="Courier New" SIZE="2"><p ALIGN="JUSTIFY">instanceof</font><font
  FACE="細明體" LANG="ZH-TW" size="3">的許多用途可以因為改用多型而消除之。使用多型，程式碼將更清晰、更易於擴展和維護。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font><font size="3">6<font FACE="細明體" LANG="ZH-TW">：必要時才使用</font></font><font
FACE="Courier New" SIZE="2">instanceof</font><font FACE="Lucida Console" size="2"> </font><font
size="3"></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">有時我們無法迴避使用</font></font><font
  FACE="Courier New" SIZE="2">instanceof</font><font FACE="細明體" LANG="ZH-TW" size="3">。我們應該瞭解什麼情況下必須使用它。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font><font size="3">7<font FACE="細明體" LANG="ZH-TW">：一旦不再需要</font>object 
references<font FACE="細明體" LANG="ZH-TW">，就將它設為</font></font><font
FACE="Lucida Console" size="2">null</font><font size="3"> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">不要忽視記憶體可能帶來的問題。儘管有了垃圾回收機制（</font>garbage 
  collection<font FACE="細明體" LANG="ZH-TW">），你仍然需要關注你的程式碼如何運用記憶體。如果能夠領悟垃圾回收機制和記憶體運用細節，你就能夠更好地知道何時應該將</font>object 
  references<font FACE="細明體" LANG="ZH-TW">設為</font>null<font FACE="細明體"
  LANG="ZH-TW">，那將導致高效的程式碼。</p>
</dir>
</font></font><font FACE="華康中黑體" LANG="ZH-TW">

<p ALIGN="JUSTIFY"></font><big><font color="#0000FF" FACE="華康中黑體" LANG="ZH-TW">物件與相等性（</font><font
color="#0000FF">Objects and Equality<font FACE="華康中黑體" LANG="ZH-TW">） </font></font></big></p>
<font FACE="細明體" LANG="ZH-TW" size="3">

<p ALIGN="JUSTIFY">實踐</font><font size="3">8<font FACE="細明體" LANG="ZH-TW">：區分</font>reference 
type<font FACE="細明體" LANG="ZH-TW">和</font>primitive type </p>

<dir>
  <p ALIGN="JUSTIFY">Java<font FACE="細明體" LANG="ZH-TW">是物件導向的，但其操控的東西並非都是物件（</font>objects<font
  FACE="細明體" LANG="ZH-TW">）。理解</font>reference type<font FACE="細明體"
  LANG="ZH-TW">和</font>primitive types<font FACE="細明體" LANG="ZH-TW">之間的差異，及它們在</font>JVM<font
  FACE="細明體" LANG="ZH-TW">中的表述（</font>representation<font FACE="細明體"
  LANG="ZH-TW">），會使你在運用它們時得以做出明智的選擇。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>9<font FACE="細明體" LANG="ZH-TW">：區分</font> </font><font
FACE="Courier New" SIZE="2">==</font><font size="3"> <font FACE="細明體" LANG="ZH-TW">和</font></font><font
FACE="Courier New" SIZE="2">equals()</font><font FACE="Courier New" size="3"> </font><font
size="3"></p>

<dir>
  </font><font FACE="Courier New" SIZE="2"><p ALIGN="JUSTIFY">== </font><font
  FACE="細明體" LANG="ZH-TW" size="3">用來測試基本型別的相等性，亦可判定兩個</font><font
  size="3">object references<font FACE="細明體" LANG="ZH-TW">是否指向同一個</font>object<font
  FACE="細明體" LANG="ZH-TW">。若要測試</font>values<font FACE="細明體"
  LANG="ZH-TW">（值）或</font>semantic<font FACE="細明體" LANG="ZH-TW">（語意）相等，應使用</font></font><font
  FACE="Courier New" size="2">equals()</font><font FACE="細明體" LANG="ZH-TW" size="3">。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font><font size="3">10<font FACE="細明體" LANG="ZH-TW">：不要依賴</font></font><font
FACE="Courier New" size="2">equals()</font><font FACE="細明體" LANG="ZH-TW" size="3">的預設實作（</font><font
size="3">default implementation<font FACE="細明體" LANG="ZH-TW">） </font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">不要不假思索地認定一個</font>class<font
  FACE="細明體" LANG="ZH-TW">總是會正確實作出</font></font><font
  FACE="Courier New" size="2">equals()</font><font FACE="細明體" LANG="ZH-TW" size="3">。此外，</font><font
  FACE="Lucida Console" size="2">java.lang.Object</font><font FACE="細明體" LANG="ZH-TW"
  size="3">提供的</font><font FACE="Courier New" size="2">equals()</font><font
  FACE="細明體" LANG="ZH-TW" size="3">大多數時候並非進行你想要的比較。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font><font size="3">11<font FACE="細明體" LANG="ZH-TW">：實作</font></font><font
FACE="Courier New" size="2">equals()</font><font FACE="細明體" LANG="ZH-TW" size="3">時必須深思熟慮</font><font
size="3"> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">如果某個</font>class<font
  FACE="細明體" LANG="ZH-TW">的兩個</font>objects<font FACE="細明體" LANG="ZH-TW">「即使不佔用相同的記憶體空間，也被視為邏輯上相等」，那麼就該為這個</font>class<font
  FACE="細明體" LANG="ZH-TW">提供一個</font></font><font FACE="Courier New" size="2">equals()</font><font
  FACE="細明體" LANG="ZH-TW" size="3">。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font><font size="3">12<font FACE="細明體" LANG="ZH-TW">：實作</font></font><font
FACE="Courier New" size="2">equals()</font><font FACE="細明體" LANG="ZH-TW" size="3">時優先考慮使用</font><font
FACE="Courier New" size="2">getClass()</font><font size="3"> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">實作</font></font><font
  FACE="Courier New" size="2">equals()</font><font FACE="細明體" LANG="ZH-TW" size="3">時請優先考慮採用</font><font
  FACE="Courier New" size="2">getClass()</font><font FACE="細明體" LANG="ZH-TW" size="3">。畢竟，「相同</font><font
  size="3">class<font FACE="細明體" LANG="ZH-TW">下的</font>objects<font
  FACE="細明體" LANG="ZH-TW">才得被視為相等」是正確實作</font></font><font
  FACE="Courier New" size="2">equals()</font><font FACE="細明體" LANG="ZH-TW" size="3">的一個清晰簡明的解決方案。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font><font size="3">13<font FACE="細明體" LANG="ZH-TW">：呼叫</font>base 
class<font FACE="細明體" LANG="ZH-TW">（基礎類別）的</font></font><font
FACE="Courier New" size="2">super.equals()</font><font FACE="細明體" LANG="ZH-TW"
size="3"> </font><font size="3"></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">任何</font>base class<font
  FACE="細明體" LANG="ZH-TW">（除了</font></font><font FACE="Lucida Console" size="2">java.lang.Object</font><font
  FACE="細明體" LANG="ZH-TW" size="3">）如果實作</font><font FACE="Courier New"
  size="2">equals()</font><font FACE="細明體" LANG="ZH-TW" size="3">，其</font><font
  size="3">derived class<font FACE="細明體" LANG="ZH-TW">都應該呼叫</font></font><font
  FACE="Courier New" size="2">super.equals()</font><font FACE="細明體" LANG="ZH-TW"
  size="3">。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font><font size="3">14<font FACE="細明體" LANG="ZH-TW">：在</font></font><font
FACE="Courier New" size="2">equals()</font><font FACE="細明體" LANG="ZH-TW" size="3">函式中謹慎使用</font><font
FACE="Courier New" size="2">instanceof</font><font size="3"> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">唯有當你考慮允許「一個</font>derived 
  class object<font FACE="細明體" LANG="ZH-TW">可以相等於其</font>base class object<font
  FACE="細明體" LANG="ZH-TW">」時，才在</font></font><font FACE="Courier New"
  size="2">equals()</font><font FACE="細明體" LANG="ZH-TW" size="3">中使用</font><font
  FACE="Courier New" size="2">instanceof</font><font FACE="細明體" LANG="ZH-TW" size="3">。使用這項技術前請先弄清楚其影響。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font><font size="3">15<font FACE="細明體" LANG="ZH-TW">：實作</font></font><font
FACE="Courier New" size="2">equals()</font><font FACE="細明體" LANG="ZH-TW" size="3">時需遵循某些規則 
</font><font size="3"></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">撰寫</font></font><font
  FACE="Courier New" size="2">equals()</font><font FACE="細明體" LANG="ZH-TW" size="3">並非那麼直觀淺白。如果想要恰當地實作出</font><font
  FACE="Courier New" size="2">equals()</font><font FACE="細明體" LANG="ZH-TW" size="3">，請遵循某些規則。</p>
</dir>
</font><font FACE="華康中黑體" LANG="ZH-TW">

<p ALIGN="JUSTIFY"></font><big><font color="#0000FF" FACE="華康中黑體" LANG="ZH-TW">異常處理（</font><font
color="#0000FF">Exception Handling<font FACE="華康中黑體" LANG="ZH-TW">）</font></font> 
</big></p>
<font FACE="細明體" LANG="ZH-TW" size="3">

<p ALIGN="JUSTIFY">實踐</font><font size="3">16<font FACE="細明體" LANG="ZH-TW">：認識「異常控制流」（</font>exception 
control flow<font FACE="細明體" LANG="ZH-TW">）機制 </font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">讓自己諳曉異常控制流程細節。瞭解這些細微之處有助於你迴避問題。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>17<font FACE="細明體" LANG="ZH-TW">：絕對不可輕忽異常（</font>Never 
ignore an Exceptions<font FACE="細明體" LANG="ZH-TW">） </font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">一旦異常出現卻沒有被捕獲，拋出異常的那個執行緒（</font>thread<font
  FACE="細明體" LANG="ZH-TW">）就會中止運行。是的，異常意味錯誤，永遠不要忽略它。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>18<font FACE="細明體" LANG="ZH-TW">：千萬不要掩蓋異常（</font>Never 
hide an Exceptions<font FACE="細明體" LANG="ZH-TW">） </font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">如果處理異常期間又從</font></font><font
  FACE="Courier New" size="2">catch</font><font FACE="細明體" LANG="ZH-TW" size="3">或</font><font
  FACE="Courier New" size="2">finally</font><font FACE="細明體" LANG="ZH-TW" size="3">區段拋出異常，原先的異常會因而被隱蔽起來。一旦發生這樣的事情，就會丟失錯誤資訊。你應當撰寫專門負責處理這種情形的程式碼，將所有異常回傳給呼叫者。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font><font size="3">19<font FACE="細明體" LANG="ZH-TW">：明察</font></font><font
FACE="Courier New" size="2">throws</font><font FACE="細明體" LANG="ZH-TW" size="3">子句的缺點</font><font
size="3"> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">將一個異常加入某函式的</font></font><font
  FACE="Courier New" size="2">throws</font><font FACE="細明體" LANG="ZH-TW" size="3">子句，會影響該函式的所有呼叫者。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font><font size="3">20<font FACE="細明體" LANG="ZH-TW">：細緻而全面地理解</font></font><font
FACE="Courier New" size="2">throws</font><font FACE="細明體" LANG="ZH-TW" size="3">子句</font><font
size="3"> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">任何函式的</font></font><font
  FACE="Courier New" size="2">throws</font><font FACE="細明體" LANG="ZH-TW" size="3">子句應當列出它所傳播的所有異常，包括衍生異常型別（</font><font
  size="3">derived exception types</font><font FACE="細明體" LANG="ZH-TW" size="3">）。</p>
  </font><font size="4" FACE="細明體" LANG="ZH-TW">
</dir>
</font><font FACE="細明體" LANG="ZH-TW" size="3">

<p ALIGN="JUSTIFY">實踐</font><font size="3">21<font FACE="細明體" LANG="ZH-TW">：使用</font></font><font
FACE="Courier New" size="2">finally</font><font FACE="細明體" LANG="ZH-TW" size="3">避免資源洩漏（</font><font
size="3">resource leaks<font FACE="細明體" LANG="ZH-TW">） </font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">不要忽視記憶體以外的資源。垃圾回收機制不會替你釋放它們。請使用</font></font><font
  FACE="Courier New" size="2">finally</font><font FACE="細明體" LANG="ZH-TW" size="3">確保記憶體以外的資源被釋放。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font><font size="3">22<font FACE="細明體" LANG="ZH-TW">：不要從</font></font><font
FACE="Courier New" size="2">try</font><font FACE="細明體" LANG="ZH-TW" size="3">區塊中回返</font><font
size="3"> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">不要從</font></font><font
  FACE="Courier New" size="2">try</font><font FACE="細明體" LANG="ZH-TW" size="3">區塊中發出</font><font
  FACE="Courier New" size="2">return</font><font FACE="細明體" LANG="ZH-TW" size="3">指令，因為這個函式未必會立即從那兒回返。如果存在</font><font
  FACE="Courier New" size="2">finally</font><font FACE="細明體" LANG="ZH-TW" size="3">區段，它就會被執行起來並可能改變回傳值。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font><font size="3">23<font FACE="細明體" LANG="ZH-TW">：將</font></font><font
FACE="Courier New" size="2">try/catch</font><font FACE="細明體" LANG="ZH-TW" size="3">區塊置於迴圈（</font><font
size="3">loop<font FACE="細明體" LANG="ZH-TW">）之外</font> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">撰寫含有異常處理的迴圈時，請將</font></font><font
  FACE="Courier New" size="2">try</font><font FACE="細明體" LANG="ZH-TW" size="3">和</font><font
  FACE="Courier New" size="2">catch</font><font FACE="細明體" LANG="ZH-TW" size="3">區塊置於迴圈外部。在某些實作版本上，這會產生更快的執行碼。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font><font size="3">24<font FACE="細明體" LANG="ZH-TW">：不要將異常（</font>exceptions<font
FACE="細明體" LANG="ZH-TW">）用於流程控制 </font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">請將異常用於預期行為之外的情況。不要以異常來控制流程，請採用標準的語言流程構件（</font>flow 
  constructs<font FACE="細明體" LANG="ZH-TW">），這樣的流程表達會更清晰更高效。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>25<font FACE="細明體" LANG="ZH-TW">：不要每逢出錯就使用異常（</font>exceptions<font
FACE="細明體" LANG="ZH-TW">） </font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">只有面對程式行為可能出乎預料的情境下才使用異常。「預期中的行為」應使用回傳碼（</font>return 
  codes<font FACE="細明體" LANG="ZH-TW">）來處理。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>26<font FACE="細明體" LANG="ZH-TW">：在建構式（</font>constructors<font
FACE="細明體" LANG="ZH-TW">）中拋出異常 </font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">儘管建構式並非函式（</font>method<font
  FACE="細明體" LANG="ZH-TW">），因而不能回傳一個值，但建構式有可能失敗。如果它們失敗了，請拋出一個異常。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>27<font FACE="細明體" LANG="ZH-TW">：拋出異常（</font>exceptions<font
FACE="細明體" LANG="ZH-TW">）之前先將</font>object<font FACE="細明體"
LANG="ZH-TW">恢復為有效狀態 </font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">拋出異常很容易，困難的是「將異常所引發的傷害減到最小」。拋出異常之前，應確保「如果異常被處理好，流程再次進入拋出異常的那個函式中，該函式可以成功完成」。</p>
</dir>
</font></font><font FACE="華康中黑體" LANG="ZH-TW">

<p ALIGN="JUSTIFY"></font><big><font color="#0000FF" FACE="華康中黑體" LANG="ZH-TW">效能/效率（</font><font
color="#0000FF">Performance<font FACE="華康中黑體" LANG="ZH-TW">）</font> </font></big></p>
<font FACE="細明體" LANG="ZH-TW" size="3">

<p ALIGN="JUSTIFY">實踐</font><font size="3">28<font FACE="細明體" LANG="ZH-TW">：先把焦點放在設計、資料結構和演算法身上 
</font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">給</font>Java<font
  FACE="細明體" LANG="ZH-TW">帶來最大效能提升的辦法就是：在設計和演算法中使用與語言無關的技術。因此，首先請將你的精力集中於這些上面。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>29<font FACE="細明體" LANG="ZH-TW">：不要倚賴編譯期程式碼優化技術 
</font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">由</font>Java<font
  FACE="細明體" LANG="ZH-TW">編譯器生成的碼，通常不會比你自己撰寫的更好。別指望編譯器能夠多麼優化你的原始碼。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>30<font FACE="細明體" LANG="ZH-TW">：理解運行期（</font>runtime<font
FACE="細明體" LANG="ZH-TW">）程式碼優化技術 </font></p>

<dir>
  <p ALIGN="JUSTIFY">Java<font FACE="細明體" LANG="ZH-TW">效能的大部分努力都圍繞著運行期優化展開。這種作法有利有弊。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>31<font FACE="細明體" LANG="ZH-TW">：如欲進行字串接合，</font></font><font
FACE="Lucida Console" size="2">StringBuffer</font><font FACE="細明體" LANG="ZH-TW"
size="3">優於</font><font FACE="Lucida Console" size="2">String</font><font
FACE="細明體" LANG="ZH-TW" size="3"> </font><font size="3"></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">對於字串接合，</font></font><font
  FACE="Lucida Console" size="2">StringBuffer</font><font size="3"> class<font
  FACE="細明體" LANG="ZH-TW">要比</font></font><font FACE="Lucida Console" size="2">String 
  </font><font size="3">class<font FACE="細明體" LANG="ZH-TW">快許多倍。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>32<font FACE="細明體" LANG="ZH-TW">：將</font>object<font
FACE="細明體" LANG="ZH-TW">的創建成本（</font>creation cost<font FACE="細明體"
LANG="ZH-TW">）降至最小</font> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">在許多物件導向系統中，「產生物件」意味著高昂的成本。瞭解成本所在，以及瞭解「加速物件產生速度」的技術，都可以導致更快的程式碼。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>33<font FACE="細明體" LANG="ZH-TW">：慎防未用上的物件（</font>unused 
objects<font FACE="細明體" LANG="ZH-TW">） </font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">非必要別產生物件。非必要地產生物件，會減慢你的程式速度。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>34<font FACE="細明體" LANG="ZH-TW">：將同步（</font>synchronization<font
FACE="細明體" LANG="ZH-TW">）減至最低 </font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">宣告</font></font><font
  FACE="Courier New" size="2">synchronized</font><font FACE="細明體" LANG="ZH-TW"
  size="3">函式或</font><font FACE="Courier New" size="2">synchronized</font><font
  FACE="細明體" LANG="ZH-TW" size="3">區塊，會顯著降低效能。只在物件需要時才使用同步機制（</font><font
  size="3">synchronization<font FACE="細明體" LANG="ZH-TW">）。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>35<font FACE="細明體" LANG="ZH-TW">：儘可能使用</font>stack<font
FACE="細明體" LANG="ZH-TW">變數</font> </p>

<dir>
  <p ALIGN="JUSTIFY">stack<font FACE="細明體" LANG="ZH-TW">變數為</font>JVM<font
  FACE="細明體" LANG="ZH-TW">提供了更高效的</font>byte code<font FACE="細明體"
  LANG="ZH-TW">指令序列。所以在迴圈內重複取用</font>static<font
  FACE="細明體" LANG="ZH-TW">變數或</font>instance<font FACE="細明體" LANG="ZH-TW">變數時，應當將它們臨時儲存於</font>stack<font
  FACE="細明體" LANG="ZH-TW">變數中，以便獲得更快的執行速度。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>36<font FACE="細明體" LANG="ZH-TW">：使用</font></font><font
FACE="Courier New" size="2">static</font><font FACE="細明體" LANG="ZH-TW" size="3">、</font><font
FACE="Courier New" size="2">final</font><font FACE="細明體" LANG="ZH-TW" size="3">和</font><font
FACE="Courier New" size="2">private</font><font FACE="細明體" LANG="ZH-TW" size="3">函式以允許實施</font><font
size="3">inlining </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">以函式本體替換函式呼叫，會導致更快的程式碼。如果要令函式為</font>inline<font
  FACE="細明體" LANG="ZH-TW">，必須先宣告它們為</font></font><font
  FACE="Courier New" size="2">static</font><font FACE="細明體" LANG="ZH-TW" size="3">、</font><font
  FACE="Courier New" size="2">final</font><font FACE="細明體" LANG="ZH-TW" size="3">或</font><font
  FACE="Courier New" size="2">private</font><font FACE="細明體" LANG="ZH-TW" size="3">。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font><font size="3">37<font FACE="細明體" LANG="ZH-TW">：</font>instance<font
FACE="細明體" LANG="ZH-TW">變數的初始化只要一次就好</font> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">由於所有</font></font><font
  FACE="Courier New" size="2">static</font><font FACE="細明體" LANG="ZH-TW" size="3">變數和</font><font
  FACE="Lucida Sans" size="2">instance</font><font FACE="細明體" LANG="ZH-TW" size="3">變數都會自動獲得預設值，所以不必重新將它們設為預設值。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font><font size="3">38<font FACE="細明體" LANG="ZH-TW">：使用基本型別（</font>primitive 
types<font FACE="細明體" LANG="ZH-TW">）使程式碼更快更小</font> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">使用基本型別，比使用基本型別外覆類別（</font>wrapper<font
  FACE="細明體" LANG="ZH-TW">），產生的程式碼又小又快。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>39<font FACE="細明體" LANG="ZH-TW">：不要使用</font></font><font
FACE="Lucida Console" size="2">Enumeration</font><font FACE="細明體" LANG="ZH-TW"
size="3">或</font><font FACE="Lucida Console" size="2">Iterator</font><font
FACE="細明體" LANG="ZH-TW" size="3">來巡訪</font><font FACE="Lucida Console"
size="2">Vector</font><font size="3"> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">巡訪</font></font><font
  FACE="Lucida Console" size="2">Vector</font><font FACE="細明體" LANG="ZH-TW" size="3">時，請使用</font><font
  FACE="Courier New" size="2">get</font><font FACE="細明體" LANG="ZH-TW" size="3">函式而非</font><font
  FACE="Lucida Console" size="2">Enumeration</font><font FACE="細明體" LANG="ZH-TW"
  size="3">或</font><font FACE="Lucida Console" size="2">Iterator</font><font
  FACE="細明體" LANG="ZH-TW" size="3">。這樣做會導致更少的函式呼叫，意味程式碼會更快。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font><font size="3">40<font FACE="細明體" LANG="ZH-TW">：使用</font></font><font
FACE="Courier New" SIZE="2">System.arraycopy()</font><font size="3"> <font
FACE="細明體" LANG="ZH-TW">來複製</font>arrays </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">請使用</font></font><font
  FACE="Courier New" SIZE="2">System.arraycopy()</font><font FACE="Lucida Console" size="2"> 
  </font><font FACE="細明體" LANG="ZH-TW" size="3">來複製</font><font size="3">arrays<font
  FACE="細明體" LANG="ZH-TW">。那是個原生（</font>native<font FACE="細明體"
  LANG="ZH-TW">）函式，速度最快。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>41<font FACE="細明體" LANG="ZH-TW">：優先使用</font>array<font
FACE="細明體" LANG="ZH-TW">，然後才考慮</font></font><font FACE="Lucida Console"
size="2">Vector</font><font FACE="細明體" LANG="ZH-TW" size="3">和</font><font
FACE="Lucida Console" size="2">ArrayList </font><font size="3"></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">如果可能，就使用</font>array<font
  FACE="細明體" LANG="ZH-TW">。如果你需要</font></font><font FACE="Lucida Console"
  size="2">Vector</font><font FACE="細明體" LANG="ZH-TW" size="3">的功能但不需要它的同步特性，可改用</font><font
  FACE="Lucida Console" size="2">ArrayList</font><font FACE="細明體" LANG="ZH-TW"
  size="3">。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font><font size="3">42<font FACE="細明體" LANG="ZH-TW">：儘可能復用（</font>reuse<font
FACE="細明體" LANG="ZH-TW">）</font>objects </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">復用現有物件，幾乎總是比產生新物件更划算。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>43<font FACE="細明體" LANG="ZH-TW">：使用緩式評估（延遲求值，</font>lazy 
evaluation<font FACE="細明體" LANG="ZH-TW">） </font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">如果某個成本高貴的計算並非一定必要，就盡量少做。請使用「緩式評估」<br>
  （</font>lazy evaluation<font FACE="細明體" LANG="ZH-TW">，延遲求值）技術避免那些永遠不需要的工作。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>44<font FACE="細明體" LANG="ZH-TW">：手工優化（</font>optimize<font
FACE="細明體" LANG="ZH-TW">）你的程式碼 </font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">由於</font>Java<font
  FACE="細明體" LANG="ZH-TW">編譯器在優化方面的作為甚少，為了生成最佳</font>byte 
  code<font FACE="細明體" LANG="ZH-TW">，請手工優化你的原始碼。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>45<font FACE="細明體" LANG="ZH-TW">：編譯為原生碼（</font>native 
code<font FACE="細明體" LANG="ZH-TW">） </font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">編譯為原生碼，通常可以導致執行速度更快的程式碼。但你卻因此必須在各種不同的原生方案（</font>native 
  solution<font FACE="細明體" LANG="ZH-TW">）中取捨。</p>
</dir>
</font></font><font FACE="華康中黑體" LANG="ZH-TW">

<p ALIGN="JUSTIFY"></font><big><font color="#0000FF" FACE="華康中黑體" LANG="ZH-TW">多緒（</font><font
color="#0000FF">Multithreading<font FACE="華康中黑體" LANG="ZH-TW">） </font></font></big></p>
<font size="3"><font FACE="細明體" LANG="ZH-TW">

<p ALIGN="JUSTIFY">實踐</font>46<font FACE="細明體" LANG="ZH-TW">：面對</font></font><font
FACE="Lucida Sans" size="2">instance</font><font FACE="細明體" LANG="ZH-TW" size="3">函式，</font><font
FACE="Courier New" size="2">synchronized</font><font FACE="細明體" LANG="ZH-TW"
size="3">鎖定的是物件而非函式或程式碼</font><font size="3"> </p>

<dir>
  </font><font FACE="細明體" LANG="ZH-TW" size="3"><p ALIGN="JUSTIFY"></font><font
  FACE="細明體" LANG="ZH-TW">關鍵字</font><font FACE="Courier New" size="2">synchronized</font><font
  FACE="細明體" LANG="ZH-TW" size="3">鎖定的是物件，而非函式或程式碼。一個函式或程式<br>
  區段被宣告為</font><font FACE="Courier New" size="2">synchronized</font><font
  FACE="細明體" LANG="ZH-TW" size="3">，並不意味同一時刻只能由一個執行緒執行它。</p>
</dir>
</font><font size="3"><font FACE="細明體" LANG="ZH-TW">

<p ALIGN="JUSTIFY">實踐</font>47<font FACE="細明體" LANG="ZH-TW">：弄清楚</font></font><font
FACE="Courier New" size="2">synchronized</font><font size="3"> </font><font
FACE="Lucida Sans" size="2">static</font><font FACE="Arial Black" size="2"><i>s</i></font><font
FACE="細明體" LANG="ZH-TW" size="3">與</font><font FACE="Courier New" SIZE="2">synchronized</font><font
size="3"> </font><font FACE="Lucida Sans" size="2">instance</font><font FACE="細明體"
LANG="ZH-TW" size="3">函式之間的差異</font><font size="3"> </p>

<dir>
  </font><font FACE="細明體" LANG="ZH-TW" size="3"><p ALIGN="JUSTIFY">兩個函式被宣告為</font><font
  FACE="Courier New" SIZE="2">synchronized</font><font FACE="細明體" LANG="ZH-TW"
  size="3">，並不就意味它們是「執行緒安全」（</font><font size="3">thread-safe<font
  FACE="細明體" LANG="ZH-TW">）的。對</font></font><font FACE="Lucida Sans" size="2">instance</font><font
  FACE="細明體" LANG="ZH-TW" size="3">函式或</font><font size="3">object reference<font
  FACE="細明體" LANG="ZH-TW">同步化，與對</font></font><font FACE="Lucida Sans"
  size="2">static</font><font FACE="細明體" LANG="ZH-TW" size="3">函式或</font><font
  size="3">class literal<font FACE="細明體" LANG="ZH-TW">（字面常數）同步化相比，得到的</font>lock<font
  FACE="細明體" LANG="ZH-TW">全然不同</font></font><font FACE="細明體"
  LANG="ZH-TW" size="3"></p>
</dir>
</font><font size="3"><font FACE="細明體" LANG="ZH-TW">

<p ALIGN="JUSTIFY">實踐</font>48<font FACE="細明體" LANG="ZH-TW">：以「</font></font><font
FACE="Courier New" size="2">private</font><font FACE="細明體" LANG="ZH-TW" size="3">資料搭配存取器（</font><font
size="3">accessor<font FACE="細明體" LANG="ZH-TW">）」取代</font></font><font
FACE="Courier New" size="2">public/protected</font><font FACE="細明體" LANG="ZH-TW"
size="3">資料&nbsp; </p>

<dir>
  <p ALIGN="JUSTIFY">如果沒有適當保護你的資料，用戶便有機會繞過你的同步機制。</p>
</dir>
</font><font size="3"><font FACE="細明體" LANG="ZH-TW">

<p ALIGN="JUSTIFY">實踐</font>49<font FACE="細明體" LANG="ZH-TW">：避免無謂的同步控制（</font>avoid 
unnecessary synchronization<font FACE="細明體" LANG="ZH-TW">）</font> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">一般情況下請不要同步化所有函式。同步化不僅造成程式緩慢，並且喪失了<br>
  並行（</font>concurrency<font FACE="細明體" LANG="ZH-TW">）的可能。請採用「單物件多鎖」技術以允許更多並行。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>50<font FACE="細明體" LANG="ZH-TW">：取用共享變數時請使用</font></font><font
FACE="Courier New" size="2">synchronized</font><font FACE="細明體" LANG="ZH-TW"
size="3">或</font><font FACE="Courier New" size="2">volatile</font><font
FACE="Lucida Console" SIZE="2"> </font><font size="3"></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">不可切割（原子化，</font>atomic<font
  FACE="細明體" LANG="ZH-TW">）操作並非意味「執行緒安全」。</font>JVM<font
  FACE="細明體" LANG="ZH-TW">實作品被允許在私有記憶體中保留變數的工作副本。這可能會產生陳舊數值（</font>stale 
  values<font FACE="細明體" LANG="ZH-TW">）。為避免這個問題，請使用同步化機制或將變數宣告為</font></font><font
  FACE="Courier New" size="2">volatile</font><font FACE="細明體" LANG="ZH-TW" size="3">。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font><font size="3">51<font FACE="細明體" LANG="ZH-TW">：在單一操作（</font>single 
operation<font FACE="細明體" LANG="ZH-TW">）中鎖定所有用到的</font>objects </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">同步化某一函式，並不一定就會使其成為「執行緒安全」的函式碼。如果</font></font><font
  FACE="Courier New" size="2">synchronized</font><font FACE="細明體" LANG="ZH-TW"
  size="3">函式操控著多個</font><font size="3">objects<font FACE="細明體"
  LANG="ZH-TW">，而它們並不都是此函式所屬</font>class<font FACE="細明體"
  LANG="ZH-TW">的</font></font><font FACE="Courier New" size="2">private</font><font
  size="3"> </font><font FACE="Lucida Sans" SIZE="2">instance</font><font size="3"> data<font
  FACE="細明體" LANG="ZH-TW">，那麼你必須對這些</font>objects<font
  FACE="細明體" LANG="ZH-TW">自身也進行同步化。</p>
</dir>
</font></font><font FACE="細明體" LANG="ZH-TW" size="3">

<p ALIGN="JUSTIFY">實踐52：以固定而全域性的順序取得多個locks（機鎖）以避免死結（deadlock）</font><font
size="3"></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY"></font></font><font
  FACE="細明體" LANG="ZH-TW" size="3">當你同步化多個物件，請以固定和全域性的順序獲得locks，以避免死結。</font><font
  size="3"><font FACE="細明體" LANG="ZH-TW"></p>
</dir>
</font>

<p ALIGN="JUSTIFY"><font FACE="細明體" LANG="ZH-TW">實踐</font>53<font
FACE="細明體" LANG="ZH-TW">：優先使用</font><font FACE="Courier New" size="2">notifyAll()</font><font
FACE="細明體" LANG="ZH-TW" size="3">而非</font><font FACE="Courier New" size="2">notify()</font><font
FACE="細明體" LANG="ZH-TW" size="3"> </font></p>

<dir>
  </font><font FACE="Courier New" size="2"><p ALIGN="JUSTIFY">notify()</font><font
  FACE="細明體" LANG="ZH-TW" size="3">只喚醒一個執行緒。要想喚醒多個執行緒，請使用</font><font
  FACE="Courier New" size="2">notifyAll()</font><font FACE="細明體" LANG="ZH-TW" size="3">。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font><font size="3">54<font FACE="細明體" LANG="ZH-TW">：針對</font></font><font
FACE="Courier New" size="2">wait()</font><font FACE="細明體" LANG="ZH-TW" size="3">和</font><font
FACE="Courier New" size="2">notifyAll()</font><font FACE="細明體" LANG="ZH-TW" size="3">使用旋鎖（</font><font
size="3">spin locks<font FACE="細明體" LANG="ZH-TW">）</font> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">當你等待條件變數（</font>condition 
  variables<font FACE="細明體" LANG="ZH-TW">）時，請總是使用旋鎖（</font>spin 
  locks<font FACE="細明體" LANG="ZH-TW">）以確保正確結果。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>55<font FACE="細明體" LANG="ZH-TW">：使用</font></font><font
FACE="Courier New" size="2">wait()</font><font FACE="細明體" LANG="ZH-TW" size="3">和</font><font
FACE="Courier New" size="2">notifyAll()</font><font FACE="細明體" LANG="ZH-TW" size="3">取代輪詢迴圈（</font><font
size="3">polling loops<font FACE="細明體" LANG="ZH-TW">）</font> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">將所有</font>polling loops<font
  FACE="細明體" LANG="ZH-TW">替換為使用</font></font><font FACE="Courier New"
  size="2">wait()</font><font FACE="細明體" LANG="ZH-TW" size="3">、</font><font
  FACE="Courier New" size="2">notify()</font><font FACE="細明體" LANG="ZH-TW" size="3">和</font><font
  FACE="Courier New" size="2">notifyAll()</font><font FACE="細明體" LANG="ZH-TW" size="3">的</font><font
  size="3">spin locks<font FACE="細明體" LANG="ZH-TW">（旋鎖）。使用</font>spin 
  locks<font FACE="細明體" LANG="ZH-TW">直觀而高效，使用</font>polling loops<font
  FACE="細明體" LANG="ZH-TW">則慢很多倍。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>56<font FACE="細明體" LANG="ZH-TW">：不要對</font>locked 
object<font FACE="細明體" LANG="ZH-TW">（上鎖物件）之</font>object reference<font
FACE="細明體" LANG="ZH-TW">重新賦值</font> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">當一個</font>object<font
  FACE="細明體" LANG="ZH-TW">被鎖定，有可能其他執行緒會因同一個</font>object 
  lock<font FACE="細明體" LANG="ZH-TW">而受阻（</font><i>blocked</i><font
  FACE="細明體" LANG="ZH-TW">）。假如你對上鎖物件的</font>object reference<font
  FACE="細明體" LANG="ZH-TW">重新賦值，其他執行緒中懸而未決的那些</font>locks<font
  FACE="細明體" LANG="ZH-TW">將不再有意義。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>57<font FACE="細明體" LANG="ZH-TW">：不要呼叫</font></font><font
FACE="Courier New" size="2">stop()</font><font FACE="細明體" LANG="ZH-TW" size="3">或</font><font
FACE="Courier New" size="2">suspend()</font><font size="3"> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">不要呼叫</font></font><font
  FACE="Courier New" size="2">stop()</font><font FACE="細明體" LANG="ZH-TW" size="3">或</font><font
  FACE="Courier New" size="2">suspend()</font><font FACE="細明體" LANG="ZH-TW" size="3">，因為它們可能導致資料內部混亂，甚至引發死結（</font><font
  size="3">deadlock<font FACE="細明體" LANG="ZH-TW">）。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>58<font FACE="細明體" LANG="ZH-TW">：透過執行緒（</font>threads<font
FACE="細明體" LANG="ZH-TW">）之間的合作來中止執行緒</font> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">你不應該呼叫</font></font><font
  FACE="Courier New" size="2">stop()</font><font FACE="細明體" LANG="ZH-TW" size="3">。如欲安全地停止執行緒，必須要求它們相互協作，才能姿態優雅地中止。</p>
</dir>
</font><font FACE="華康中黑體" LANG="ZH-TW">

<p ALIGN="JUSTIFY"></font><big><font color="#0000FF" FACE="華康中黑體" LANG="ZH-TW">類別與介面（</font><font
color="#0000FF">Classes and Interfaces<font FACE="華康中黑體" LANG="ZH-TW">）</font> 
</font></big></p>
<font FACE="細明體" LANG="ZH-TW" size="3">

<p ALIGN="JUSTIFY">實踐</font><font size="3">59<font FACE="細明體" LANG="ZH-TW">：使用</font>interface<font
FACE="細明體" LANG="ZH-TW">支援多重繼承（</font>multiple inheritance<font
FACE="細明體" LANG="ZH-TW">）</font> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">當你想要支援</font></font><font
  FACE="Lucida Console" size="2">interface</font><font FACE="細明體" LANG="ZH-TW"
  size="3">的單一繼承或多重繼承，或者想要實作一個標記式的（</font><font
  size="3">marker<font FACE="細明體" LANG="ZH-TW">）</font></font><font
  FACE="Lucida Console" size="2">interface</font><font FACE="細明體" LANG="ZH-TW"
  size="3">時，請使用</font><font size="3">interfaces<font FACE="細明體"
  LANG="ZH-TW">。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>60<font FACE="細明體" LANG="ZH-TW">：避免</font>interfaces<font
FACE="細明體" LANG="ZH-TW">中的函式發生衝突</font> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">沒有任何辦法能夠阻止兩個</font>interfaces<font
  FACE="細明體" LANG="ZH-TW">使用同名的常數和函式。為了避免可能的衝突，應當小心命名常數和函式。</p>
</dir>
</font>

<p ALIGN="JUSTIFY"><font FACE="細明體" LANG="ZH-TW">實踐</font>61<font
FACE="細明體" LANG="ZH-TW">：需要提供部分實作（</font>partial implementation<font
FACE="細明體" LANG="ZH-TW">）時，請使用</font></font><font FACE="Lucida Console"
size="2">abstract </font><font size="3">classes</p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY"></font></font><font
  FACE="細明體" LANG="ZH-TW" size="3">使用</font><font FACE="Lucida Console" size="2">abstract</font><font
  size="3"> class<font FACE="細明體" LANG="ZH-TW">來為一個</font>class<font
  FACE="細明體" LANG="ZH-TW">提供部分實作，這些實作很可能對</font>derived 
  class<font FACE="細明體" LANG="ZH-TW">是共通的（都被需要的）。</p>
</dir>
</font>

<p ALIGN="JUSTIFY"><font FACE="細明體" LANG="ZH-TW">實踐</font>62<font
FACE="細明體" LANG="ZH-TW">：區分</font><font FACE="Lucida Console" size="2">interface</font><font
FACE="細明體" LANG="ZH-TW" size="3">、</font><font FACE="Lucida Console" size="2">abstract</font> 
class<font FACE="細明體" LANG="ZH-TW">和</font>concrete class </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">一旦正確理解了</font></font><font
  FACE="Lucida Console" size="2">interface</font><font FACE="細明體" LANG="ZH-TW"
  size="3">、</font><font FACE="Lucida Console" size="2">abstract</font><font size="3"> 
  class<font FACE="細明體" LANG="ZH-TW">和</font>concrete class<font FACE="細明體"
  LANG="ZH-TW">的差異，你就可以在設計和撰碼時做出正確的選擇。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>63<font FACE="細明體" LANG="ZH-TW">：審慎地定義和實作</font>immutable 
classes<font FACE="細明體" LANG="ZH-TW">（恆常類別） </font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">如果你希望</font>object<font
  FACE="細明體" LANG="ZH-TW">的資料永遠不被改動，請使用</font>immutable 
  object<font FACE="細明體" LANG="ZH-TW">。這種</font>objects<font FACE="細明體"
  LANG="ZH-TW">自動擁有執行緒安全性（</font>thread safety<font FACE="細明體"
  LANG="ZH-TW">）。</p>
</dir>
</font>

<p ALIGN="JUSTIFY"><font FACE="細明體" LANG="ZH-TW">實踐</font>64<font
FACE="細明體" LANG="ZH-TW">：欲傳遞或接收</font>mutable objects<font
FACE="細明體" LANG="ZH-TW">（可變物件）之</font>object references<font
FACE="細明體" LANG="ZH-TW">時，請施行</font><font FACE="Courier New" size="2">clone()</font><font
FACE="Lucida Console" size="2"> </font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">為了保證</font>immutable 
  objects<font FACE="細明體" LANG="ZH-TW">，你必須在傳入和回傳</font>immutable 
  objects<font FACE="細明體" LANG="ZH-TW">時對它們進行</font></font><font
  FACE="Courier New" size="2">clone</font><font FACE="細明體" LANG="ZH-TW" size="3">動作。</font><font
  size="3"><font FACE="細明體" LANG="ZH-TW"></p>
</dir>
</font>

<p ALIGN="JUSTIFY"><font FACE="細明體" LANG="ZH-TW">實踐</font>65<font
FACE="細明體" LANG="ZH-TW">：使用繼承（</font>inheritance<font FACE="細明體"
LANG="ZH-TW">）或委託（</font>delegation<font FACE="細明體" LANG="ZH-TW">）來定義</font></font><font
FACE="細明體" LANG="ZH-TW" size="3"> </font><font size="3">immutable classes<font
FACE="細明體" LANG="ZH-TW">（恆常類別）</font><font size="2"> </font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">使用</font>immutable </font><font
  FACE="Lucida Console" size="2">interface</font><font FACE="細明體" LANG="ZH-TW"
  size="3">、</font><font size="3">common interface<font FACE="細明體" LANG="ZH-TW">或</font>base 
  class<font FACE="細明體" LANG="ZH-TW">，或是</font>immutable delegation classes<font
  FACE="細明體" LANG="ZH-TW">，來定義</font>immutable classes<font FACE="細明體"
  LANG="ZH-TW">（恆常類別）。</p>
</dir>
</font>

<p ALIGN="JUSTIFY"><font FACE="細明體" LANG="ZH-TW">實踐</font>66<font
FACE="細明體" LANG="ZH-TW">：實作</font><font FACE="Courier New" size="2">clone()</font><font
FACE="細明體" LANG="ZH-TW" size="3">時記得呼叫</font><font FACE="Courier New"
size="2">super.clone()</font><font FACE="Lucida Console" size="2"> </font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">當你實作了一個</font></font><font
  FACE="Courier New" size="2">clone()</font><font FACE="細明體" LANG="ZH-TW" size="3">，總是應該呼叫</font><font
  FACE="Courier New" size="2">super.clone()</font><font FACE="細明體" LANG="ZH-TW"
  size="3">以確保產生正確的</font><font size="3">object<font FACE="細明體"
  LANG="ZH-TW">。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font>67<font FACE="細明體" LANG="ZH-TW">：別只是倚賴</font></font><font
FACE="Courier New" size="2">finalize()</font><font FACE="細明體" LANG="ZH-TW" size="3">清理記憶體以外的（</font><font
size="3">non-memory<font FACE="細明體" LANG="ZH-TW">）資源 </font></p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">你不能保證</font></font><font
  FACE="Courier New" size="2">finalize()</font><font FACE="細明體" LANG="ZH-TW" size="3">是否被呼叫，以及何時被呼叫。因此，請專門實作一個</font><font
  FACE="Courier New" size="2">public</font><font FACE="細明體" LANG="ZH-TW" size="3">函式來釋放記憶體以外的資源。</p>
</dir>

<p ALIGN="JUSTIFY">實踐</font><font size="3">68<font FACE="細明體" LANG="ZH-TW">：在建構式（</font>constructors<font
FACE="細明體" LANG="ZH-TW">）內呼叫</font>non-</font><font FACE="Courier New"
size="2">final</font><font FACE="細明體" LANG="ZH-TW" size="3">函式時要當心</font><font
size="3"> </p>

<dir>
  <font FACE="細明體" LANG="ZH-TW"><p ALIGN="JUSTIFY">如果一個</font>non-</font><font
  FACE="Courier New" size="2">final</font><font FACE="細明體" LANG="ZH-TW" size="3">函式被某個</font><font
  size="3">derived class</font><font FACE="細明體" LANG="ZH-TW" size="3">覆寫，在建構式中呼叫這個函式可能會導致不可預期的結果。</p>
  </font><font FACE="華康粗圓體" LANG="ZH-TW" size="7"><p ALIGN="RIGHT">　</p>
</dir>
</font><font FACE="華康粗圓體" LANG="ZH-TW" COLOR="#ffffff" size="7">

<p ALIGN="left"></font><font FACE="華康粗圓體" LANG="ZH-TW" size="7">前言<br>
</font><font FACE="細明體" LANG="ZH-TW" size="3" color="#0000FF">讓無知儘管信口開河吧，學習自有其價值</font><br>
<font color="#0000FF" size="3"><i>Let ignorance talk as it will, learning has its value.</i></font><br>
<font color="#0000FF" size="3">J. de La Fontaine, <i>The Use of Knowledge</i>, Book viii, 
Fable 19</font><font FACE="Footlight MT Light,Book Antiqua"></p>
</font><font size="3" FACE="細明體" LANG="ZH-TW">

<p ALIGN="JUSTIFY">本書彙集了</font><font size="3">Java<font FACE="細明體"
LANG="ZH-TW">編程實踐方面的建議、忠告、範例和討論。本書的組織是一個個獨立課程，每個課程謂之實踐（</font></font><font
FACE="Lucida Console" size="2">PRAXIS</font><font size="3" FACE="細明體" LANG="ZH-TW">，發音</font><font
size="3">prak-sis<font FACE="細明體" LANG="ZH-TW">），用以討論特定主題。每個實踐按各自獨立的方式撰寫。你可以從頭閱讀到尾，也可以挑選某些專題閱讀。這種編排風格使你可以在短暫的閒暇中閱讀此書。許多實踐都少於</font>5<font
FACE="細明體" LANG="ZH-TW">頁，因此你可以在簡短的時間內學習它們。</p>

<p ALIGN="JUSTIFY">我在這本書中詳細分析了某些設計（</font>design<font
FACE="細明體" LANG="ZH-TW">）和編程（</font>programming<font FACE="細明體"
LANG="ZH-TW">）方面的問題。我挑選主題的依據是編程實踐上的有效（</font>effective<font
FACE="細明體" LANG="ZH-TW">）和高效（</font>efficient<font FACE="細明體"
LANG="ZH-TW">）性質。</font>Java<font FACE="細明體" LANG="ZH-TW">最被人抱怨的一點是效能（效率，</font>performance<font
FACE="細明體" LANG="ZH-TW">），因此我以最大的篇幅討論這一主題，探索使</font>Java<font
FACE="細明體" LANG="ZH-TW">程式碼執行得更有效率的技術。</p>

<p ALIGN="JUSTIFY">我撰寫本書，希望它能夠作為指南，幫助你設計和撰碼。它可以幫助你更全面地理解</font>Java<font
FACE="細明體" LANG="ZH-TW">，讓你撰寫出更高效、更健壯和（或許最重要的是）更正確的程式碼。</p>

<p ALIGN="JUSTIFY">本書所有資訊都適用於各種</font>Java<font FACE="細明體"
LANG="ZH-TW">編程，並不囿於伺服端（</font>server<font FACE="細明體"
LANG="ZH-TW">）、客戶端（</font>client<font FACE="細明體" LANG="ZH-TW">）或</font>GUI<font
FACE="細明體" LANG="ZH-TW">（圖形用戶介面）編程。此外，你可以將這些資訊運用於</font>Java<font
FACE="細明體" LANG="ZH-TW">的任一發行版本。</p>

<p ALIGN="JUSTIFY">本書風格受了</font>Scott Meyers<font FACE="細明體"
LANG="ZH-TW">所著的《</font><font FACE="Book Antiqua"><i>Effective C++</i></font><font
FACE="細明體" LANG="ZH-TW">》和《</font><font FACE="Book Antiqua"><i>More Effective 
C++</i></font><font FACE="細明體" LANG="ZH-TW">》的影響</font></font><font
FACE="細明體" LANG="ZH-TW" size="3">。我發現他的風格對書籍組織非常有益，因此我決定採用類似的格式。</p>
</font><font FACE="華康粗圓體" LANG="ZH-TW">

<p><big>預期讀者</big></p>
</font><font FACE="細明體" LANG="ZH-TW" size="3">

<p ALIGN="JUSTIFY">本書是為已經掌握</font><font size="3">Java<font
FACE="細明體" LANG="ZH-TW">語言基礎知識的程式員準備的。我假設讀者已經具備</font>Java<font
FACE="細明體" LANG="ZH-TW">語言和並行編程（</font>concurrent programming<font
FACE="細明體" LANG="ZH-TW">）的工作經驗，並理解物件導向（</font>object-oreinted<font
FACE="細明體" LANG="ZH-TW">）的概念和術語。本書適用於「想獲得如何高效使用</font>Java<font
FACE="細明體" LANG="ZH-TW">之實用建議、討論和範例」的程式員。</p>

<p ALIGN="JUSTIFY">無論對</font>Java<font FACE="細明體" LANG="ZH-TW">編程老手或新手，本書都為他們提供了</font>Java<font
FACE="細明體" LANG="ZH-TW">關鍵領域的資訊和討論。本書提供充足的新資訊，即使經驗豐富的程式員也能從考查他們業已熟悉的領域中獲得極大收益。例如在某些場合，我以獨特的方式討論問題，幫助程式員以不同的方法思考，或使用與以往不同的角度看待事物。</p>

<p ALIGN="JUSTIFY">初入門的程式員也可以從本書獲益良多。我提供了討論和範例，幫助他們消除許多常見的編程錯誤。我也澄清了某些常見的</font>Java<font
FACE="細明體" LANG="ZH-TW">錯誤觀念，並強調語言特性方面的某些問題。</p>
</font></font><font FACE="華康粗圓體" LANG="ZH-TW">

<p><big>本書組織</big></p>
</font><font FACE="細明體" LANG="ZH-TW" size="3">

<p ALIGN="JUSTIFY">本書組織為六大部分。</p>

<ol>
  <li>一般技術</font><font size="3"> <font FACE="細明體" LANG="ZH-TW">展現</font>Java<font
    FACE="細明體" LANG="ZH-TW">編程的數個基礎領域，包括引數傳遞（</font>parameter 
    passing<font FACE="細明體" LANG="ZH-TW">），</font>arrays<font FACE="細明體"
    LANG="ZH-TW">，</font></font><font FACE="Lucida Console" SIZE="2">Vector</font><font
    size="3">s<font FACE="細明體" LANG="ZH-TW">以及垃圾回收（</font>garbage 
    collection<font FACE="細明體" LANG="ZH-TW">）。</li>
  <li>物件與相等性</font> <font FACE="細明體" LANG="ZH-TW">研究物件（</font>objects<font
    FACE="細明體" LANG="ZH-TW">）和基礎型別（</font>primitive types<font
    FACE="細明體" LANG="ZH-TW">），以及如何、為何為一個</font>class<font
    FACE="細明體" LANG="ZH-TW">實作</font></font><font FACE="Lucida Console" SIZE="2">equals()</font><font
    FACE="細明體" LANG="ZH-TW" size="3">。</li>
  <li>　</li>
  <li>異常處理</font><font size="3"> <font FACE="細明體" LANG="ZH-TW">提供異常處理技術（</font>exception 
    handling techniques<font FACE="細明體" LANG="ZH-TW">）的細緻分析，並告訴你如何在你的程式碼中高效加入異常處理機制。</li>
  <li>效能（效率）</font> <font FACE="細明體" LANG="ZH-TW">展示可用來改善程式碼效能的諸多技術，並仔細審查</font>JVM<font
    FACE="細明體" LANG="ZH-TW">（</font>Java<font FACE="細明體" LANG="ZH-TW">虛擬機器）、</font>byte 
    code<font FACE="細明體" LANG="ZH-TW">和</font>JITs<font FACE="細明體" LANG="ZH-TW">（及時程式碼生成器）。</li>
  <li>多執行緒</font> <font FACE="細明體" LANG="ZH-TW">涵蓋執行緒模型（</font>threading 
    model<font FACE="細明體" LANG="ZH-TW">）的諸多方面</font> <font FACE="細明體"
    LANG="ZH-TW">它們對於建立健壯、可靠的多執行緒程式極為關鍵。</li>
  <li>類別與介面</font> <font FACE="細明體" LANG="ZH-TW">解釋了</font>interfaces<font
    FACE="細明體" LANG="ZH-TW">、</font></font><font FACE="Lucida Console" SIZE="2">abstract</font><font
    size="3"> classes<font FACE="細明體" LANG="ZH-TW">和</font>concrete classes<font
    FACE="細明體" LANG="ZH-TW">，以及何處、何時使用它們。這部分還詳細討論了</font>immutable 
    object<font FACE="細明體" LANG="ZH-TW">（不可變物件）、</font>cloning<font
    FACE="細明體" LANG="ZH-TW">（克隆、複製）和</font>finalization</font><font
    FACE="細明體" LANG="ZH-TW" size="3">（終結）。</li>
</ol>

<p ALIGN="JUSTIFY">在上述各標題之下，是數量不等的相關專題。往往我會在不止一處討論特定專題的某個屬性。例如我在不同場合討論了</font><font
FACE="Lucida Console" SIZE="2">synchronized</font><font FACE="細明體" LANG="ZH-TW"
size="3">關鍵字的方方面面，每次討論都涉及</font><font
FACE="Lucida Console" SIZE="2">synchronized</font><font FACE="細明體" LANG="ZH-TW"
size="3">的不同特性。為此，我提供了擴展性甚強的交叉參照，你可以由此得知何時閱讀特定專題、何處存在相關資訊。</p>

<p ALIGN="JUSTIFY">目錄之後便是細目。這一部分包含所有實踐標題和其頁碼，並附有每個實踐的核心概要。你可以使用這個細目喚起你對專題的記憶，或用以找出某個專題。</p>

<p ALIGN="JUSTIFY">附錄內含一個已經證實的技術，可以進一步擴展你的</font><font
size="3">Java<font FACE="細明體" LANG="ZH-TW">知識。之後還有一份「進一步閱讀」列表，列出關於</font>Java<font
FACE="細明體" LANG="ZH-TW">、一般設計和編程方面的書籍和期刊。</p>
</font></font><font FACE="華康粗圓體" LANG="ZH-TW">

<p><big>三言兩語話</font><font FACE="Footlight MT Light,Book Antiqua">PRAXIS</font></big><font
FACE="華康粗圓體" LANG="ZH-TW" size="3">（實踐）</p>
</font><font FACE="Lucida Console" size="2">

<p ALIGN="JUSTIFY">PRAXIS</font><font FACE="細明體" LANG="ZH-TW" size="3">（實踐）一詞，是我查詢「得以概括本書所做工作」的詞彙的結果。</font><font
size="3">1982<font FACE="細明體" LANG="ZH-TW">年的《</font><font FACE="Book Antiqua"><i>American 
Heritage Dictionary</i></font><font FACE="細明體" LANG="ZH-TW">》將</font></font><font
FACE="Lucida Console" size="2">PRAXIS</font><font FACE="細明體" LANG="ZH-TW" size="3">定義為：</font><font
size="3">The practical application or exercise of a branch of learning<font
FACE="細明體" LANG="ZH-TW">（實際應用或訓練；學習的一個支脈）。這正是我希望在本書中達成的。</p>

<p ALIGN="JUSTIFY">最確切的恐怕是《</font><font FACE="Book Antiqua"><i>Webster's 
New Collegiate Dictionary</i></font><font FACE="細明體" LANG="ZH-TW">》於</font>1958<font
FACE="細明體" LANG="ZH-TW">年給出的一份定義：</font>Practice, especially of an 
art, science, or technical occupation; opposite to theory</font><font FACE="細明體"
LANG="ZH-TW" size="3">（實際</font><font FACE="細明體" LANG="ZH-TW" SIZE="2">履行</font><font
FACE="細明體" LANG="ZH-TW" size="3">，尤指藝術、科學或技術領域；與理論遙相對應）。這個定義準確概括了本書精髓。那句</font><font
size="3">opposite to theory<font FACE="細明體" LANG="ZH-TW">更是畫龍點睛。「理論」本身當然沒錯，但本書沒有為它準備位置。</p>
</font></font><font FACE="華康粗圓體" LANG="ZH-TW">

<p><big>範例程式碼</big></p>
</font><font FACE="細明體" LANG="ZH-TW" size="3">

<p ALIGN="JUSTIFY">正文所列的所有程式碼，都採用本書寫作時可獲得之</font><font
size="3">Java<font FACE="細明體" LANG="ZH-TW">最新版本加以編譯和運行。所有程式碼都曾經在</font>Windows 
NT 4.0<font FACE="細明體" LANG="ZH-TW">環境下以</font>Sun Java 2 SDK<font
FACE="細明體" LANG="ZH-TW">，</font>Standard Edition<font FACE="細明體"
LANG="ZH-TW">，</font>v1.2.1<font FACE="細明體" LANG="ZH-TW">完成編譯和運行。如果你想要得到原始碼，請在以下網址進行註冊：</p>

<dir>
  </font></font><font FACE="Courier New" size="2"><p>http://www.awl.com/cseng/register</p>
</dir>
</font><font FACE="細明體" LANG="ZH-TW" size="3">

<p ALIGN="JUSTIFY">該網頁要求你輸入一個獨一無二的碼，此碼可在本書末尾標明為「</font><font
size="3">How to Register Your Book<font FACE="細明體" LANG="ZH-TW">」的頁面找到。</p>
</font></font><font FACE="華康粗圓體" LANG="ZH-TW">

<p><big>提供反饋</big></p>
</font><font FACE="細明體" LANG="ZH-TW" size="3">

<p ALIGN="JUSTIFY">歡迎讀者對本書提供相關反饋資訊。任何建議、批評或臭蟲報告，都請寄到</font><font
size="3">PracticalJava@awl.com<font FACE="細明體" LANG="ZH-TW">。</p>

<p ALIGN="JUSTIFY">希望本書讓你覺得有用、可讀，並且具備實用價值。</p>

<dir>
  </font></font><font FACE="Courier New" size="2"><i><p ALIGN="left">Peter Haggar<br>
  Research Triangle Park, North Carolina<br>
  November, 1999</p>
  </i></font><font FACE="細明體" LANG="ZH-TW" SIZE="2">
</dir>
</font>
</body>
</html>
