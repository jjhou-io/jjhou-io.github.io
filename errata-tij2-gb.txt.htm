<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=big5">
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
<title>勘誤《Java 編程思想》2/e&nbsp; 簡體</title>
</head>

<body>

<pre>本勘誤檔更新日期: 2005/01/28</pre>

<pre>《Java 編程思想》2/e 簡體
機械出版社華章公司 出版, 2002/09</pre>

<pre>原著：Thinking in Java 2e, 
      by Eckel Bruce
      Prentice Hall, 2000          

請注意：以下各項修正皆以日期排序</pre>

<pre>======================================================</pre>

<pre>書籍內容更正，有兩種作法，一是在網際網路上做個專屬勘誤
網頁，讓大家上去看。這是比較即時的作法。而更理想更負責
的作法是：不但有勘誤網頁，並且在新刷中予以更正 -- 如果
有新刷的話。</pre>

<pre>不過，理想與現實之間需要一點協調。書籍的製作是這樣的，
製版與印刷時，是以檯（8 或 16 頁）為單位。因此，每換一
頁，同檯的各頁統統要換過。這便造成印製成本的大量增加。</pre>

<pre>以前，我從不考慮成本，只要我認為書籍內容有修改必要，即
使只是某個字詞用得不甚理想，我都會請出版社更新。出版社
也都全力配合（這一點讓我非常感謝）。</pre>

<pre>慢慢地，我的行事不再這麼霹靂，我覺得我多少也要站在出版
社的立場想想。所以我打算，如果是關係到對錯正誤的根本性
問題，我便一定在新刷修正。如果是易判別的錯別字或排版誤
失或用詞不很恰當…等等，我便先在勘誤網頁上明載，但不求
立刻於新刷中更正。直到收集來的這類誤失較為密集了，才一
併於下一刷修正。</pre>

<pre>哪些是新刷已修正的，哪些是暫請讀者自行動手更改的，我會
在勘誤網頁（網址見書封底）上很清楚地說明。</pre>

<pre>這是個便宜法門，請讀者見諒。</pre>

<pre>書籍應該在出版前就詳細檢查，以完美之姿出現。但是完美很
難達到。對於下列大大小小輕重不等的誤失，我謹向讀者說抱
歉。</pre>

<pre>本檔歡迎廣為流傳，謝謝。
</pre>

<pre>以下為更新記錄。如果您購買的是第 n 刷，請將以下第 n+1
刷之後的更新內容自行修正至書上。謝謝</pre>

<pre>======================================================</pre>

<pre><font color="#0000FF">以下已於第二刷更正完畢</font>
（注意，Lm 表示第 m 行，L-n 表示倒數第 n 行）</pre>

<pre>■序言p3, L24（錯字）
原文：同樣的，「設計樣式（Design Patters）」
修改：同樣的，「設計樣式（Design Patter<strong><font
color="#0000FF">n</font></strong>s）」
感謝：gigix
日期：2002/09/16

■p100,L-16（中文版處理錯誤）
原文：緊接於其後的表達式則使用<font
color="#FF0000">邏輯運算符</font>來產生...
修改：緊接於其後的表達式則使用<font
color="#0000FF">關係比較式（relational comparisons）</font>來產生...
感謝：施正桓
日期：2002/09/19

■p110,L-8（筆誤）
原文：FORTAN 是個全面使用大寫字母的語言...
修改：FORT<strong><font
color="#0000FF">R</font></strong>AN 是個全面使用大寫字母的語言...
感謝：dbai
日期：2002/09/19

■p217,L12（處理錯誤）
原文：將其「對象生成<font
color="#FF0000">空間</font>」註解掉
修改：將其「對象生成<font
color="#0000FF">動作</font>」註解掉
感謝：annhy
日期：2002/09/20

■p195,L8（譯筆不佳，原書文字亦不佳。現按技術意義重譯）
原文：
<font
color="#FF0000">  注意，Bath 構造函數中，有一行語句在任何初始化動作之前執行。如果你未
  在定義處進行初始化，那麼就無法保證在你發送消息給 object references
  之前能夠進行任何初始化 — 反倒是無可避免會發生執行期異常。
</font>修改：
<font
color="#0000FF">  注意 Bath 構造函數中有一行語句在所有初始化動作之前執行。如果你未曾
  在數據成員定義處初始化 object references，便無法保證它們在接受消息
  之前已完成初始化 — 果真如此便會發生執行期異常。
</font>感謝：annhy
日期：2002/09/20

■p203,L-18（原譯不佳。重譯）
原文：
<font
color="#FF0000">  那麼在 derived class 中重新定義此一函數，並不會遮蔽它在 base class 中
  的任何版本。因此，不論該層 class 或 base class 是否定義了這個函數，
  都會發揮重載作用
</font>修改：
<font
color="#0000FF">  那麼在 derived class 中重新定義（使用）此一函數名稱，並不會遮蔽它在 base class 中
  的任何版本。因此，函數不論被定義於某層 class 或其 base class，重載機制都可正常運作
</font>感謝：annhy
日期：2002/09/20

■p193,第一段文字第一行（討論）
原文：
  每個非基本型別的物件都具備 toString()，當編譯器希望得到一個
  String，而你手上卻只有那些對象的情況下，這個函數便會被喚起。
<font
color="#408080">討論 by annhy：
到底在哪種情況下這個函數會自動被喚起？想來想去好像還是只有 &quot;字符串加法&quot; 啊!!
我寫了一個小程式來測試：
public class A {
  public String toString() {
    return &quot;A&quot;;
  }
  static void pStr(String str) {
    System.out.println(&quot;pStr: &quot; + str);
  }
  static void pObj(Object obj) {
    System.out.println(&quot;pObj: &quot; + obj);
  }
  public static void main(String[] args) {
    A a = new A();
    pObj(a);              // pObj() 內有字符串加法
    //! pStr(a);          // pStr() 需要 String，但也不會自動呼叫 toString()
    //! pStr((String)a);  // 將 A 轉型為 String 是不合法的
    pStr(a.toString());   // 自行呼叫 toString()，可以
    pStr(a + &quot;&quot;);         // 經過 &quot;字符串加法&quot; 也可以
    //! pStr(a + 1);      // 經過 &quot;數值加法&quot; 就不行
  }
}
另外在 JSP 中的寫法 &lt;%=objectReference%&gt; 也可以自動呼叫 toString()。
不過這大概是個可以接受 Object 型別的函數，而內部會呼叫 toString() 吧。
測試例如下：
&lt;%@ page contentType=&quot;text/html; charset=Big5&quot; %&gt;
&lt;html&gt;
  &lt;body&gt;
    目前時間: &lt;%=new java.util.Date()%&gt;
  &lt;/body&gt;
&lt;/html&gt;
除了「字符串加法」和「JSP」外，我實在想不出還有哪些情況會自動呼叫 toString()
</font>
感謝：annhy
日期：2002/09/20

■p264,L4（原譯不佳。重譯）
原文：
<font
color="#FF0000">  3. 一個匿名（anonymous）class，用以實現某個 interface。
  4. 一個匿名 class，用來擴充一個擁有 non-default 構造函數的 class。
  5. 一個匿名 class，用來執行數據成員初始化動作。
</font>修改：
<font
color="#0000FF">  3. 一個匿名（anonymous）class，實現某個 interface。
  4. 一個匿名 class，擴充某個「擁有 non-default 構造函數」之 class。
  5. 一個匿名 class，執行數據成員初始化動作。
</font>感謝：jjhou
日期：2002/09/21

■p429,L-6（贅字）
原文：4.輸出至文件<font
color="#FF0000">的</font>
修改：4.輸出至文件
感謝：jjhou
日期：2002/09/21

■p93,L14（誤植）
原文：這意謂，如果對<font
color="#FF0000">是將</font>寫下 C = D 這樣的式子，...
修改：這意謂，如果對<font
color="#0000FF">兩個對象</font>寫下 C = D 這樣的式子，...
感謝：jjhou
日期：2002/09/24

■p95,L-1~L-2，範例 c03:MathOps.java（討論）

<font
color="#408080">    // '%' limits maximum value to 99:
    j = rand.nextInt() % 100;
    k = rand.nextInt() % 100;
  j, k 的值其實是 [-99, 99] 之間的整數(包括 0)
  因此在執行這個程序時，會有約 1/50 的機率（好像不低耶）
  發生錯誤（java.lang.ArithmeticException: / by zero）

  這是因為後頭會有除以零的情形
    i = k / j; pInt(&quot;k / j&quot;, i);
    i = k % j; pInt(&quot;k % j&quot;, i);
    j %= k;    pInt(&quot;j %= k&quot;, j);

以下是我的想法：
1. 由於在這個範例以及之前的內容中，均沒有提到 java.lang.ArithmeticException，
   所以這個 Exception 應該不是作者故意留在程式中讓讀者體會的。比較好的做法是在
   書中內容增加一些篇幅，解釋這一部分數學運算的問題。

2. 或者也可以用權宜的方式，將 L-1~L-2 改成
     // limits the integer values between [1, 100]:
     j = rand.nextInt(100) + 1;
     k = rand.nextInt(100) + 1;
   則 j, k 的值為 [1, 100] 之間的整數，便不會有除以零的問題。
   只不過這樣會只剩下 [正整數] 的數學運算，可能會偏離作者設計此範例的原義。

3. 至於後來出現的隨機浮點數
     v = rand.nextFloat();
     w = rand.nextFloat();
   由於 v, w 為 0.0f 的機率就只有 2^-24 這麼少，實在不容易碰上。
   而且就算碰上了，除以 0.0f 也不會發生 ArithmeticException，只會是 NaN 罷了，
   所以這應該是無傷大雅的。

4. 真是奇怪，1/50 的機率應該不算低，怎麼都沒有人提出這個問題？難道大家都不
   執行範例程式來看看嗎？
   我猜大部分的人會以為自己 keyin 錯程式碼或下錯指令，結果第二次執行就正常了。
   由於要連續兩次都出現錯誤的機率提高到了 1/2500，這個機率就算低了。
</font>
感謝：annhy
日期：2002/09/25

■p110,L-8（誤植）
原文：1<font
color="#FF0000">7</font>60-1970 年代
修改：1<font color="#0000FF">9</font>60-1970 年代
感謝：devilotte
日期：2002/10/03

■p294,L10（英文版誤植）
修改：a.length = 2  此行應移至程式輸出第一行。修改後之結果為：

<font
color="#0000FF">      a.length = 2</font>
      b.length = 5
      b[0]=null
      b[1]=null
      b[2]=null
      b[3]=null
      b[4]=null
      c.length = 4
      d.length = 3
      a.length = 3
      f.length = 5
      ...
感謝：kevinLin, songwae
日期：2002/10/03

■p767,第一段文字，第二行（誤植）
原文：第一個 #include 指令會<font
color="#FF0000">括</font>入 j<font color="#FF0000">in</font>.h，
修改：第一個 #include 指令會<font
color="#0000FF">含</font>入 j<font color="#0000FF">ni</font>.h，
感謝：Starr
日期：2002/10/03

■p786,L-5（誤植）
原文：自行印製,19<font
color="#FF0000">9</font>8）
修改：自行印製,19<font color="#0000FF">8</font>8）
感謝：Starr
日期：2002/10/03

■p309,L-2（英文版錯誤）
原文：引數<font
color="#FF0000">小</font>於自己時返回負值，二者相等時返回零值，引數<font
color="#FF0000">大</font>於自己時返回正值。
修改：引數<font color="#0000FF">大</font>於自己時返回負值，二者相等時返回零值，引數<font
color="#0000FF">小</font>於自己時返回正值。
感謝：zhycq
日期：2002/10/03

■p439,L-7（英文版錯誤）
讀者來函：
經測試後發現，destination 與 manifest 的順序與 options 中的 f,m 的順序相依。
因此書中 p439,L-7 的例子不符合條件。
原文：jar c<font
color="#FF0000">mf</font> myJarFile.jar myManifestFile.mf *.class
修改：jar c<font
color="#0000FF">fm</font> myJarFile.jar myManifestFile.mf *.class
感謝：Walter Suen
日期：2002/10/03

■p505,L24（討論）
<font
color="#408080">讀者來函：
p505,L24 註解
  // The improved solution in JDK 1.3:
  //  frame.setDefaultCloseOperation( EXIT_ON_CLOSE );
其中的 EXIT_ON_CLOSE 常數其實是 JDK1.4 才加入，
在 JDK1.3 中只有 DO_NOTHING_ON_CLOSE、HIDE_ON_CLOSE、DISPOSE_ON_CLOSE 三個常數
此外，應寫成 WindowConstants.DISPOSE_ON_CLOSE。
（雖然 JFrame 實現了 interface WindowConstants
但我用 jdk 1.3.1_4 得寫 WindowConstants.DISPOSE_ON_CLOSE 才跑得出來）
</font>感謝：Canby
日期：2002/12/10

■p440,L4（討論）
<font
color="#408080">讀者來函：
原書英文版如下：
  If you create a JAR file using the 0 option, that file can be placed in your CLASSPATH:
  CLASSPATH=&quot;lib1.jar;lib2.jar;&quot;
  Then Java can search lib1.jar and lib2.jar for class files.
依此說明，意義應為：
  『jar 文件必須不是壓縮格式才可以放在 classpath 使用』
但我查詢 J2SDK 說明文檔則有如下文句(...\JDK 1.4 Docs\tooldocs\win32\jar.html)
    A jar archive can be use as a class path entry, whether it is compressed or not.
依此說明，classpath 的 jar 檔不論壓縮與否都可以使用，作者如此說明
是否緣於版本的差異所致，我無法查證。但我測試結果壓縮格式確實能使用。
可否賜教以解疑惑，謝謝您！
</font>
侯捷回覆：
原文並沒有「只限於非壓縮格式」的意思。
不過，中文版卻做了過度說明，易起誤會。修改如下。

原文：
如果你以選項 O 建立 JAR 文件，它<font
color="#FF0000">便</font>可被置於你的 CLASSPATH 之下：
  CLASSPATH=&quot;lib1.jar;lib2.jar;&quot;
<font
color="#FF0000">如此一來</font> Java <font color="#FF0000">便</font>可在 lib1.jar 和 lib2.jar 中查找 class 文件。

修改：
如果你以選項 O 建立 JAR 文件，它可被置於你的 CLASSPATH 之下：
  CLASSPATH=&quot;lib1.jar;lib2.jar;&quot;
<font
color="#0000FF">於是</font> Java 可在 lib1.jar 和 lib2.jar 中查找 class 文件。

感謝：Walter Suen
日期：2002/12/10


■p641（討論）
<font
color="#408080">讀者來函：
第六、七個試驗我的執行結果分別為：
java.lang.ThreadGroup[name=g1,maxpri=3]
    Thread[A,9,g1]
    Thread[B,8,g1]
    Thread[C,3,g1]
java.lang.ThreadGroup[name=g1,maxpri=3]
    Thread[A,9,g1]
    Thread[B,8,g1]
    Thread[C,2,g1]
這個程序群組為 3 時，新線程也為 3，和書上不一樣
我想是版本的關係。我用的JDK 1.3.1_04
</font>感謝：Canby
日期：2002/12/10

■p637, L17（討論）
<font
color="#408080">讀者來函：
g.enumerate(gAll); 此函數無法精確寫入 gAll，
使得接下來的 for() 丟出 NullPointerException
（我用的 JDK 為 1.3.1_04 多語版）
</font>感謝：Canby
日期：2002/12/10

■p256,L21（討論）
<font
color="#408080">讀者來函：
  public final static Month2[] month = {
    JAN, JAN, FEB, MAR, APR, MAY, JUN,
    JUL, AUG, SEP, OCT, NOV, DEC
  };
  本書前面曾經提到，就算 array 宣告為 final，也無法阻止 array 的內容
  被更改。因此上述 month 有可能遭到 user 破壞，例如：
    Month2.month[1] = null;
  如果改為 get method 便可更進一步成為範例註解所說的「A more robust
  enumeration system」。而且也不需要多放進一個 JAN 使索引偏移一個位置：

  private final static Month2[] month = {
    JAN, FEB, MAR, APR, MAY, JUN,
    JUL, AUG, SEP, OCT, NOV, DEC
  };
  public static Month2 getMonth(int i) {
    return month[i-1];
  }
</font>感謝：annhy
日期：2002/12/10

■p256,L11（討論）
<font
color="#408080">原文：此一 class 名為 Month2，避免和 Java 標準程序庫的 Month class 衝突。
疑問：有這個 class 嗎？我在 JDK 1.4 的 API 中找不到耶...
</font>感謝：annhy
日期：2002/12/10

■p259,L-12（修潤）
原文：<font
color="#FF0000">「定義於該 interface 中的函數」</font>
修改：<font
color="#0000FF">「該 interface 中的函數的定義」</font>
感謝：annhy
日期：2002/12/10

■p261,L-6（討論）
<font
color="#408080">原文：
  如果你想要在外圍 class 的 non-static 函數之外產生一個 inner class 對象，
  你就得以 OuterClassName.InnerClassName 的型式指定該對象的型別，
  一如上述 main() 的行為。
討論：
  我把 main() 中 Parcel2.Contents 前面的 Parcel2 刪掉，執行起來
  並不會有問題 (測試環境 JDK 1.4 )
</font>感謝：annhy
日期：2002/12/10

■p267,L1（討論）
<font
color="#408080">原文：
  是的，只要將適當引數傳入 base class 構造函數中，就像將 x 傳入 new Wrapping(x)
  中一樣。匿名 class 不能擁有構造函數，所以通常你會調用 super()。
疑問：
  「通常你會調用 super()」？在這個範例中，匿名 class 調用的明明是
  super(x) 而不是 super() 啊！而且我們也沒有自行調用啊？於是我只好
  求助於英文版來解決我的疑惑。不過這句「where you would normally
  call super()」還真難翻譯，我雖然看得懂他在說什麼，但就是無法用中
  文很通順地表達出來...
英文：
  That is, you simply pass the appropriate argument to the base-class
  constructor, seen here as the x passed in new Wrapping(x). An
  anonymous class cannot have a constructor where you would normally
  call super().
試譯如下：
  在這裡，你只是簡單地將引數轉交給 base class 的構造函數，看起來就像
  是直接將 x 傳入 new Wrapping(x) 中一樣。匿名 class 不能擁有構造函數，
  因此你不能像平常那樣在構造函數中調用 super() (以擴充 base class 構造函數的行為)。
</font>感謝：annhy
日期：2002/12/10

■p349,L1（討論）
<font
color="#408080">原文：本例之中程序員必須保證，沒有任何兩個 Groundhog 對象具有相同的編號。
討論：
  1. 本例的對象應為 Groundhog2 object
  2. 本例不就是要展現：當有兩個編號均為 3 的 Groundhog2 instance 也能正常運作嗎？
     前一個例子 (p347, c09:SpringDetector.java) 似乎才需要此限制。
</font>侯捷回覆：
  1. 請將 <font
color="#FF0000">Groundhog</font> 修改為 <font color="#0000FF">groundhogs（土撥鼠）</font>— 這裡並不代表 class 名稱。
  2. 不，本例要展現的是，先前以 new Groundhog2(3) 做出來的 A 對象，和後來再次以
     new Groundhog2(3) 做出來的 B 對象，兩者雖然地址不同（導致缺省的 hashCode 不同），
     但由於我們覆寫了 Groundhog2 的 hashCode() 和 equals()，造成其 hashCode 相同
     並被視為「相等」。這麼一來我們才能夠拿 B 對象來查找（比對）map，
     找出 map 中與之相等的 A 對象。
感謝：annhy
日期：2002/12/10

■p354,L6（修改）
原文：現在，你已經了解 HashMap <font
color="#FF0000">函數</font>牽涉了哪些東西
修改：現在，你已經了解 HashMap <font
color="#0000FF">的運作</font>牽涉了哪些東西
感謝：annhy
日期：2002/12/10

■p369,表格下第一行（修改）
原文：min() 和 max() <font
color="#FF0000">都能處理 Collection 對象，但不能處理 List。</font>
修改：min() 和 max() <font
color="#0000FF">是針對 Collection 對象做動作，而不是針對 Lists。</font>
感謝：annhy
日期：2002/12/10

■p434,L-5（修改）
原文：這個程序會將標準輸入裝置<font
color="#FF0000">的內容附加於文件內</font>，
修改：這個程序會將標準輸入裝置<font
color="#0000FF">附著於一個文件</font>，
感謝：annhy
日期：2002/12/10

■p431（討論）
<font
color="#408080">讀者來函：
  在 p431「這是個臭蟲嗎？」這個 section 中，我的看法和書中所說的那位
  JavaSoft 的人員一樣，Bruce Eckel 大師似乎用了一種怪異的方式來使用 Java
  IO stream，因而導致錯誤發生。我不認為這是個 bug。

  我想用個譬喻來說明好了。多個 streams 疊合運作時，看起來就好像是一堆
  不同的水管線路接起來，裡面有自來水管線入口、加壓馬達、屋內管線、塑膠水
  管出口，中間可能再加上個水塔。每次將一個 stream 對象（上游）疊合置入
  另一個 stream 對象（下游）之中，看起來就像是把上下游兩個管線緊密接起。
  而當整個管路中沒有任何分支時，才能保證上游所有的水都可以到達下游，
  不會在中游某個部分發生漏水現象。這是 Java IO stream 最常見的用法。

  但在此例 (p431-p432) 還有前例 (p427) 中的 streams（從上游到下游）：

  FileInputStream ==&gt; BufferedInputStream ==&gt; DataInputStream (in)
   ==&gt; InputStreamReader ==&gt; BufferedReader (inbr)

  我們本應只使用最末端（最外層）inbr 來讀取所有數據，但作者在 in 的
  地方等於多挖了個洞來裝水龍頭。如此，有些水（data）便流不到 inbr，而是在
  in 就流出去了。作者依照下面的順序來讀取 data，認為在第四個指令會發生
  EOFException 錯誤是很怪異的。但這是因為 inbr 像是個水塔（buffer），它在
  第三個指令就已將之後所有的水載入了，in 當然就沒有水可用了。

  in.readDouble();
  inbr.readLine();
  inbr.readLine();
  in.readDouble(); //!! EOFException !!

  作者預期「每個 stream 對象在讀取數據時，只會向上游 stream 要求剛好滿足
  數量的 data」，但事實上不然，Java 文件中好像也沒有這樣規定。而
  BufferedReader 為了效率考量，在呼叫 readLine() 時多要求一些 data
  以備不時之需，看起來也是很合理的，不然它怎麼能稱為 Buffered。我們甚至可
  以自己撰寫一個 FullyBufferedReader — 在構造函數中便將上游所有資料載入，
  這樣會連上面的第一個指令都發生錯誤。

  寫到這裡，就想到前一陣子的限水運動。大樓中各住戶共用一個水塔，我本來也想
  響應政府節約用水的政策，但是想到我並沒有權力要求其他住戶也要有公德心，於
  是我就只好把家中所有能裝水的水桶、浴缸通通存滿水來保護自己。只是這麼一來
  ，我的水是夠用了，但可能就有某個倒楣的傢伙沒水可用。本例也是一樣，當兩個
  下游 streams 共享同一個上游 stream，就有可能發生互搶狀況。

結論：
  看完這部分，我對使用 Java IO stream 有個感覺：「當內層 stream 對象(s)
  （上游）置入外層 stream 對象(s)（下游）之後，便應該將中間通路看成一個黑箱
  （black-box），只能對兩端（最上游 &amp; 最下游）對象進行操作，似乎應避免操作
  中間通路對象」。不知道這個觀念是否正確？若是，可以將這個觀念擴及
  其他的 Decorator pattern 嗎？
</font>
侯捷回覆：您的討論鞭辟入裡，文字表達能力也非常好。
   是否擴及其他 Decorator patterns，還待思考。先謝謝您。
感謝：annhy
日期：2002/12/10


■p431（討論）
<font
color="#408080">讀者來函：
In TIJ 2/e Rev12 and TIJ 3/e beta, the author add the following at the end
of 'A Bug?' section:
///////////////////////////////////////////////////////
[Removed from text] (This was a bug in my reasoning; I did not
understand the intention of writeUTF( ) and readUTF( ). Also, creating two
buffers for the same stream turns out to be a big mistake; the first
buffer that you read sucks up extra bytes so the second buffer gets
indeterminate output). [ Add Comment ]
///////////////////////////////////////////////////////
But since TIJ 2/e Rev12 is still under contruction (there's [ Add Comment ]
at the end of the paragraph) and TIJ 3/e is still a beta version, we can
know that the final definite decision has not been made about the section.

Thus, although it's almost the case, now we can only regard it as a
suggestion of the author.

</font>提示：請參考上一項討論
感謝：ark
日期：2002/12/10

■p462,L-16（討論）
<font
color="#408080">原文：
  nextToken() 會返回一個語彙單元，或返回無內容的字符串（代表字符串中已無任何語彙單元）
討論：
  nextToken() 在已無任何語彙單元時並不會返回空字串，而是會
  throw java.util.NoSuchElementException。這也是為什麼作者在 p463,L-6
  要另外宣告一個 next() 函數來包裝 nextToken() 的原因。
</font>感謝：annhy
日期：2002/12/10

■p471,L-1（討論）
<font
color="#408080">原文：
  當你將某個對象傳入某個「預期收到 String」的函數時，便會自動調用
  該對象的 toString()，這是 Java 提供的有限度自動型別轉換功能。
討論：
  這個問題與之前 &quot;p193,第一段文字第一行&quot; 的討論相同，傳入某個「預期收到 String」
  的函數時「並沒有」如同作者所說的有限度「自動型別轉換」功能，似乎只有
  「字符串相加」才會自動呼叫某個對象的 toString()，除此之外都必須手動呼叫。
  下面的測試程式證實了我的想法：

    public class ToStringTester {
      static void print1(String str) {
        System.out.println(&quot;print1: &quot; + str);
      }
      static void print2(Object obj) {
        System.out.println(&quot;print2: &quot; + (String)obj);
      }
      static void print3(Object obj) {
        System.out.println(&quot;print3: &quot; + obj.toString());
      }
      public static void main(String[] args) {
        java.util.Date d = new java.util.Date();
        //! print1(d);  // compile error
        //! print2(d);  // run-time error
        print3(d);
      }
    }

  print1() 便是作者所說的情形，會發生 compiler error。
  print2() 是 print1() 的手動型別轉換版，會發生 run-time error。
  只有 print3() 手動呼叫 toString() 是可以正確執行的。
</font>
感謝：annhy
日期：2002/12/10

■p482,L-1（大小寫處理錯誤）
原文：<font
color="#FF0000">class </font>的 isInstance()
修改：<font color="#0000FF"><strong>Class </strong></font>的 isInstance()    // 編輯請注意：Class 應使用加重字體
感謝：annhy
日期：2002/12/10

■p505,L25（補充）
原文： // frame.setDefaultCloseOperation(
       //     EXIT_ON_CLOSE);
修改： // frame.setDefaultCloseOperation(
       //     <font
color="#0000FF">JFrame.</font>EXIT_ON_CLOSE);
討論：EXIT_ON_CLOSE 是 JFrame 中的常量，如果沒有加 JFrame，編譯器會找不到。
感謝：annhy
日期：2002/12/10

■p587,L-11（補充）
<font
color="#408080">原文：你可以看到，所有數據都是 private。
討論：p586,L6~L11 的數據都是 protected，所以這兩個地方要一致才對。
</font>感謝：annhy
日期：2002/12/10

■p610,L-6
原文：該對象的<font
color="#FF0000">其他</font> synchronized 函數便無法再被調用
修改：該對象的<font
color="#0000FF">所有</font> synchronized 函數便無法再被調用
感謝：annhy
日期：2002/12/10

■p610,L-1（別字）
原文：避免 static <font
color="#000000">數據</font><font color="#FF0000">並</font>同時訪問
修改：避免 static <font
color="#000000">數據</font><font color="#0000FF">被</font>同時訪問
感謝：annhy
日期：2002/12/10

■p628,L-13（補充）
<font
color="#408080">原文：（※以下是中譯本刻意留下的未譯原文）
  In init(), notice the loop that moves through the entire array and adds
  the state and peeker.status text fields to the page.
討論：
  這段英文真的是很難理解，不過我猜（真的是用猜的...）它的意思是：

  在 init() 中，當 b 這個 array（Blockable[]）中的元素被逐一建構
  (loop? moves through?) 的時候，每個元素（Blockable）的 state 和
  peeker.status 這兩個 JTextField 數據成員也就會被加入至顯示畫面（JApplet）中。
</font>感謝：annhy
日期：2002/12/10

■p718,L9（筆誤）
原文：<font
color="#FF0000">分</font>發（Developing）EJB
修改：<font color="#0000FF">開</font>發（Developing）EJB
感謝：annhy
日期：2002/12/10

■p764, L1（筆誤）
原文：因而規<font
color="#FF0000">免</font>了實現...
修改：因而規<font color="#0000FF">避</font>了實現...
感謝：annhy
日期：2002/12/10

■p211,L1（討論）
<font
color="#408080">讀者來函：
  此處說到「不過就我所知，沒有任何方法可以令 array references 本身成為 final」
  可是我們的確可以將 array references 設成 final，而且不論 array 內是
  primitive types 或 object references。

  例如：
  public class test {
          final static int[] intArray  = new int[10];
          final static String[] strArray = new String[10];

          public static void main(String[] args) {
                  intArray = new int[20];
                  strArray = new String[20];
          }
  }
  編譯時會出現兩個錯誤：
  test.java:6: cannot assign a value to final variable intArray
                  intArray = new int[20];
                  ^
  test.java:7: cannot assign a value to final variable strArray
                  strArray = new String[20];
                  ^
  如此一來 array references 也是可以設成 final。抑或我重頭到尾誤解這句話呢？

</font>侯捷回覆：
  書上的意思是，array 內的元素都是 references，你無法令它們(s)為 final。
  至於 array 本身（其名稱也是個 reference），你當然可以令它為 final —
  你上面所寫的例子就是 !
  換句話說，final 用來修飾 array 時，修飾的是 array 本身，不是 array 元素。
感謝：sorry
日期：2002/12/10




■p247,第七章習題15最後一句（修改）
原文：接著，<font
color="#FF0000">將此函數的 abstract 飾詞移至 base class，因而免去
      向下轉型的需要。</font>
修改：接著，<font
color="#0000FF">將 abstract 飾詞加在 base class 的成員函數上，從而免去
      向下轉型的需要。</font>
感謝：PeterPeng
日期：2002/12/10

■討論
<font
color="#408080">讀者來函：
  最近發現﹐用 J2SDK 1.4.1
    （java -version 為：
    java version &quot;1.4.1-rc&quot;
    Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.1-rc-b19)
    Java HotSpot(TM) Client VM (build 1.4.1-rc-b19, mixed mode)）
  的 javac.exe 來編譯 TIJ2 代碼，會因為 Bruce Eckel 在代碼末尾加 ///:~ 但不換
  新行而得到編譯期錯誤：unclosed comment
  去 SUN 公司的主頁查詢，發現這是一個 bug（Bug ID:4316827,4710200,4733858）。
  這個 bug 真是比想象的還過份。因此幾乎所有代碼均無法編譯成功。
  當然，在其它版本的 J2SDK 中沒有問題。
</font>感謝：ark
日期：2002/12/10

■p288,第13題（修正）
原文：撰寫一個 interface <font
color="#FF0000">並</font>令它具備<font color="#FF0000">一個以上</font>的函數，並在某個函數<font
color="#FF0000">中定義
      inner class 以實現出該 interface。inner class 必須傳回一個 reference，
      指向那個 interface。</font>
修改：撰寫一個 interface，令它具備<font
color="#0000FF">至少一個</font>函數，並在<font color="#000000">另外</font>某個函數<font
color="#0000FF">內定義一個
      inner class 用以實現該 interface。這個函數必須傳回一個
      reference 指向你的那個 interface。</font>
感謝：ark
日期：2002/12/10

■p259（討論）
<font
color="#408080">讀者來函：
  本頁上半部代碼 NestingIterfaces.java 中的 main() 內有一行
    a.getD().f();
  被註釋掉了，因書上提到 cannot access a member of the interface。
  並說正確的取用方法應該是：
    A a2 = new A();
    a2.receiveD(a.getD());
  但我覺得 a.getD().f(); 這行代碼放在這個地方應該是可以正常執行，
  因為調用的並不是 a member of the interface，而是 class DImp2 中的 f()，
  返回的是一個 D 的 reference，但具體應該是指向了一個 DImp2 object，
  所以應該是一個向上轉型的多態調用。
  因為這個懷疑我把源代碼鍵入調試了一下﹐發現
    a.getD().f();
  這個語句可以通過編譯，我在 class DImp2 的 f() 中加入了
    System.out.print(&quot;into DImp2.f()&quot;);
  的調試語句後也發現，這個語句的確正常進行了多態調用（調用 DImp2 methods），
  其執行結果和
    a2.receiveD(a.getD());
  一樣! 這和書上的解說有點出入。
</font>感謝：ovo-lucky
日期：2002/12/10</pre>

<pre>■p259（續上討論）
<font color="#408080">讀者來函：</font>
<font
color="#408080">  真奇怪，我測試的結果和書上的解說的相同，並不會有上述所說狀況。
  我把註解移除，直接編譯此指令:
    a.getD().f();
  
  JBuilder 6 會給我下面這樣的錯誤訊息:
    &quot;NestingInterfaces.java&quot;: Error #: 311 : interface A.D is not public, 
    therefore method f() cannot be accessed from outside package at line 80, column 10
  
  直接用命令列的 javac 也是不通過，只是訊息有些差異:
    NestingInterfaces.java:80: f() in A.D is not defined in a public class or interface; 
    cannot be accessed from outside package
  
  它們說的都是同一件事情，A.D 是個 private interface，因此在 NestingInterfaces class 中
  不可以對 A.D 作任何呼叫函式的動作。我有點懷疑 ovo-lucky 會不會沒把 A.D 設為 private。
  
  其實如果經過向下轉型為 A.DImp2 (public class) 再呼叫它的函式，就可以通過編譯，只是這樣
  就不算是多型了。下列兩個指令可這樣修改:
    // Doesn't return anything but A.D:
    //! A.DImp2 di2 = a.getD();
    A.DImp2 di2 = (A.DImp2)a.getD();  // 向下轉型方可通過編譯
    // Cannot access a member of the interface:
    //! a.getD().f();
    ((A.DImp2)a.getD()).f();          // 向下轉型方可通過編譯
</font>感謝：annhy
日期：2003/01/06

■p413, L-2,L-1（遺漏一個括號）
原文：（也就是說﹐…譯注：functor一詞在 C++ STL 的意義與此處明顯不同或 Command 模式。
更正：（也就是說﹐…譯注：functor一詞在C++STL 的意義與此處明顯不同<strong><font
color="#0000FF">）</font></strong>或 Command 模式。
感謝：ark
日期：2002/12/10

■讀者詢問
<font
color="#408080">讀者來函：
  1. classpath 問題。安裝 jdk1.4 後，dos 提示符下鍵入執行 java 命令，
  執行 java文檔會出現
  Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: Hellodate/java
  按照您書中所提的 classpath 環境在 jdk1.3 中可以使用﹐當安裝 jdk1.4 以後
  就行不通了，具體應該怎樣設定？設定中各項具體含義是什麼？還望您賜教﹗
  機器為 windows98se系統（如果不同的windows系統，設定是否不同？）
  jdk 安裝路徑為 c:\jdk14,
  java 文檔路徑為 e:\java,
  jdk版本如下﹕
  java version &quot;1.4.0_02&quot;
  Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.0_02-b02)
  Java HotSpot(TM) Client VM (build 1.4.0_02-b02, mixed mode)

  2﹕讀完《Thinking in java》以後還可以讀一讀哪幾本書呢？敬請您推薦幾本﹗

  3﹕《Thinking in java》一書課後的習題我正在邊學邊做，很想去 Bruce Eckel 先生
  的網站購買課後習題代碼。第一，可知道自己答案正不正確。第二，可學一學大師的編
  程風格，怎樣將代碼寫得最精簡。但是大陸的金融體系並不完善，我們的信用卡並不是
  真正意義上的信用卡，所以未能如願以償。再說對於我等大陸窮學生來說，Eckel 先生
  將價格也定得太高了，﹩20美金。呵呵，買書還只花了不到﹩10美金。您可否給我們提供
  一些相關數據呢﹖先謝謝您了﹗希望 Eckel 先生不會生氣﹗
</font>
侯捷回覆：
  1. 以相同的（如我在本書譯序之後所附加的）環境設定手法，可設定 JDK 1.4，
     沒有問題。設定具體細節，請上 BBS 發問。
  2. 一言難盡。Java 是個平台（非僅止於語言），Java 相關主題和書籍太多太多了。
  3. 我不能提供你任何違反他人智財權的東西。
感謝：longyigg
日期：2002/12/10</pre>

<pre>======================================================</pre>

<pre><font color="#0000FF">以上已於第二刷更正完畢</font>
以下暫請讀者自行更正：
（注意，Lm 表示第 m 行，L-n 表示倒數第 n 行）

■p357,L6（誤譯）
原文：...每一個都弱於<font
color="#FF0000">後</font>者。
更正：...每一個都弱於<font color="#0000FF">前</font>者。
感謝：zhaijing
日期：2003/01/06</pre>

<pre>■p211 第一個程序（製作錯誤）
原文：
<font color="#FF0000">//: class Poppet { }</font>

class BlankFinal {
  ...
更正：
<font
color="#0000FF">//: c06:BlankFinal.java
// &quot;Blank&quot; final data members.

class Poppet { }</font>

class BlankFinal {
  ...
感謝：softxlf
日期：2003/01/17</pre>

<pre>■p245,L-6（筆誤）
原文：a &quot;big picture&quot; of class relationsh<font
color="#FF0000">o</font>p
更正：a &quot;big picture&quot; of class relationsh<font
color="#0000FF">i</font>p
感謝：PennyGe
日期：2003/02/18

■p211,L21（版面處理不當）
原文：BlankFinal(int x) { 
更正：<font
color="#408080">該行應該縮排</font>
感謝：wawa
日期：2003/02/18

■p184,L-13（少一個右括弧）
原文：你將仍舊擁有對所有friendly成員的一般性 &quot;package 存取權限&quot;。
更正：你將仍舊擁有對所有friendly成員的一般性 &quot;package 存取權限&quot;<font
color="#0000FF">）</font>。
感謝：wawa
日期：2003/02/18

■p189,L6（誤譯）
原文：class Soup <font
color="#FF0000">的對象是被 Soup 的 static private 成員函數產生出來的，</font>所以恰恰只能有一份。
更正：class Soup <font
color="#0000FF">對象被產生出來當作 Soup 的 static private 數據成員，</font>所以恰恰只能有一份。
感謝：wawa
日期：2003/02/18

■p128,L-2; p129,L1（筆誤）
原文：labeld
更正：label<font
color="#0000FF">e</font>d
感謝：wawa
日期：2003/02/18</pre>

<pre>■p124,L-3（譯本處理錯誤）
原文：每當 i 不能被 <font color="#FF0000">10</font> 整除，
更正：每當 i 不能被 <font
color="#0000FF">9</font> 整除，
感謝：wawa
日期：2003/02/18

■p62,L-11（少一個右引號）
原文：&quot;將程序庫轉換為新的 data types（classes）便是 Java 達成此一目標的手段。
更正：&quot;將程序庫轉換為新的 data types（classes）<font
color="#0000FF">&quot; </font>便是 Java 達成此一目標的手段。
感謝：wawa
日期：2003/02/18

■p328,L14（譯本處理錯誤）
原文：當你第一次調用 Iterator 的 ne<font
color="#FF0000">s</font>t() 時
更正：當你第一次調用 Iterator 的 ne<font
color="#0000FF">x</font>t() 時
感謝：donghuihz
日期：2003/02/18</pre>

<pre>■p217,L17（筆誤）
原文：至<font color="#FF0000">止</font>，所有必要的 classes 都已被裝載，...
更正：至<font
color="#0000FF">此</font>，所有必要的 classes 都已被裝載，...
感謝：learn
日期：2003/03/27</pre>

<pre>■p499,表格第三橫項內容（誤譯）
原文：調用 Destroy() 之<font
color="#FF0000">後</font>也會調用這個函式
更正：調用 Destroy() 之<font
color="#0000FF">前</font>也會調用這個函式
感謝：jack0zhu
日期：2003/03/27

■p673,L-8（英文版筆誤，多了一個右圓括弧）
原文：&quot;ORDER BY FIRST&quot;<font
color="#FF0000">)</font>;
更正：&quot;ORDER BY FIRST&quot;;
感謝：wangrui_xjtu
日期：2003/03/27</pre>

<pre>■p107,L8;p138,L-5（全書一致性）
原文：<font color="#FF0000">多</font>載
更正：<font
color="#0000FF">重</font>載
感謝：aparnet
日期：2005/01/28</pre>

<pre>■p308,L-8（筆誤）
原文：pri<font color="#FF0000">v</font>itives array 和 objects array
更正：pri<font
color="#0000FF">m</font>itive arrays 和 object arrays
感謝：paranonia
日期：2005/01/28</pre>

<p>　</p>
</body>
</html>
