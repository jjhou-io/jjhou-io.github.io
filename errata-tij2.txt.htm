<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=big5">
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
<title>勘誤《Thinking in Java 2/e》中文版 繁體</title>
</head>

<body>

<pre>本勘誤表 更新日期: 2005/01/28</pre>

<pre>《Thinking in Java 2/e》中文版 繁體
碁峰資訊股份有限公司 出版, 2002/08</pre>

<pre>原著：Thinking in Java 2e, 
      by Eckel Bruce
      Prentice Hall, 2000          

請注意：以下各項修正皆以日期排序</pre>

<pre><font color="#0000FF">★ ★ ★
</font><font color="#000000"><a name="PDF-bug">請注意</a>：本書製作乃以 Word 透過 PDF Distiller 轉為 PDF 後由印刷廠直接製版輸出。
不想 </font><font
color="#0000FF">PDF Distiller 竟有瑕疵：某些左大括弧（ { ）會在轉換過程中遺失</font><font
color="#000000">。
因而造成本書多處程式碼遺漏左大括弧。對此甚感抱歉和遺憾。
我已將熱心讀者所指出之遺漏張貼於後。
在 Adobe 改善此 bug 之前，我將不再採用 Distiller PDF 進行書籍後製作。
幸好，略有 programming 經驗之讀者，比對程式碼縮排格式，大致便可發現
遺失之左大括弧（ { ）。</font></pre>

<pre>2002/12/10 :
我已歸納出 PDF Distiller 遺失左大括弧之情況：
  當左大括弧之後無任何文字，而只有一個空白字元（然後是換行字元）時，
  PDF Distiller 便會遺漏該左大括弧。<a
href="#brace-missing" target="main">據此，我找出所有遺漏的左大括弧，列於此</a>。<font
color="#0000FF">
★ ★ ★</font></pre>

<pre>======================================================</pre>

<pre>書籍內容更正，有兩種作法，一是在網際網路上做個專屬勘誤
網頁，讓大家上去看。這是比較即時的作法。而更理想更負責
的作法是：不但有勘誤網頁，並且在新刷中予以更正 -- 如果
有新刷的話。</pre>

<pre>不過，理想與現實之間需要一點協調。書籍的製作是這樣的，
製版與印刷時，是以檯（8 或 16 頁）為單位。因此，每換一
頁，同檯的各頁統統要換過。這便造成印製成本的大量增加。</pre>

<pre>以前，我從不考慮成本，只要我認為書籍內容有修改必要，即
使只是某個字詞用得不甚理想，我都會請出版社更新。出版社
也都全力配合（這一點讓我非常感謝）。</pre>

<pre>慢慢地，我的行事不再這麼霹靂，我覺得我多少也要站在出版
社的立場想想。所以我打算，如果是關係到對錯正誤的根本性
問題，我便一定在新刷修正。如果是易判別的錯別字或排版誤
失或用詞不很恰當…等等，我便先在勘誤網頁上明載，但不求
立刻於新刷中更正。直到收集來的這類誤失較為密集了，才一
併於下一刷修正。</pre>

<pre>哪些是新刷已修正的，哪些是暫請讀者自行動手更改的，我會
在勘誤網頁（網址見書封底）上很清楚地說明。</pre>

<pre>這是個便宜法門，請讀者見諒。</pre>

<pre>書籍應該在出版前就詳細檢查，以完美之姿出現。但是完美很
難達到。對於下列大大小小輕重不等的誤失，我謹向讀者說抱
歉。</pre>

<pre>本檔歡迎廣為流傳，謝謝。
</pre>

<pre>以下為更新記錄。如果您購買的是第 n 刷，請將以下第 n+1
刷之後的更新內容自行修正至書上。謝謝</pre>

<pre>======================================================</pre>

<pre>以下暫請讀者自行更正：
（注意，<font color="#FF0000">Lm</font> 表示第 m 行，<font
color="#FF0000">L-n</font> 表示倒數第 n 行）</pre>

<pre>
■p215, L2（DOC 轉 PDF 遺漏左大括弧）
原文：Book(boolean checkOut)
修改：Book(boolean checkOut) <strong><font
color="#0000FF">{</font></strong>
感謝：truename
日期：2002/08/03

■p369, L2（DOC 轉 PDF 遺漏左大括弧）
原文：private class PContents implements Contents
修改：private class PContents implements Contents <strong><font
color="#0000FF">{</font></strong>
感謝：contagiouskimo
日期：2002/08/06

■p392, L7（DOC 轉 PDF 遺漏左大括弧）
原文：public void increment()
修改：public void increment() <strong><font
color="#0000FF">{</font></strong>
感謝：contagiouskimo
日期：2002/08/06

■p235,L-3（DOC 轉 PDF 遺漏左大括弧）
原文：f(new object[]
修改：f(new object[] <strong><font
color="#0000FF">{</font></strong>
感謝：ikai
日期：2002/08/06

■p239,L-14（中文版筆誤）
原文：stroustru
修改：stroustru<font
color="#0000FF">p</font>
感謝：ikai
日期：2002/08/06

■p244,L-10（中文版筆誤）
原文：不過，這麼一來就法直接使用 java.util 內的其他 class
修改：不過，這麼一來就<font
color="#0000FF">無</font>法直接使用 java.util
      內的其他 class
感謝：ikai
日期：2002/08/06

■p374,L-14（DOC 轉 PDF 遺漏左大括弧）
原文：return new Wrapping(x)
修改：return new Wrapping(x) <strong><font
color="#0000FF">{</font></strong>
感謝：ikai
日期：2002/08/06

■p363,L19（DOC 轉 PDF 遺漏左大括弧）
原文：public void receiveD(D d)
修改：public void receiveD(D d) <strong><font
color="#0000FF">{</font></strong>
感謝：annec
日期：2002/08/07

■扉頁前兩頁，「關於 Thinking in C++」L3（筆誤）
原文：Jolt Awar<font
color="#FF0000">e</font>d 得主
修改：Jolt Award 得主
感謝：jjhou
日期：2002/08/12

■p410,L5（DOC 轉 PDF 遺漏左大括弧）
原文：Weeble[] d =
修改：Weeble[] d = <strong><font
color="#0000FF">{</font></strong>
感謝：contagiouskimo
日期：2002/08/12

■p416,L3（DOC 轉 PDF 遺漏左大括弧）
原文：public interface Generator
修改：public interface Generator <strong><font
color="#0000FF">{</font></strong>
感謝：contagiouskimo
日期：2002/08/12

■p460,L5（中文版筆誤）
原文：collectio<font
color="#FF0000">p</font>ns
修改：collections
感謝：contagiouskimo
日期：2002/08/12

■p461,L12（誤譯）
原文：並<font
color="#FF0000">隱藏 x 的確切</font>型別資訊
修改：並<font color="#0000FF">讓 x 帶有明確的</font>型別資訊
感謝：contagiouskimo
日期：2002/08/12

■p574,L-10（英文版筆誤）
原文：我使用 java.util<strong><font
color="#FF0000">s</font></strong>.Array.sort()
修改：我使用 java.util.Array<strong><font
color="#0000FF">s</font></strong>.sort()
感謝：ikai
日期：2002/08/12

■p611,L14（中文版筆誤）
原文：在 Internet 上 JAR 檔案<font
color="#FF0000">特</font>外有用
修改：在 Internet 上 JAR 檔案<font
color="#0000FF">格</font>外有用
感謝：ikai
日期：2002/08/12

■p585,L5（中文版筆誤）
原文：Decorator <font
color="#FF0000">模</font>式
修改：Decorator <font color="#0000FF">樣</font>式
感謝：jjhou
日期：2002/08/18

■p614,L19（中文版筆誤）
原文：這<font
color="#FF0000">件</font>話的言外之意
修改：這<font color="#0000FF">句</font>話的言外之意
感謝：jjhou
日期：2002/08/18</pre>

<pre>■p1,L2（誤譯，重潤）
原文：<font color="#FF0000">我想起我的兄弟 Todd，他正從硬體領域大躍進到程式設計領域。
      基因工程將是下一個大革命的戰場。</font>
      我們將擁有許多被設計用來製造食物、燃料、塑膠的各類微生物；
      這些微生物的出現，可以免去污染，讓我們僅付出遠少於現今所付的代價，
      便足以主宰整個物質世界。<font
color="#FF0000">我原以為，</font>這場革命規模之大，將使電腦革命相形見絀。
修改：<font
color="#0000FF">我的兄弟 Todd 正從硬體領域跨足程式設計領域。我告訴他
      下一場大革命將是基因工程</font>。
      我們將擁有許多被設計用來製造食物、燃料、塑膠的各類微生物；
      這些微生物的出現，可以免去污染，讓我們僅付出遠少於現今所付的代價，
      便足以主宰整個物質世界。<font
color="#0000FF">我認為</font>這場革命規模之大，將使電腦革命相形見絀。
感謝：jason,ctwu,jcwang,mike
日期：2002/08/26</pre>

<pre>■p3,L9（誤譯）
原文：意思是，寫完<font color="#FF0000">之後的數個月內</font>，你<font
color="#FF0000">都還是</font>無法閱讀它
修改：意思是，寫完<font
color="#0000FF">數個月之後</font>，你<font color="#0000FF">便</font>無法閱讀它
感謝：annhy
日期：2002/08/26

■p6,L-4（錯別字）
原文：過去的<font
color="#FF0000">沉</font>舊內容
修改：過去的<font color="#0000FF">陳</font>舊內容
感謝：annhy
日期：2002/08/26</pre>

<pre>■p172,L-9（原書有誤）
討論：
  p172 的 return 用法範例中 ( //: c03:IfElse2.java )
  1) 變數 result 在採用 return 新法後應該不需要了
  2) 譯文
          &quot;現在我們不需要 else 了&quot;
     是否改為
          &quot;現在我們不需要 result 這個變數了&quot;
侯捷回覆：爾言有理。我想應該修改。
原文（L-9）：現在我們<font
color="#FF0000">不需要 else 了，因為 test() 在執行 return 之後不再繼續執行</font>。
修改：現在我們<font
color="#0000FF">不需要變數 result 了</font>。
感謝：rock
日期：2002/08/26

■p256,L-5（DOC 轉 PDF 遺漏左大括弧）
原文：public Cookie()
修改：public Cookie() <strong><font
color="#0000FF">{</font></strong>
感謝：ljy_china
日期：2002/08/26</pre>

<pre>■p287,L19（討論）
討論：Hide.java 第19行 class Hide 是否應為 public class Hide 才較為正確!
侯捷回覆：雖然一般如此，但本例並沒錯
感謝：Jeff
日期：2002/08/26</pre>

<pre>■p392,L24（DOC 轉 PDF 遺漏左大括弧）
原文：private void incr()
修改：private void incr() <strong><font
color="#0000FF">{</font></strong>
感謝：Jeff
日期：2002/08/31</pre>

<pre>■p970,L17（中文版錯別字）
原文：<font color="#FF0000">要</font>了觀察
修改：<font
color="#0000FF">為</font>了觀察
感謝：hjh
日期：2002/09/09

■p948,L14（中文版錯別字）
原文：<font
color="#FF0000">也</font>時候也會提供
修改：<font color="#0000FF">有</font>時候也會提供
感謝：hjh
日期：2002/09/09

■p836,L14（中文版錯別字）
原文：所以你得回到先前<font
color="#FF0000">,</font>作法
修改：所以你得回到先前作法
感謝：hjh
日期：2002/09/09

■p5,L4（中文版錯別字）
原文：同樣的，「設計樣式（Design Patters）」
修改：同樣的，「設計樣式（Design Patter<font
color="#0000FF">n</font>s）」
感謝：gigix
日期：2002/09/16

■p125,L10, p170,L6, p175,L2, p193,L1, p207,L4, p909,L-6（錯別字）
原文：其<font
color="#FF0000">它</font>
修改：其<font color="#0000FF">他</font>
感謝：jjhou
日期：2002/09/19

■p144,L13（中文版處理錯誤）
原文：緊接於其後的算式則使用<font
color="#FF0000">邏輯運算子（Logical operators）</font>來...
修改：緊接於其後的算式則使用<font
color="#0000FF">關係比較（relational comparisons）</font>來...
感謝：施正桓
日期：2002/09/19

■p157,L-9（筆誤）
原文：FORTAN 是個全面使用大寫字母的語言...
修改：FORT<font
color="#0000FF">R</font>AN 是個全面使用大寫字母的語言...
感謝：dbai
日期：2002/09/19

■p259,L8（DOC 轉 PDF 遺漏左大括弧）
原文：static Sundae makeASundae()
修改：static Sundae makeASundae() <strong><font
color="#0000FF">{</font></strong>
感謝：shiun
日期：2002/09/20

■p305,L-1（處理錯誤）
原文：將其「物件生成<font
color="#FF0000">空間</font>」註解掉
修改：將其「物件生成<font
color="#0000FF">動作</font>」註解掉
感謝：annhy
日期：2002/09/20

■p124,L-10（錯別字）
原文：請<font
color="#FF0000">註</font>意
修改：請<font color="#0000FF">注</font>意
感謝：annhy
日期：2002/09/20

■p275,L7~L9（譯筆不佳，原書文字亦不佳。現按技術意義重譯）
原文：
<font
color="#FF0000">注意，Bath 建構式中，有一行述句在任何初始化動作之前執行。如果你未
在定義處進行初始化，那麼就無法保證在你發送訊息給 object references
之前能夠進行任何初始化 — 反倒是無可避免會發生執行期異常。</font>
修改：
<font
color="#0000FF">注意 Bath 建構式中有一行述句在所有初始化動作之前執行。如果你未曾
在資料成員定義處初始化 object references，便無法保證它們在接受訊息
之前已完成初始化 — 果真如此便會發生執行期異常。</font>
感謝：annhy
日期：2002/09/20

■p286,L-2（原譯不佳。重譯）
原文：
那麼在 derived class 中重新定義此一函式，並不會遮蔽它在 base class 中
的任何版本。因此，<font
color="#FF0000">不論該層 class 或 base class 是否定義了這個函式，
都會發揮重載作用</font>
修改：
那麼在 derived class 中重新定義<font
color="#0000FF">（使用）</font>此一函式名稱，並不會遮蔽它在 base class 中
的任何版本。因此，<font
color="#0000FF">函式不論被定義於某層 class 或其 base class，重載機制都可正常運作</font>
感謝：annhy
日期：2002/09/20

■p272,L-4（討論）
原文：
每個非基本型別的物件都具備 toString()，當編譯器希望得到一個
String，而你手上卻只有那些物件的情況下，這個函式便會被喚起。
討論 by annhy：
<font
color="#408080">到底在哪種情況下這個函式會自動被喚起？想來想去好像還是只有 &quot;字串加法&quot; 啊!!
我寫了一個小程式來測試：
public class A {
  public String toString() {
    return &quot;A&quot;;
  }
  static void pStr(String str) {
    System.out.println(&quot;pStr: &quot; + str);
  }
  static void pObj(Object obj) {
    System.out.println(&quot;pObj: &quot; + obj);
  }
  public static void main(String[] args) {
    A a = new A();
    pObj(a);              // pObj() 內有字串加法
    //! pStr(a);          // pStr() 需要 String，但也不會自動呼叫 toString()
    //! pStr((String)a);  // 將 A 轉型為 String 是不合法的
    pStr(a.toString());   // 自行呼叫 toString()，可以
    pStr(a + &quot;&quot;);         // 經過 &quot;字串加法&quot; 也可以
    //! pStr(a + 1);      // 經過 &quot;數值加法&quot; 就不行
  }
}
另外在 JSP 中的寫法 &lt;%=objectReference%&gt; 也可以自動呼叫 toString()。
不過這大概是個可以接受 Object 型別的函式，而內部會呼叫 toString() 吧。
測試範例如下：
&lt;%@ page contentType=&quot;text/html; charset=Big5&quot; %&gt;
&lt;html&gt;
  &lt;body&gt;
    目前時間: &lt;%=new java.util.Date()%&gt;
  &lt;/body&gt;
&lt;/html&gt;
除了「字串加法」和「JSP」外，我實在想不出還有哪些情況會自動呼叫 toString()
</font>
感謝：annhy
日期：2002/09/20

■p318,L2,..（DOC 轉 PDF 遺漏左大括弧）
修改：
// Polymorphism in Java.

class Shape<strong><font
color="#0000FF"> {</font></strong>
  void draw() {}
  void erase() {}
}

class Circle extends Shape {
  void draw() <strong><font
color="#0000FF">{</font></strong>
    System.out.println(&quot;Circle.draw()&quot;);
  }
  void erase() <strong><font
color="#0000FF">{</font></strong>
    System.out.println(&quot;Circle.erase()&quot;);
  }
}

class Square extends Shape {
  void draw() <strong><font
color="#0000FF">{</font></strong>
    System.out.println(&quot;Square.draw()&quot;);
  }
  void erase() <strong><font
color="#0000FF">{</font></strong>
    System.out.println(&quot;Square.erase()&quot;);
  }
}

class Triangle extends Shape {
  void draw() <strong><font
color="#0000FF">{</font></strong>
    System.out.println(&quot;Triangle.draw()&quot;);
  }
  void erase() <strong><font
color="#0000FF">{</font></strong>
    System.out.println(&quot;Triangle.erase()&quot;);
  }
}

感謝：jjhou
日期：2002/09/20

■p371,L2~L4（原譯不佳。重譯）
原文：
3. 一個匿名（anonymous）class，用以實作某個interface。
4. 一個匿名class，<font
color="#FF0000">用來擴充一個擁有non-default建構式的class</font>。
5. 一個匿名class，<font
color="#FF0000">用來執行資料成員初始化動作</font>。
修改：
3. 一個匿名（anonymous）class，實作出某個 interface。
4. 一個匿名 class，<font
color="#0000FF">擴充某個「擁有 non-default 建構式」之 class</font>。
5. 一個匿名 class，<font
color="#0000FF">執行資料成員初始化動作</font>。
感謝：jjhou
日期：2002/09/21

■p589,L-9（修潤）
原文：Writer 則提供了相容於 Unicode 並以字元為<font
color="#FF0000">主</font>（charater-based）的 I/O。
修改：Writer 則提供了相容於 Unicode 並以字元為<font
color="#0000FF">基準</font>（character-based）的 I/O。
感謝：jjhou
日期：2002/09/21

■p599,L1（贅字）
原文：4.輸出至檔案<font
color="#FF0000">的</font>
修改：4.輸出至檔案
感謝：jjhou
日期：2002/09/21

■p135,L1（誤植）
原文：這意謂，如果對<font
color="#FF0000">是將</font>寫下 C = D 這樣的式子，...
修改：這意謂，如果對<font
color="#0000FF">兩個物件</font>寫下 C = D 這樣的式子，...
感謝：jjhou
日期：2002/09/24

■p967,L21（DOC 轉 PDF 遺漏左大括弧）
原文：&lt;% } else
修改：&lt;% } else <strong><font
color="#0000FF">{</font></strong>
感謝：陳俊忠
日期：2002/09/25</pre>

<pre>■p138,L13~15，範例 c03:MathOps.java（討論）
討論 by annhy：
<font
color="#408080">    // '%' limits maximum value to 99:
    j = rand.nextInt() % 100;
    k = rand.nextInt() % 100;
  j, k 的值其實是 [-99, 99] 之間的整數(包括 0)
  因此在執行這個範例程式時，會有約 1/50 的機率（好像不低耶）
  發生錯誤（java.lang.ArithmeticException: / by zero）

  這是因為 L19, L21, L22 會有除以零的情形
    i = k / j; pInt(&quot;k / j&quot;, i);
    i = k % j; pInt(&quot;k % j&quot;, i);
    j %= k;    pInt(&quot;j %= k&quot;, j);

以下是我的想法：
1. 由於在這個範例以及之前的內容中，均沒有提到 java.lang.ArithmeticException，
   所以這個 Exception 應該不是作者故意留在程式中讓讀者體會的。比較好的做法是在
   書中內容增加一些篇幅，解釋這一部分數學運算的問題。

2. 或者也可以用權宜的方式，將 L13~15 改成
     // limits the integer values between [1, 100]:
     j = rand.nextInt(100) + 1;
     k = rand.nextInt(100) + 1;
   則 j, k 的值為 [1, 100] 之間的整數，便不會有除以零的問題。
   只不過這樣會只剩下 [正整數] 的數學運算，可能會偏離作者設計此範例的原義。

3. 至於後來 L-15, L-16 出現的隨機浮點數
     v = rand.nextFloat();
     w = rand.nextFloat();
   由於 v, w 為 0.0f 的機率就只有 2^-24 這麼少，實在不容易碰上。
   而且就算碰上了，除以 0.0f 也不會發生 ArithmeticException，只會是 NaN 罷了，
   所以這應該是無傷大雅的。

4. 真是奇怪，1/50 的機率應該不算低，怎麼都沒有人提出這個問題？難道大家都不
   執行範例程式來看看嗎？
   我猜大部分的人會以為自己 keyin 錯程式碼或下錯指令，結果第二次執行就正常了。
   由於要連續兩次都出現錯誤的機率提高到了 1/2500，這個機率就算低了。</font></pre>

<pre>感謝：annhy
日期：2002/09/25</pre>

<pre>■p157,註釋 L2（誤植）
原文：1<font color="#FF0000">7</font>60 ~ 1970 年代
修改：1<font
color="#0000FF">9</font>60 ~ 1970 年代
感謝：devilotte
日期：2002/10/03</pre>

<pre>■p411,L14（英文版誤植）
修改：<font color="#000000">a.length = 2</font>  此行應移至程式輸出第一行。修改後之結果為：
<font
color="#0000FF">      a.length = 2
</font>      b.length = 5
      b[0]=null
      b[1]=null
      b[2]=null
      b[3]=null
      b[4]=null
      c.length = 4
      d.length = 3
      a.length = 3
      f.length = 5
      ...
感謝：KevinLin, songwae
日期：2002/10/03

■p415,L18（誤植）
原文：pac<strong><font
color="#FF0000">c</font></strong>kage
修改：package
感謝：songwae
日期：2002/10/03</pre>

<pre>■p1068,L2（誤植）
原文：第一個 #include 指令會<font color="#FF0000">括</font>入 j<font
color="#FF0000">in</font>.h，
修改：第一個 #include 指令會<font color="#0000FF">含</font>入 j<font
color="#0000FF">ni</font>.h，
感謝：Starr
日期：2002/10/03

■p1096,L6（誤植）
原文：自行印製,19<font
color="#FF0000">9</font>8）
修改：自行印製,19<font color="#0000FF">8</font>8）
感謝：Starr
日期：2002/10/03</pre>

<pre>■p432,L8（英文版錯誤）
原文：引數<font color="#FF0000">小於</font>自己時回傳負值，二者相等時回傳零值，引數<font
color="#FF0000">大於</font>自己時回傳正值。
修改：引數<font color="#0000FF">大於</font>自己時回傳負值，二者相等時回傳零值，引數<font
color="#0000FF">小於</font>自己時回傳正值。
感謝：zhycq
日期：2002/10/03

■p612,L-8（英文版錯誤）
讀者來函：經測試後發現，destination 與 manifest 的順序與 options 中的 f, m
的順序相依。因此書中 p612,L-8的例子不符合條件。
原文：jar c<font
color="#FF0000">mf</font> myJarFile.jar myManifestFile.mf *.class
修改：jar c<font
color="#0000FF">fm</font> myJarFile.jar myManifestFile.mf *.class
感謝：Walter Suen
日期：2002/10/03
</pre>

<pre>■<a name="brace-missing">遺失左大括弧</a>
前面有多位讀者反映，書中多處遺漏左大括弧。這是 <a
href="#PDF-bug" target="main">PDF Distiller 4.0 的 bug</a>。
我已歸納出 PDF Distiller 遺失左大括弧之情況（見本頁最上）。
以下列出據此找出的所有遺漏的左大括弧（而且未於本頁先前找出者）。
p197,L-4; p200,L15; p261,L13; p329,L1; p331,L22; p338,L9; p340,L12,L17;
p353,L1; p367,L20; P369,L17; p424,L10,L16; p425,L7,L18; p432,L-17,L-13;
p445,L14,L-3; p471,L-3; p472,L-10,L-7; p480,L13,L15; p494,L11; p498,L-3;
p502,L-6; p503,L2,L10,L19,L28; p506,L-17,L-8,L-1; p508,L-5; p509,L5,L12;
p521,L-5; p631,L5; p635,L1,L4,L14,L17,L24,L29,L36,L39; p736,L-11; p782,L-15;
p785,L-1; p786,L3,L16; p788,L11; p803,L14,L18; p840,L-5; p855,L20,L27;
p861,L23; p869,L12; p870,L1; p875,L-6; p892,L14; p895,L20; p911,L11,L-3;
p918,L22,L-1; p920,L-10; p921,L5; p957,L8; p1000,L10; p1019,L15;
p1028,L8; p1039,L-4; p1043,L16; p1048,L16,L19; p1050,L-8;
日期：2002/12/10



■p703,L6（討論）
讀者來函：
<font
color="#408080">p703,L6 註解
  // The improved solution in JDK 1.3:
  //  frame.setDefaultCloseOperation( EXIT_ON_CLOSE );
其中的 EXIT_ON_CLOSE 常數其實是 JDK1.4 才加入，
在 JDK1.3 中只有 DO_NOTHING_ON_CLOSE、HIDE_ON_CLOSE、DISPOSE_ON_CLOSE 三個常數
此外，應寫成 WindowConstants.DISPOSE_ON_CLOSE。
（雖然 JFrame 有實作 interface WindowConstants
但我用 jdk 1.3.1_4 得寫 WindowConstants.DISPOSE_ON_CLOSE 才跑得出來）
</font>感謝：Canby
日期：2002/12/10

■p613,L5（討論）
讀者來函：
<font
color="#408080">原書英文版如下：
  If you create a JAR file using the 0 option, that file can be placed in your CLASSPATH:
  CLASSPATH=&quot;lib1.jar;lib2.jar;&quot;
  Then Java can search lib1.jar and lib2.jar for class files.
依此說明，意義應為：
  『jar 檔必須不是壓縮格式才可以放在 classpath 使用』
但我查詢 J2SDK 說明文件則有如下文句(...\JDK 1.4 Docs\tooldocs\win32\jar.html)
    A jar archive can be use as a class path entry, whether it is compressed or not.
依此文之說明，classpath 的 jar 檔不論壓縮與否都可以使用，作者如此說明
是否緣於版本的差異所致，我無法查證。但我測試結果壓縮格式確實能使用。
可否賜教以解疑惑，謝謝您！
</font>
侯捷回覆：
原文並沒有「只限於非壓縮格式」的意思。
不過，中文版卻做了過度說明，易起誤會。修改如下。

原文：
如果你以選項 O 建立 JAR 檔，該檔<font
color="#FF0000">便</font>可被置於你的 CLASSPATH 之下：
  CLASSPATH=&quot;lib1.jar;lib2.jar;&quot;
<font
color="#FF0000">如此一來 </font>Java <font color="#FF0000">便</font>可在 lib1.jar 和 lib2.jar 中搜尋 class 檔案。

修改：
如果你以選項 O 建立 JAR 檔，該檔可被置於你的 CLASSPATH 之下：
  CLASSPATH=&quot;lib1.jar;lib2.jar;&quot;
<font
color="#0000FF">於是</font> Java 可在 lib1.jar 和 lib2.jar 中搜尋 class 檔案。

感謝：Walter Suen
日期：2002/12/10


■p889~890（討論）
讀者來函：
<font
color="#408080">第六、七個試驗我的執行結果分別為：
java.lang.ThreadGroup[name=g1,maxpri=3]
    Thread[A,9,g1]
    Thread[B,8,g1]
    Thread[C,3,g1]
java.lang.ThreadGroup[name=g1,maxpri=3]
    Thread[A,9,g1]
    Thread[B,8,g1]
    Thread[C,2,g1]
這個程式群組為3時，新緒也為3，和書上不一樣
我想是版本的關係。我用的JDK 1.3.1_04
</font>感謝：Canby
日期：2002/12/10

■p884, L13（討論）
讀者來函：
<font
color="#408080">g.enumerate(gAll); 此函式無法精確寫入 gAll，
使得接下來的 for() 丟出 NullPointerException
（我用的 JDK 為 1.3.1_04 多語版）
</font>感謝：Canby
日期：2002/12/10

■p360,L-9（討論）
讀者來函：
<font
color="#408080">  public final static Month2[] month = {
    JAN, JAN, FEB, MAR, APR, MAY, JUN,
    JUL, AUG, SEP, OCT, NOV, DEC
  };
  本書前面曾經提到，就算 array 宣告為 final，也無法阻止 array 的內容
  被更改。因此上述 month 有可能遭到 user 破壞，例如：
    Month2.month[1] = null;
  如果改為 get method 便可更進一步成為範例註解所說的「A more robust
  enumeration system」。而且也不需要多放進一個 JAN 使索引偏移一個位置：

  private final static Month2[] month = {
    JAN, FEB, MAR, APR, MAY, JUN,
    JUL, AUG, SEP, OCT, NOV, DEC
  };
  public static Month2 getMonth(int i) {
    return month[i-1];
  }
</font>感謝：annhy
日期：2002/12/10

■p361,L6（討論）
<font
color="#408080">原文：此一 class 名為 Month2，避免和 Java 標準程式庫的 Month class 衝突。
疑問：有這個 class 嗎？我在 JDK 1.4 的 API 中找不到耶...
</font>感謝：annhy
日期：2002/12/10

■p365,L8（修潤）
原文：<font
color="#FF0000">「定義於該 interface 中的函式」</font>
修改：<font
color="#0000FF">「該 interface 中的函式的定義」</font>
感謝：annhy
日期：2002/12/10

■p368,L1（討論）
<font
color="#408080">原文：
  如果你想要在外圍 class 的 non-static 函式之外產生一個 inner class 物
  件，你就得以 OuterClassName.InnerClassName 的型式指定該物件的型別，
  一如上述 main() 的行為。
討論：
  我把 main() 中 Parcel2.Contents 前面的 Parcel2 刪掉，執行起來
  並不會有問題 (測試環境 JDK 1.4 )
</font>感謝：annhy
日期：2002/12/10

■p374,L-3（討論）
<font
color="#408080">原文：
  是的，只要將適當引數傳入 base class 建構式中，就像將 x 傳入 new Wrapping(x)
  中一樣。匿名 class 不能擁有建構式，所以通常你會呼叫 super()。
疑問：
  「通常你會呼叫 super()」？在這個範例中，匿名 class 呼叫的明明是
  super(x) 而不是 super() 啊！而且我們也沒有自行呼叫啊？於是我只好
  求助於英文版來解決我的疑惑。不過這句「where you would normally
  call super()」還真難翻譯，我雖然看得懂他在說什麼，但就是無法用中
  文很通順地表達出來...
英文：
  That is, you simply pass the appropriate argument to the base-class
  constructor, seen here as the x passed in new Wrapping(x). An
  anonymous class cannot have a constructor where you would normally
  call super().
試譯如下：
  在這裡，你只是簡單地將引數轉交給 base class 的建構式，看起來就像
  是直接將 x 傳入 new Wrapping(x) 中一樣。匿名 class 不能擁有建構式，
  因此你不能像平常那樣在建構式呼叫 super() (以擴充 base class 建構式的行為)。
</font>感謝：annhy
日期：2002/12/10

■p485,L7（討論）
<font
color="#408080">原文：本例之中程式員必須保證，沒有任何兩個 Groundhog 物件具有相同的編號。
討論：
  1. 本例的物件應為 Groundhog2
  2. 本例不就是要展現：當有兩個編號均為 3 的 Groundhog2 instance 也能正常運作嗎？
     前一個例子 (p482, c09:SpringDetector.java) 似乎才需要此限制。
</font>侯捷回覆：
  1. 請將 <font
color="#FF0000">Groundhog</font> 修改為 <font color="#0000FF">groundhogs（土撥鼠）</font>— 這裡並不代表 class 名稱。
  2. 不，本例要展現的是，先前以 new Groundhog2(3) 做出來的 A 物件，和後來再次以
     new Groundhog2(3) 做出來的 B 物件，兩者雖然位址不同（導致預設的 hashCode 不同），
     但由於我們覆寫了 Groundhog2 的 hashCode() 和 equals()，造成其 hashCode 相同
     並被視為「相等」。這麼一來我們才能夠拿 B 物件來搜尋（比對）map，
     找出 map 中與之相等的 A 物件。
感謝：annhy
日期：2002/12/10

■p492,L5（修改）
原文：現在，你已經了解 HashMap <font
color="#FF0000">函式</font>牽涉了哪些東西
修改：現在，你已經了解 HashMap <font
color="#0000FF">的運作</font>牽涉了哪些東西
感謝：annhy
日期：2002/12/10

■p513,L6（修改）
原文：min() 和 max() <font
color="#FF0000">都能處理 Collection 物件，但不能處理 List</font>。
修改：min() 和 max() <font
color="#0000FF">是針對 Collection 物件做動作，而不是針對 Lists</font>。
感謝：annhy
日期：2002/12/10

■p605,L-5（修改）
原文：這個程式會將標準輸入裝置<font
color="#FF0000">的內容附加於檔案內</font>
修改：這個程式會將標準輸入裝置<font
color="#0000FF">附著於一個檔案</font>
感謝：annhy
日期：2002/12/10

■p601（討論）
<font
color="#408080">讀者來函：
  在 p601「這是個臭蟲嗎？」這一節中，我的看法和書中所說的那位
  JavaSoft 的人員一樣，Bruce Eckel 大師似乎用了一種怪異的方式來使用 Java
  IO stream，因而導致錯誤發生。我不認為這是個 bug。

  我想用個譬喻來說明好了。多個 streams 疊合運作時，看起來就好像是一堆
  不同的水管線路接起來，裡面有自來水管線入口、加壓馬達、屋內管線、塑膠水
  管出口，中間可能再加上個水塔。每次將一個 stream 物件（上游）疊合置入
  另一個 stream 物件（下游）之中，看起來就像是把上下游兩個管線緊密接起。
  而當整個管路中沒有任何分支時，才能保證上游所有的水都可以到達下游，
  不會在中游某個部分發生漏水現象。這是 Java IO stream 最常見的用法。

  但在此例 (p601,L-5 至 p602,L2) 還有前例 (p595,L-3 至 p596,L4)
  中的 streams（從上游到下游）：

  FileInputStream ==&gt; BufferedInputStream ==&gt; DataInputStream (in)
   ==&gt; InputStreamReader ==&gt; BufferedReader (inbr)

  我們本應只使用最末端（最外層）inbr 來讀取所有資料，但作者在 in 的
  地方等於多挖了個洞來裝水龍頭。如此，有些水（data）便流不到 inbr，而是在
  in 就流出去了。作者依照下面的順序來讀取 data，認為在第四個指令會發生
  EOFException 錯誤是很怪異的。但這是因為 inbr 像是個水塔（buffer），它在
  第三個指令就已將之後所有的水載入了，in 當然就沒有水可用了。

  in.readDouble();
  inbr.readLine();
  inbr.readLine();
  in.readDouble(); //!! EOFException !!

  作者預期「每個 stream 物件在讀取資料時，只會向上游 stream 要求剛好滿足
  數量的 data」，但事實上不然，Java 文件中好像也沒有這樣規定。而
  BufferedReader 為了效率考量，在呼叫 readLine() 時多要求一些 data
  以備不時之需，看起來也是很合理的，不然它怎麼能稱為 Buffered。我們甚至可
  以自己撰寫一個 FullyBufferedReader — 在建構式時便將上游所有資料載入，
  這樣會連上面的第一個指令都發生錯誤。

  寫到這裡，就想到前一陣子的限水運動。大樓中各住戶共用一個水塔，我本來也想
  響應政府節約用水的政策，但是想到我並沒有權力要求其他住戶也要有公德心，於
  是我就只好把家中所有能裝水的水桶、浴缸通通存滿水來保護自己。只是這麼一來
  ，我的水是夠用了，但可能就有某個倒楣的傢伙沒水可用。本例也是一樣，當兩個
  下游 streams 共享同一個上游 stream，就有可能發生互搶狀況。

結論：
  看完這部分，我對使用 Java IO stream 有個感覺：「當內層 stream 物件(s)
  （上游）置入外層 stream 物件(s)（下游）之後，便應該將中間通路看成一個黑箱
  （black-box），只能對兩端（最上游 &amp; 最下游）物件進行操作，似乎應避免操作
  中間通路物件」。不知道這個觀念是否正確？若是，可以將這個觀念擴及
  其他的 Decorator pattern 嗎？
</font>
侯捷回覆：您的討論鞭辟入裡，文字表達能力也非常好。
   是否擴及其他 Decorator patterns，還待思考。先謝謝您。
感謝：annhy
日期：2002/12/10


■p601（討論）
<font
color="#408080">讀者來函：
In TIJ 2/e Rev12 and TIJ 3/e beta, the author add the following at the end
of 'A Bug?' section:

///////////////////////////////////////////////////////
[Removed from text] (This was a bug in my reasoning; I did not
understand the intention of writeUTF( ) and readUTF( ). Also, creating two
buffers for the same stream turns out to be a big mistake; the first
buffer that you read sucks up extra bytes so the second buffer gets
indeterminate output). [ Add Comment ]
///////////////////////////////////////////////////////

But since TIJ 2/e Rev12 is still under contruction (there's [ Add Comment ]
at the end of the paragraph) and TIJ 3/e is still a beta version, we can
know that the final definite decision has not been made about the section.

Thus, although it's almost the case, now we can only regard it as a
suggestion of the author.
</font>
提示：請參考上一項討論
感謝：ark
日期：2002/12/10


■p244,L-10（漏字）
原文：這麼一來就法直接
修改：這麼一來就<font
color="#0000FF">無</font>法直接
感謝：jerry
日期：2002/12/10

■p643,L4（討論）
<font
color="#408080">原文：
  nextToken() 會回傳一個語彙單元，或回傳空字串（代表字串中已無任何語彙單元）
討論：
  nextToken() 在已無任何語彙單元時並不會回傳空字串，而是會
  throw java.util.NoSuchElementException。這也是為什麼作者在 p644,L-9
  要另外宣告一個 next() 函式來包裝 nextToken() 的原因。
</font>感謝：annhy
日期：2002/12/10

■p655,L-9（討論）
<font
color="#408080">原文：
  當你將某個物件傳入某個「預期收到 String」的函式時，便會自動呼叫
  該物件的 toString()，這是 Java 提供的有限度自動型別轉換功能。
討論：
  這個問題與之前 p272,L-4 提出的討論相同，傳入某個「預期收到 String」
  的函式時「並沒有」如同作者所說的有限度「自動型別轉換」功能，似乎只有
  「字串加法」才會自動呼叫某個物件的 toString()，除此之外都必須手動呼叫。
  下面的測試程式證實了我的想法：

    public class ToStringTester {
      static void print1(String str) {
        System.out.println(&quot;print1: &quot; + str);
      }
      static void print2(Object obj) {
        System.out.println(&quot;print2: &quot; + (String)obj);
      }
      static void print3(Object obj) {
        System.out.println(&quot;print3: &quot; + obj.toString());
      }
      public static void main(String[] args) {
        java.util.Date d = new java.util.Date();
        //! print1(d);  // compile error
        //! print2(d);  // run-time error
        print3(d);
      }
    }

  print1() 便是作者所說的情形，會發生 compiler error。
  print2() 是 print1() 的手動型別轉換版，會發生 run-time error。
  只有 print3() 手動呼叫 toString() 是可以正確執行的。
</font>
感謝：annhy
日期：2002/12/10

■p671,L4（大小寫處理錯誤）
原文：<font
color="#FF0000">class</font> 的 isInstance()
修改：<strong><font color="#0000FF">Class</font></strong> 的 isInstance()
感謝：annhy
日期：2002/12/10

■p703,L7（補充）
原文： // frame.setDefaultCloseOperation(EXIT_ON_CLOSE);
修改： // frame.setDefaultCloseOperation(<font
color="#0000FF">JFrame.</font>EXIT_ON_CLOSE);
討論：EXIT_ON_CLOSE 是 JFrame 中的常數，如果沒有加 JFrame，編譯器會找不到。
感謝：annhy
日期：2002/12/10

■p814,L16（補充）
<font
color="#408080">原文：你可以看到，所有欄位都是 private。
討論：p812,L12~L17 的欄位都是 protected，所以這兩個地方要一致才對。
</font>感謝：annhy
日期：2002/12/10

■p848,L11
原文：該物件的<font
color="#FF0000">其他</font> synchronized 函式便無法再被呼叫
修改：該物件的<font
color="#0000FF">所有</font> synchronized 函式便無法再被呼叫
感謝：annhy
日期：2002/12/10

■p848,L-9（別字）
原文：避免 static 資料<font
color="#FF0000">並</font>同時存取
修改：避免 static 資料<font color="#0000FF">被</font>同時存取
感謝：annhy
日期：2002/12/10

■p865,L-6（贅字）
原文：會<font
color="#FF0000">罷</font>霸佔物件
修改：會霸佔物件
感謝：annhy
日期：2002/12/10

■p872,L19（補充）
<font
color="#408080">原文：（※以下是中譯本刻意留下的未譯原文）
  In init(), notice the loop that moves through the entire array and adds
  the state and peeker.status text fields to the page.
討論：
  這段英文真的是很難理解，不過我猜（真的是用猜的...）它的意思是：

  在 init() 中，當 b 這個 array（Blockable[]）中的元素被逐一建構
  (loop? moves through?) 的時候，每個元素（Blockable）的 state 和
  peeker.status 這兩個 JTextField 資料成員也就會被加入至顯示畫面（JApplet）中。
</font>感謝：annhy
日期：2002/12/10

■p997,L-7（筆誤）
原文：<font
color="#FF0000">分</font>發（Developing）EJB
修改：<font color="#0000FF">開</font>發（Developing）EJB
感謝：annhy
日期：2002/12/10

■p1061, L-5
原文：因而規<font
color="#FF0000">免</font>了實作...
修改：因而規<font color="#0000FF">避</font>了實作...
感謝：annhy
日期：2002/12/10

■p297,L9（討論）
<font
color="#408080">讀者來函：
  此處說到「不過就我所知，沒有任何方法可以令 array references 本身成為 final」
  可是我們的確可以將 array references 設成 final，而且不論 array 內是
  primitive types 或 object references。

  例如：
  public class test {
          final static int[] intArray  = new int[10];
          final static String[] strArray = new String[10];

          public static void main(String[] args) {
                  intArray = new int[20];
                  strArray = new String[20];
          }
  }
  編譯時會出現兩個錯誤：
  test.java:6: cannot assign a value to final variable intArray
                  intArray = new int[20];
                  ^
  test.java:7: cannot assign a value to final variable strArray
                  strArray = new String[20];
                  ^
  如此一來 array references 也是可以設成 final。抑或我重頭到尾誤解這句話呢？
</font>
侯捷回覆：
  書上的意思是，array 內的元素都是 references，你無法令它們(s)為 final。
  至於 array 本身（其名稱也是個 reference），你當然可以令它為 final —
  你上面所寫的例子就是 !
  換句話說，final 用來修飾 array 時，修飾的是 array 本身，不是 array 元素。
感謝：sorry
日期：2002/12/10


■p348,第七章習題15最後一句（修改）
原文：接著，將<font
color="#FF0000">此函式的</font> abstract 飾詞<font color="#FF0000">移至 base class，因而免去
      向下轉型的需要。</font>
修改：接著，將 abstract 飾詞<font
color="#0000FF">加在 base class 的成員函式上，從而免去
      向下轉型的需要。</font>
感謝：PeterPeng
日期：2002/12/10

■討論
<font
color="#408080">讀者來函：
  最近發現﹐用 J2SDK 1.4.1
    （java -version 為：
    java version &quot;1.4.1-rc&quot;
    Java(TM) 2 Runtime Environment, Standard Edition (build 1.4.1-rc-b19)
    Java HotSpot(TM) Client VM (build 1.4.1-rc-b19, mixed mode)）
  的 javac.exe 來編譯 TIJ2 代碼，會因為 Bruce Eckel 在代碼末尾加 ///:~ 但不換
  新行而得到編譯期錯誤：unclosed comment
  去 SUN 公司的主頁查詢，發現這是一個 bug（Bug ID:4316827,4710200,4733858）。
  這個 bug 真是比想象的還過份。因此幾乎所有代碼均無法編譯成功。
  當然，在其它版本的 J2SDK 中沒有問題。
</font>感謝：ark
日期：2002/12/10

■p404,第13題（修正）
原文：撰寫一個 interface <font
color="#FF0000">並</font>令它具備一個以上的函式，並在某個函式<font
color="#FF0000">中</font>定義
      inner class 以實作<font color="#FF0000">出</font>該 interface。<font
color="#FF0000">inner class 必須傳回一個 reference，
      指向那個 interface。</font>
修改：撰寫一個 interface，令它具備至少一個函式，並在<font
color="#000000">另外</font>某個函式<font color="#0000FF">內</font>定義一個
      inner class <font
color="#0000FF">用</font>以實作該 interface。<font color="#0000FF">這個函式必須傳回一個
      reference 指向你的那個 interface。</font>
感謝：ark
日期：2002/12/10

■p364（討論）
<font
color="#408080">讀者來函：
  本頁程式 NestingIterfaces.java 中的 main() 內有一行
    a.getD().f();
  被註釋掉了，因書上提到 cannot access a member of the interface。
  並說正確的取用方法應該是：
    A a2 = new A();
    a2.receiveD(a.getD());
  但我覺得 a.getD().f(); 放在這個地方應該是可以正常執行，
  因為呼叫的並不是 a member of the interface，而是 class DImp2 中的 f()，
  返回的是一個 D 的 reference，但具體應該是指向了一個 DImp2 object，
  所以應該是一個向上轉型的多型呼叫。
  因為這個懷疑我試了一下，發現
    a.getD().f();
  這個語句可以通過編譯，我在 class DImp2 的 f() 中加入了
    System.out.print(&quot;into DImp2.f()&quot;);
  後也發現，這個語句的確正常進行了多型呼叫（呼叫 DImp2 methods），
  其執行結果和
    a2.receiveD(a.getD());
  一樣! 這和書上的解說有點出入。
</font>感謝：ovo-lucky
日期：2002/12/10</pre>

<pre>■p364（續上討論）
<font color="#408080">讀者來函：</font>
<font
color="#408080">  真奇怪，我測試的結果和書上的解說的相同，並不會有上述所說狀況。
  我把註解移除，直接編譯此指令:
    a.getD().f();
  
  JBuilder 6 會給我下面這樣的錯誤訊息:
    &quot;NestingInterfaces.java&quot;: Error #: 311 : interface A.D is not public, 
    therefore method f() cannot be accessed from outside package at line 80, column 10
  
  直接用命令列的 javac 也是不通過，只是訊息有些差異:
    NestingInterfaces.java:80: f() in A.D is not defined in a public class or interface; 
    cannot be accessed from outside package
  
  它們說的都是同一件事情，A.D 是個 private interface，因此在 NestingInterfaces class 中
  不可以對 A.D 作任何呼叫函式的動作。我有點懷疑 ovo-lucky 會不會沒把 A.D 設為 private。
  
  其實如果經過向下轉型為 A.DImp2 (public class) 再呼叫它的函式，就可以通過編譯，只是這樣
  就不算是多型了。下列兩個指令可這樣修改:
    // Doesn't return anything but A.D:
    //! A.DImp2 di2 = a.getD();
    A.DImp2 di2 = (A.DImp2)a.getD();  // 向下轉型方可通過編譯
    // Cannot access a member of the interface:
    //! a.getD().f();
    ((A.DImp2)a.getD()).f();          // 向下轉型方可通過編譯
</font>感謝：annhy
日期：2003/01/06</pre>

<pre>■p496,L6（誤譯）
原文：...每一個都弱於<font color="#FF0000">後</font>者。
更正：...每一個都弱於<font
color="#0000FF">前</font>者。
感謝：zhaijing
日期：2003/01/06</pre>

<pre>■p346,L11（筆誤）
原文：a &quot;big picture&quot; of class relationsh<font
color="#FF0000">o</font>p
更正：a &quot;big picture&quot; of class relationsh<font
color="#0000FF">i</font>p
感謝：PennyGe
日期：2003/02/18

■p298,L1（版面處理不當）
原文：BlankFinal(int x) { 
更正：<font
color="#408080">該行應該縮排</font>
感謝：wawa
日期：2003/02/18

■p260,L-12（少一個右括弧）
原文：你將仍舊擁有對所有 friendly 成員的一般性「package 存取權限」。
更正：你將仍舊擁有對所有 friendly 成員的一般性「package 存取權限」<font
color="#0000FF">）</font>。
感謝：wawa
日期：2003/02/18

■p266,L-9（誤譯）
原文：class Soup <font
color="#FF0000">的物件是被 Soup 的 static private 成員函式產生出來的，</font>所以恰恰只能有一份。
更正：class Soup <font
color="#0000FF">物件被產生出來當作 Soup 的 static private 資料成員，</font>所以恰恰只能有一份。
感謝：wawa
日期：2003/02/18

■p182,L3,L6（筆誤）
原文：labeld
更正：label<font
color="#0000FF">e</font>d
感謝：wawa
日期：2003/02/18

■p176,L-6（中譯本處理錯誤）
原文：每當 i 不能被 <font
color="#FF0000">10</font> 整除，
更正：每當 i 不能被 <font color="#0000FF">9</font> 整除，
感謝：wawa
日期：2003/02/18

■p92,L4（少一個右引號）
原文：「將程式庫轉換為新的 data types（classes）便是 ...
更正：「將程式庫轉換為新的 data types（classes）<font
color="#0000FF">」</font>便是 ...
感謝：wawa
日期：2003/02/18</pre>

<pre>■p306,L6（筆誤）
原文：至<font color="#FF0000">止</font>，所有必要的 classes 都已被載入，...
更正：至<font
color="#0000FF">此</font>，所有必要的 classes 都已被載入，...
感謝：learn
日期：2003/03/27</pre>

<pre>■p694,表格第三橫項內容（誤譯）
原文：呼叫 Destroy() 之<font
color="#FF0000">後</font>也會呼叫這個函式
更正：呼叫 Destroy() 之<font
color="#0000FF">前</font>也會呼叫這個函式
感謝：jack0zhu
日期：2003/03/27

■p935,L9（英文版筆誤，多了一個右圓括弧）
原文：&quot;ORDER BY FIRST&quot;<font
color="#FF0000">)</font>;
更正：&quot;ORDER BY FIRST&quot;;
感謝：wangrui_xjtu
日期：2003/03/27</pre>

<pre>■p430,L-11（筆誤）
原文：pri<font color="#FF0000">v</font>itives array 和 objects array
更正：pri<font
color="#0000FF">m</font>itive arrays 和 object arrays
感謝：paranonia
日期：2005/01/28</pre>

<pre>-- the end

</pre>
</body>
</html>
