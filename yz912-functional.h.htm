<html>// yz912-functional.h

// 設計一些 functors
// 參考：《STL源碼剖析》p416~p421
// unary_function, binary_function
// plus, minus, multiplies, divides
// equal_to, greater, greater_equal, less, less_equal

// 設計一些 function adapters
// 參考：《STL源碼剖析》8.4 節
// bind2nd, binder2nd


#ifndef _YZ_FUNCTIONAL_
#define _YZ_FUNCTIONAL_

namespace YZ
{

// C++ Standard 規定，每一個 Adaptable Unary Function 都必須繼承此類別
template <class Arg, class Result>
struct unary_function {
    typedef Arg argument_type;
    typedef Result result_type;
};

// C++ Standard 規定，每一個 Adaptable Binary Function 都必須繼承此類別
template <class Arg1, class Arg2, class Result>
struct binary_function {
    typedef Arg1 first_argument_type;
    typedef Arg2 second_argument_type;
    typedef Result result_type;
};      

// 以下6個為算術類（Arithmetic）仿函式
template <class T>
struct plus : public binary_function<T, T, T> {
    T operator()(const T& x, const T& y) const { return x + y; }
};

template <class T>
struct minus : public binary_function<T, T, T> {
    T operator()(const T& x, const T& y) const { return x - y; }
};

template <class T>
struct multiplies : public binary_function<T, T, T> {
    T operator()(const T& x, const T& y) const { return x * y; }
};

template <class T>
struct divides : public binary_function<T, T, T> {
    T operator()(const T& x, const T& y) const { return x / y; }
};

template <class T>
struct modulus : public binary_function<T, T, T> {
    T operator()(const T& x, const T& y) const { return x % y; }
};

template <class T>
struct negate : public unary_function<T, T> {
    T operator()(const T& x) const { return -x; }
};

// 以下6個為相對關係類（Relational）仿函式
template <class T>
struct equal_to : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x == y; }
};

template <class T>
struct not_equal_to : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x != y; }
};

template <class T>
struct greater : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x > y; }
};

template <class T>
struct less : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x < y; }
};

template <class T>
struct greater_equal : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x >= y; }
};

template <class T>
struct less_equal : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x <= y; }
};

// 以下3個為邏輯運算類（Logical）仿函式
template <class T>
struct logical_and : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x && y; }
};

template <class T>
struct logical_or : public binary_function<T, T, bool> {
    bool operator()(const T& x, const T& y) const { return x || y; }
};

template <class T>
struct logical_not : public unary_function<T, bool> {
    bool operator()(const T& x) const { return !x; }
};


// ---- 以上都是 functor，以下都是 function adapter

// 以下配接器用來表示某個 Adaptable Predicate 的邏輯負值（logical negation）
template <class Predicate>
class unary_negate
  : public unary_function<typename Predicate::argument_type, bool> {
protected:
  Predicate pred;
public:
  explicit unary_negate(const Predicate& x) : pred(x) {}
  bool operator()(const typename Predicate::argument_type& x) const {
    return !pred(x);
  }
};

// 輔助函式，使我們得以方便使用 unary_negate<Pred>
template <class Predicate>
inline unary_negate<Predicate> not1(const Predicate& pred) {
  return unary_negate<Predicate>(pred);
}


// 以下配接器用來將某個 Adaptable Binary function 轉換為 Unary Function
template <class Operation> 
class binder2nd
  : public unary_function<typename Operation::first_argument_type,
                               typename Operation::result_type> {
protected:
  Operation op;
  typename Operation::second_argument_type value;
public:
  // 以下 ctor 建立 op 和 value。
  binder2nd(const Operation& x,
            const typename Operation::second_argument_type& y) 
      : op(x), value(y) {}
  typename Operation::result_type
  operator()(const typename Operation::first_argument_type& x) const {
    return op(x, value); 	// 將 value 繫結（binding）為第二引數
                             	// operator() 被呼叫時的引數，將成為op的第一引數 
  }
};

// 輔助函式，讓我們得以方便使用 binder2nd<Op>
// 用法：例如 bind2nd(less<int>(), 5)
template <class Operation, class T>
inline binder2nd<Operation> bind2nd(const Operation& op, const T& x) {
  typedef typename Operation::second_argument_type arg2_type;
  return binder2nd<Operation>(op, arg2_type(x));
          // 以上把x當做op的第二引數型別
          // 語法分析：binder2nd<T>() 是產生一個暫時物件，() 之內是ctor參數。
          // arg2_type() 是強制轉型動作。
}



} // namespace YZ

#endif // _YZ_FUNCTIONAL_

