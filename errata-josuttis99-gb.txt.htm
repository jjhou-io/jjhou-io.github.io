<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=big5">
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
<title>勘誤《C++ 標準程序庫》簡體</title>
</head>

<body>

<pre>本勘誤檔更新日期: 2003/12/30</pre>

<pre>《C++ 標準程序庫》簡體
華中科技大學出版社, 2002/10 出版</pre>

<pre>原著：The C++ Standard Library, 
      by Nicolai M. Josuttis
      Addison Wesley, 1999</pre>

<pre>注意：以下按修正日期排序。</pre>

<pre>======================================================</pre>

<pre>書籍內容更正，有兩種作法，一是在網際網路上做個專屬勘誤
網頁，讓大家上去看。這是比較即時的作法。而更理想更負責
的作法是：不但有勘誤網頁，並且在新刷中予以更正 — 如果
有新刷的話 :)</pre>

<pre>不過，理想與現實之間需要一點協調。書籍的製作是這樣的，
製版與印刷時，是以檯（8 或 16 頁）為單位。因此，每換一
頁，同檯的各頁統統要換過。這便造成印製成本的大量增加。</pre>

<pre>以前，我從不考慮成本，只要我認為書籍內容有修改必要，即
使只是某個字詞用得不甚理想，我都會請出版社更新。出版社
也都全力配合（這一點讓我非常感謝）。</pre>

<pre>慢慢地，我的行事不再這麼霹靂，我覺得我多少也要站在出版
社的立場想想。所以我打算，如果是關係到對錯正誤的根本性
問題，我便一定在新刷修正。如果是易判別的錯別字或排版誤
失或用詞不很恰當…等等，我便先在勘誤網頁上明載，但不求
一定於新刷中更正。直到收集來的這類誤失較為密集了，才一
併於下一刷修正。</pre>

<pre>哪些是新刷已修正的，哪些是暫請讀者自行動手更改的，我會
在勘誤網頁（網址見書封底）上清楚說明。</pre>

<pre>這是個便宜法門，請讀者見諒。</pre>

<pre>書籍應該在出版前就詳細檢查，以完美之姿出現。但是完美很
難達到。對於下列大大小小輕重不等的誤失，我謹向讀者說抱
歉。</pre>

<pre>本檔歡迎廣為流傳，謝謝。</pre>

<pre>以下為更新記錄。如果您購買的是第 n 刷，請將以下第 n+1
刷之後的更新內容自行修正至書上。謝謝</pre>

<pre>======================================================</pre>

<pre>以下暫請讀者自行更正：
（注意，Lm 表示第 m 行，L-n 表示倒數第 n 行）</pre>

<pre>■p6, L5（轉碼失誤）
原文：D<font color="#FF0000">??</font>38108
更正：D<font
color="#0000FF">—</font>38108
感謝：frankliu
日期：2002/08/26</pre>

<pre>■譯序 c, L19（筆誤）
原文：has<font color="#FF0000">t</font> table
更正：has<font
color="#0000FF">h</font> table
感謝：chen jack
日期：2002/10/09</pre>

<pre>■pxx, L-3（重譯）
原文：<font color="#FF0000">但願各位能從這本書獲得樂趣，另外，請保持寬厚。
      （譯註：上句原文為 Have fun and be human!。抱歉，譯者對其精確含義並無十足把握）</font>
更正：<font
color="#0000FF">Have fun and be human!（願各位從本書獲得趣味，並享受身為人類的樂趣）</font>
感謝：Jiang Hong
註  ：以下是 Jiang Hong 來信：
      <font
color="#408080">Be Human 是人工智能領域的特定語義，見：
         http://www.wired.com/wired/archive/3.04/turing.html
      在 TCSL 裡面﹐作者說這話的意思，猜想是「享受身為人類的樂趣」吧。</font>
日期：2002/10/10</pre>

<pre>■以上的另一個討論
<font color="#408080">侯老師﹐請允許我這樣稱呼您~ 我自認為是在您的著作影響下成長起來的一代程序員。
請接受我的敬意
假期裡閱讀了您與孟岩先生合譯的 C++ 標準程序庫一書。受益匪淺 感謝您的辛勤工作。
今天看作品勘誤表的時候﹐又看到了那個 &quot;be human&quot; 的地方 呵呵 就允許我隨便說說
看法吧
在和指針﹐內存﹐不計其數重複繁雜的代碼墳墓中奮鬥了多年以後﹐開始想象對太多人
來說那經歷似乎 &quot;not be human&quot; 呵呵﹐說成 &quot;不人道&quot; 似乎也可:)。俗一點﹐誇張一
點﹐&quot;哪是人干的事情&quot;﹐哈哈。 標準庫很大程度上讓大家從這種低層次的﹐繁複的﹐
某種程度上機械的勞動中解脫出來﹐&quot;be human&quot;. 標準庫對 c++ 語言以及相應編程
風格的巨大影響也在證明這一點。所以我覺得上面那句話的意思（只是 &quot;意思&quot;）在於</font>

<font
color="#0000FF">&quot;願各位（飽受痛苦折磨的程序員們）從中得到樂趣﹐活的真正有點人樣兒&quot;</font>

<font
color="#408080">是一點點輕鬆玩笑的口吻。 也許這也正是語言的差異﹐翻譯的頭痛之處。勘誤表上提的
那個翻譯也可以說的過去了﹐但失之嚴肅﹐不夠有生氣了。
心裡總覺得這點意思不吐不快 呵呵 希望沒耽誤您太多時間 真希望能夠有機會
和您一起做一點事情﹕） 先生下次翻譯書稿的時候希望也能夠盡一點微薄之力
（渴望中）。</font>
侯捷回覆：您的說法十分生動。
          也謝謝您的心意。是的，希望將來有志一同的朋友一起來做點事。
感謝：Yonghang Wang
日期：2003/02/11</pre>

<pre>■p8, L5（拼字錯誤）
原文：Bja<font color="#FF0000">m</font>e Stroustrup
更正：Bja<font
color="#0000FF">rn</font>e Stroustrup
註：我給的原件是正確的，請責任編輯了解原因所在。
感謝：Jiang Hong
日期：2002/10/10

■p23, L-6（中文版處理錯誤，最後少了一個分號）
原文：std::cout &lt;&lt; std::hex &lt;&lt; 3.4 &lt;&lt; std::endl
更正：std::cout &lt;&lt; std::hex &lt;&lt; 3.4 &lt;&lt; std::endl<strong><font
color="#0000FF">;</font></strong>
感謝：Jiang Hong
日期：2002/10/10

■（討論，單複數）
<font
color="#408080">讀者來函：
    TCSL p16「Namespaces 正是用來解決這一問題的」
    為什麼用複數呢﹖
    中文和英文有個區別就在於中文對於複數的模糊性﹐比如「千山萬水」，並無一個修飾
    把山和水變成複數，人們也都明白山不止一座水不止一條。

    像「Namespaces 正是用來解決這一問題的」這句，本來 namespace 可以當作 C++
    的一個關鍵字，在此處不用複數反而提示讀者，用了複數倒有迷惑之效。

    比如這句「不同於 class 的是，namespaces 是開放的」(p17)﹐為什麼不用 classes
    而用單數？

    再如 p82：
    下面是 STL 中預先定義好的關聯容器...
    + Sets
    + Multisets
    + Maps
    + Multimaps
    我不知道 STL 定義了一個 Sets 容器 :)
</font>侯捷回覆：
    感謝您以嚴謹的態度審視這個問題。您所言有某種程度的道理，但恐非絕對。
    對於此種單複數問題，我並不一一推敲。我的翻譯絕大部份以原書英文稿為據；
    原書如何，我便如何。我並不很重視這個問題（如果它真的成為一個問題），
    但還是很感謝您。
感謝：Jiang Hong
日期：2002/10/10</pre>

<pre>■p65, L-5（英文版錯誤）
原文：is_signed(char) : <font color="#FF0000">false</font>
更正：is_signed(char) : <font
color="#0000FF">true</font>
感謝：dirtfei
日期：2002/10/13</pre>

<pre><a name="flaw">■p12, L18,19（簡體中文版處理錯誤）</a>
<font
color="#408080">讀者來函：
  void assign(const MyClass&lt;T&gt;&amp; x) { // x must have same type as *this
  被不當斷行，這樣就破壞了 // 的作用。</font>
侯捷回覆：是的，我發現簡體版改動了我設計的（繁體版）字形，因此出現上述情況。

  特別請讀者注意<font
color="#0000FF">某些不當折行處又進行了縮排</font>，使不當折行的 program comments 
  看來好似一般正常的 program code，例 <font
color="#0000FF">p27,L6</font>：
  正確應為（單行）：throw E2(); // calls unexpected(), which calls terminate()
  簡版誤為（雙行）：throw E2(); // calls unexpected(), which calls
                    terminate()
  錯誤的折行使上述程式看起來好像分別呼叫了 throw E2() 和 terminate()
  （進而又使讀者懷疑是否最後一行少了個分號）</pre>

<pre>  經查此乃簡體版製作過程中的疏失。<font color="#0000FF">不幸中的大幸是僅出現於前三章（1~32頁）</font>
  我謹代表所有工作人員向簡體版讀者致歉。
  我的責任編輯十分優秀負責，必會積極謀求新刷更正之道。</pre>

<pre>以下是目前發現的不當折行處：
  p13, L3,L4
  p12, L18,L19
  p27, L6,L7, L23,L24

彌補：
  請至本書網頁 <a
href="jjtbooks-the-cpp-standard-library.htm" tppabs="http://jjhou.boolan.com/jjtbooks-the-cpp-standard-library.htm" target="main">jjtbooks-the-cpp-standard-library.htm</a>
  下載全書範例源碼，以為基準。
感謝：Jiang Hong
日期：2002/10/13

■e, L1（簡體中文版處理錯誤）
原文：《STL 源碼剖析,The Annoated STL Sources》 by 侯捷,<font
color="#FF0000">眳p</font>,2002。
更正：《STL 源碼剖析,The Annoated STL Sources》 by 侯捷,<font
color="#0000FF">華中科技大學出版社</font>,2002。
感謝：zg_fyx
日期：2002/10/13

■e, L1（筆誤）
原文：《Mod<font
color="#FF0000">re</font>n C++ Design》
更正：《Mod<font color="#0000FF">er</font>n C++ Design》
感謝：zg_fyx
日期：2002/10/13

■21, L-10（簡體中文版處理錯誤）
原文：計算<font
color="#FF0000">器</font>科學家
更正：計算<font color="#0000FF">機</font>科學家
感謝：zg_fyx
日期：2002/10/13

■124, L-7（兩岸術語轉譯）
原文：function object（函數<font
color="#FF0000">物件</font>）
更正：function object（函數<font color="#0000FF">對象</font>）
感謝：zg_fyx
日期：2002/10/13

■130, L4（兩岸術語轉譯）
原文：AddValue <font
color="#FF0000">物件</font>
更正：AddValue <font color="#0000FF">對象</font>
感謝：zg_fyx
日期：2002/10/13

■133, L16（筆誤）
原文：再傳給 transfor()
更正：再傳給 transfor<font
color="#0000FF">m</font>()
感謝：zg_fyx
日期：2002/10/13</pre>

<pre>■區間 [,) 誤為 (1) [,] 或 (2) [;)
出現地點：              錯誤原因
  p99,  L-7,L-11,L-17      (2)
  p100, L11,L18            (2)
  p145, 表6.1（兩處）   (1)(2)
  p150, 表6.2           (1)(2)
  p151, 表6.4           (1)(2)
  p154, 表6.7（兩處）   (1)(2)
  p162, 表6.9           (1)(2)
  p163, 表6.11（兩處）  (1)(2)
  p167, 表6.12          (1)(2)
  p168, 表6.14             (2)
  p170, 表6.17（兩處）  (1)(2)
  p171, 表6.18          (1)(2)
  p177, 表6.20（兩處）  (1)(2)
  p183, 表6.25（兩處）  (1)(2)
  p196, 表6.26（兩處）  (1)(2)
  p202, 表6.31（兩處）  (1)(2)
  p232, L-5                (2)

  p458, L-11            (1)
  p482, 表11.2          (1)(2)
  p483, 表11.4          (1)(2)
  p498, 表11.6（六處）  (1)(2)
  p517, L-2                (2)
  p519, L-6,L-16           (2)
  p520, L5,L12             (2)
  p710, 表14.12         (1)(2)
  p711, L9                 (2)
  p720, L13                (2)
  p730, 表15.2（兩處）  (1)(2)
  p731, L18                (2)
  p740, L-15               (2)
  p742, L4                 (2)
感謝：ark
日期：2002/12/12

■p728,表15.1最後一行（處理錯誤）
原文：回收 p 所指的 <font
color="#FF0000">◎◎◎</font> &quot;可容納...
更正：回收 p 所指的 &quot;可容納...
感謝：ark
日期：2002/12/12

■p739,L16（處理錯誤）
原文：返回一個<font
color="#FF0000"> ◎◎◎</font> &quot;對 allocate() 有意義...
更正：返回一個 &quot;對 allocate() 有意義...
感謝：ark
日期：2002/12/12

■p314,L12（排版錯誤，識別字之中不該出現空格）
  出現地點     原文                 更正
  p314,L12     compose_ f_ gx       compose_f_gx
  p315,L1      compose_ f_ gx       compose_f_gx
  p316,L12     compose_ f_ gx_ hx   compose_f_gx_hx
  p317,L1      compose_ f_ gx_ hx   compose_f_gx_hx
  p318,L-12    compose_ f_ gx_ hy   compose_f_gx_hy
  p319,L13     compose_ f_ gx_ hy   compose_f_gx_hy
感謝：ark
日期：2002/12/12

■p327,表9.5標題（筆誤）
原文：表9.5 變<font
color="#FF0000">動</font>性算法（Mutating Algorithms）
更正：表9.5 變<font
color="#0000FF">序</font>性算法（Mutating Algorithms）
註  ：表9.3 才是變動性算法（Modifying Algorithms）
感謝：ark
日期：2002/12/12

■p460-461（討論 10.4.1 範例 cont/bitset1.cpp）
<font
color="#408080">讀者來函：
  我先後在兩台 PC上 測試，VC6,VC7 沒問題，BCB6 出現 compile time error:
    Error E2021 F:\Program Files\Borland\CBuilder6\Include\stl/_bitset.h 89:
    Array must have at least one element in function
    bitset&lt;6&gt;::reference::reference(bitset&lt;6&gt; &amp;,unsigned int)
    *** 1 errors in Compile ***

  另外，p64 的 util/limits1.cpp 範例也是在 VC6,VC7 沒問題，BCB6 出現
  runtime error（詳見 TCPPSL Errata Update 20021025 -- from Ark）。
  後來有人告知我 BCB5 沒問題。
</font>侯捷回覆：
  的確，各家編譯器所支援的標準程序庫，與真正的標準相比，或多或少都還有點距離。
  謝謝你告訴大家你的經驗。你真是個實事求是的人。
感謝：ark
日期：2002/12/12

■7.5.1節 p286（討論與更正）
<font
color="#408080">讀者來函：
  7.5.1節 p286 講述了運用迭代器類型的兩個步驟﹐其中第 2 步原文為：
    Step 2. Implement that other function for any iterator category
    that provides a special implementation that is not derived from
    another iterator category.
  譯文為﹕
    2. 針對不同的迭代器類型實作出上述所調用的函數。
    只有「並非派生自其他迭代器類型」的迭代器類型，才需要提供特化版本。

  疑問如下：

  參見文中針對第 2 步所舉例子：

    //foo() for bidirectional iterators
    template &lt;class BiIterator&gt;
    void foo (BiIterator beg, BiIterator end,
              std::bidirectional_iterator_tag)
    {  ...  }

    //foo() for random access iterators
    template &lt;class RaIterator&gt;
    void foo (RaIterator beg, RaIterator end,
              std::random_access_iterator_tag)
    {  ...  }

  其中的
    bidirectional_iterator_tag 不是派生自 forward_iterator_tag 嗎？
    random_access_iterator_tag 不是派生自 bidirectional_iterator_tag 嗎？

  我的看法：

  [Implement] [that other function] [for any iterator category]
  意思是：為某些特定的 iterator category 實現那個函數。

  [that provides a special implementation]
  用來修飾 any iterator category。
  哪些特定的 iterator category 呢？就是意欲提供 special implementation 的那些。
  為何要提供這些 special implementation 呢？因為：

  [that is not derived from another iterator category.]
  用來進一步修飾 special implementation，意思是說：
  對於這種 iterator category，我們無法經由（利用）階層體系獲得
  「針對這種 iterator category 的 foo() 所需要的操作」。

  參見文中 distance() 實作後面的敘述，即 7.5.1 最後一段話（p288），
  意思是說，第二個版本 distance() 使用 input iterator，
  而這對 forward-iterator 和 bidirectional-iterator 都有效。
  這是因為 forward-iterator 和 bidirectional-iterator 可利用階層關係
  使我們可以使用該函數版本，
  而且對於 forward-iterator 和 bidirectional-iterator 和 input-iterator
  這三種 iterator categories，所需操作都是一樣的，
  forward-iterator 和 bidirectional-iterator 並不需要比 input-iterator
  更多的「特別操作」，因而也就不需要特別針對 forward-iterator
  和 bidirectional-iterator 實作 distance()。

  綜上所述，第 2 步的含義或許是：

  1) 為一些特定的 iterator category 實作出那個函數；
  2) 我們意欲使這個函數版本能夠針對這些特定的 iterator category
     做出特殊的操作，特別是：
  3) 這些特殊的操作之所以說是「特殊」﹐是因為其無法利用 iterator category
     階層關係由一個「iterator category 更通用」的函數實作版本提供。

  上述理解恐貽笑大方。還請不吝賜教! 謝謝!
  oops! 這段話真的很難譯!

</font><font
color="#000000">侯捷回覆：你的理解非常好，斷句也很正確。日後必有重託於你 :)
          這麼繁複的句子，代表作者原先寫得就不好。以技術角度重譯如下：
</font>
原文：2. 針對不同的迭代器類型實作出上述所調用的函數。
      <font
color="#FF0000">只有「並非派生自其它迭代器類型」的迭代器類型，才需要提供特化版本。</font>
更正：2. 針對不同的迭代器類型實作出上述所調用的函數。
      <font
color="#0000FF">注意，如果迭代器類型 B 為 D 之基類（見 p284 上方之迭代器類型繼承體系
      （iterator category hierarchy）），而此處所談函數針對 B,D 之實作並無
      不同，那麼只需針對 B 實作即可。</font>
感謝：ark
日期：2002/12/12

■p285,L-15（筆誤）
原文：iterator typs
更正：iterator typ<font
color="#0000FF">e</font>s
感謝：ark
日期：2002/12/12

■p255-p281（術語轉換失誤，未將「算式」(expression) 轉為「表達式」）
出現地點：
  p255,表7.5
  p256,表7.6
  p272,表7.7
  p278,表7.9
  p281,表7.10
感謝：ark
日期：2002/12/12

■p224,L-7,L-8（處理失誤）
原文：same order in coll1 <font
color="#FF0000">coll1</font>
      same order in coll2 <font color="#FF0000">coll2</font>
更正：same order in coll1
      same order in coll2
感謝：ark
日期：2002/12/12

■p153,L-2 (轉碼失誤)
原文：那<font
color="#FF0000">ㄠ</font>該容器身上的
更正：那<font color="#0000FF">麼</font>該容器身上的
感謝：ark
日期：2002/12/12

■p59,L-1 / p60,L1 (不當折行）
更正：該行應採用<strong>非等距字體</strong>（如繁體版），請編輯於新刷時注意
感謝：ark
日期：2002/12/12

■p47,L5（auto_ptrs 中的 's' 與慣用排版字體不符）
更正：請編輯於新刷時注意
感謝：ark
日期：2002/12/12

■p50, L-4（簡體版遺漏兩個字）
原文：C++ 標準規格，
更正：C++ 標準規格<font
color="#0000FF">宣稱</font>，
感謝：ark
日期：2002/12/12

■p64 util/limits1.cpp 範例（討論）
<font
color="#408080">讀者來函：
  以下是我對於 p64 util/limits1.cpp 範例運行情況
  我的環境是：WinXP/PIII733/256Mb，環境變量為 vs.net 和 bcb6 缺省安裝設置

  VC7[o], BCB6[x]

  BCB6 運行到 p65,L6 這一行時：
    cout &lt;&lt; &quot;max(long double):  &quot;
         &lt;&lt; numeric_limits&lt;long double&gt;::max() &lt;&lt; endl;
  彈出以下訊息：
    Debugger Exception Notification
    Project Project1.exe raised exception class EOverflow with message 'Floating
    point overflow'. Process stopped. Use Step or Run to continue.

  [VC7 場合]
  在 VC7 中，numeric_limits&lt;long double&gt;::max() 以 return LDBL_MAX; 返回，
  而 float.h 中定義有：
    #define DBL_MAX   1.7976931348623158e+308  /* max value */
    #define LDBL_MAX  DBL_MAX                  /* max value */

  [bcb6 場合]
  在BCB6中，numeric_limits&lt;long double&gt;::max() 也以 return LDBL_MAX; 返回，
  而 float.h 中定義有：
    #define LDBL_MAX    std::_max_ldble
    extern long double  _RTLENTRY _EXPDATA _max_ldble;
</font>
感謝：ark
日期：2002/12/12

■p31,L-1, p32,L1（簡體版斷行錯誤）
更正：編輯請注意：本頁最後一行與下一頁第一行是同一個段落。
感謝：ark
日期：2002/12/12

■p15最下，註6（討論和更正）
<font
color="#408080">讀者來函：
  英文版為﹕
    Exceptions end a call of the function, where you find the exception, with
    the ability to pass an object as argument back to the caller. However, this
    is not a function call back in the opposite direction (from the bottom where
    the problem was found to the top where the problem is solved or handled).
    You can't process the exception and continue from where you found the
    exception. In this regard, exception handling is completely different from
    signal handling.
  其中
    You can't process the exception and continue from where you found the exception.
  一句似乎未有譯出？這一句對於區分 exception 與 call back 而言似乎是
  比較重要的強調。
</font>
侯捷回覆：
  是的，補譯如下。謝謝。

原文：也就是從下往上的方向。以此觀之...
更正：也就是從下往上的方向。<font
color="#0000FF">你無法在處理異常完畢後回到異常發生之處。</font>以此觀之...
感謝：ark
日期：2002/12/12

■p15,L14（術語轉換）
原文：<font
color="#FF0000">述</font>句 throw 開始了 stack unwinding...
更正：<font
color="#0000FF">語</font>句 throw 開始了 stack unwinding...
感謝：cuttloefish
日期：2002/12/12

■p100,L18（英文版錯誤）
原文：if(pos35 != <font
color="#FF0000">pos25</font>)
更正：if(pos35 != <font color="#0000FF">coll.end()</font>)
感謝：bai_fft
日期：2002/12/12

■p413,L14（譯者處理錯誤）
原文：<font
color="#FF0000">lower</font>_bound() 返回第一個...
更正：<font color="#0000FF">upper</font>_bound() 返回第一個...
感謝：lenger81
日期：2002/12/12

■p311,L12（討論）
<font
color="#408080">讀者來函：此處之 std::pow 似應去除 std::
</font>孟岩回覆：
  若含入 &lt;cmath&gt;，pow 會被置於 namespace std 中。讀者可能使用 VC，
  發現不加 std:: 也可通過。這是因為 VC 所帶的 Dinkum STL 為了方便使用者，
  擅自將 pow 引出到 anonymous namespace 中，所以不寫 std:: 也可以。
  （寫了 std:: 反而在 VC6 中編譯不了）。正確作法還是 std::pow。
感謝：jhz0366
日期：2002/12/12

■p558,p559（兩頁的頁碼正確、內容正確，但卻左右倒置了）
更正：請責任編輯於新刷製版時對調這兩頁。
感謝：myan
日期：2002/12/12

■p61,L-1 and p62（讀者補充）
<font
color="#408080">讀者來函：
  Signaling NaN﹕A NaN that geneally raises an exception when encountered as
  an operand of arithmetic operations is called a signaling NaN.

  normalize 和 denormalize：在浮點表示法中，常常把定點部份標定在一個範圍內，
  同時調整指數部份，這個過程叫做規格化（normalize）。
  比如 123.45 * 10^2 經過規格化後變為：1.2345 * 10^4。
  denormalize（反規格化）和這個過程相反。

  像 char、int 等類型根本就沒有 (de)normalzation 可言，
  因此 numeric_limits&lt;long int&gt;::has_denorm 肯定是 0。

  trap 是處理器的一個運算標誌，允許捕獲計算中出現的異常。對整數類型而言，
  numeric_limits&lt;T&gt;::traps 為 0。

  tinyness_before 所作的是檢查一個數值是否太小以至於在舍/入之前無法對其規格化。
</font>
侯捷回覆：我們遇上了一位專家 :) 謝謝您。
提示：本書將 &quot;normalize&quot; 譯為 &quot;標準化&quot;，即上述的 &quot;規格化&quot;。
感謝：Jiang Hong
日期：2002/12/12

■p306,表8-2,L2（處理錯誤）
原文：bind2nd(op, value)    op(<font
color="#FF0000">value, param</font>)
更正：bind2nd(op, value)    op(<font
color="#0000FF">param, value</font>)
感謝：Jiang Hong
日期：2002/12/12

■p199,表6-29,表頭（處理錯誤）
原文：Maps 和 Multimaps 的賦值（<font
color="#FF0000">賦值</font>）操作
更正：Maps 和 Multimaps 的賦值（<font
color="#0000FF">assignment</font>）操作
感謝：Jiang Hong
日期：2002/12/12

■p222,L7（術語一致，使與 p300,L-8 相同）
原文：reference counting（<font
color="#FF0000">參考</font>計數）
更正：reference counting（<font color="#0000FF">引用</font>計數）
感謝：Jiang Hong
日期：2002/12/12

■p305,L-3（筆誤）
原文：早期的 STL 版本中，乘法仿函數名為 time。
更正：早期的 STL 版本中，乘法仿函數名為 time<font
color="#0000FF">s</font>。
感謝：Jiang Hong
日期：2002/12/12

■p386,L14（筆誤）
原文：C++ 關鍵字 mutable 的<font
color="#FF0000">意義</font>意思是...
更正：C++ 關鍵字 mutable 的意思是...
感謝：Jiang Hong
日期：2002/12/12

■p687,L10,L11,L12; p722,L9（術語轉換）
原文：<font
color="#FF0000">脫</font>字符（escape character）
更正：<font color="#0000FF">轉義</font>字符（escape character）
補充：&quot;escape character&quot; 在臺灣並無一定譯名。我慣用「逸脫字元」，本書亦如是。
      簡體版轉為「脫字符」，始料未及。大陸慣用「轉義字符」我覺得很好，
      今後我的繁體版書籍也將採用「轉義字元」一詞。
感謝：Jiang Hong
日期：2002/12/12</pre>

<pre>■p207,L4（譯本處理錯誤）
原文：它會安插一個鍵值為 &quot;otto&quot; 的新元素
更正：它會安插一個鍵值為 &quot;ott<strong><font
color="#0000FF">t</font></strong>o&quot; 的新元素
感謝：cuttloefish
日期：2003/01/20

■p611,L4（譯本處理錯誤）
原文：另有兩個用以改變寫入位置的函數：tell<font
color="#FF0000">g</font>() 和 seek<font color="#FF0000">g</font>()，
更正：另有兩個用以改變寫入位置的函數：tell<font
color="#0000FF">p</font>() 和 seek<font color="#0000FF">p</font>()，
感謝：cuttloefish
日期：2003/01/20

■p615,L-8（譯本處理錯誤，遺漏了一個 '|'）
原文：二元操作符 &quot;or&quot;（也就是 operator）
更正：二元操作符 &quot;or&quot;（也就是 operator <font
color="#0000FF">|</font>）
感謝：cuttloefish
日期：2003/01/20

■p625,表13.28第二橫行（譯本處理錯誤）
原文：<font
color="#FF0000">no</font>unitbuf
更正：unitbuf
感謝：cuttloefish
日期：2003/01/20</pre>

<pre>■p625,L-9（筆誤）
原文：每次寫出後均清空（f<font color="#FF0000">r</font>ush）緩衝區
更正：每次寫出後均清空（f<font
color="#0000FF">l</font>ush）緩衝區
感謝：cuttloefish
日期：2003/01/20

■p169,L-3（術語轉換失誤）
原文：因為它們只進行內部<font
color="#FF0000">指目標</font>操作
更正：因為它們只進行內部<font
color="#0000FF">指針</font>操作
感謝：cuttloefish
日期：2003/01/20

■p172,L-6（處理錯誤）
原文：它便保證 &quot;要嘛<font
color="#FF0000">不</font>成功，要嘛無任何作用&quot;
更正：它便保證 &quot;要嘛成功，要嘛無任何作用&quot;
感謝：cuttloefish
日期：2003/01/20

■p236,L-5（漏置）
原文：vectors、deques、lists、sets、multisets、maps 和 multimaps 都支持
更正：vectors、deques、lists、sets、multisets、maps、multimaps <font
color="#0000FF">和 strings </font>都支持
感謝：cuttloefish
日期：2003/01/20

■p272,L4（處理錯誤）
原文：類似情況，遞增運操作符
更正：類似情況，遞增運<font
color="#0000FF">算</font>操作符
感謝：cuttloefish
日期：2003/01/20

■p274,L12（處理錯誤）
原文：由於 push_<font
color="#FF0000">back</font>() 只在 deques 和 lists 中有所實現
更正：由於 push_<font
color="#0000FF">front</font>() 只在 deques 和 lists 中有所實現
感謝：cuttloefish
日期：2003/01/20

■p319,L-15（誤譯）
原文：在一個字符串中以 &quot;<font
color="#FF0000">區</font>分大小寫&quot; 的方式
更正：在一個字符串中以 &quot;<font
color="#0000FF">不</font>分大小寫&quot; 的方式
感謝：cuttloefish
日期：2003/01/20

■討論
<font
color="#408080">討論1：
p307 和 p309 兩個關於mem_fun_ref和mem_fun的程序不能通過編譯﹐我後來到網站上下載了
源代碼﹐同樣不能通過編譯﹐我用的是vc++ 6.0。錯誤類型是這樣的﹕
e:\cr999\vc++\ddd\memfun1.cpp(40) : error C2664: 
  'mem_fun_ref' : cannot convert parameter 1 from 'void (__thiscall Person::*)(void) const' to 
  'void (__thiscall Person::*)(void)'
請問先生﹐這究竟是什麼問題。</font>

侯捷回覆：
此程式可在其他編譯器（例如 BCB5）通常。所以討論 VC6 的錯誤就沒有意義了。
請注意：測試 C++ Standard Library，一定要準備多個不同的編譯器。

<font
color="#408080">討論2：
p283,L10﹐coutPos = *cinPos++ 就能很好地工作了﹐為什麼寫成 *coutPos++ = *cinPos++ ?</font>

侯捷回覆：
的確如你所言。我不知道為什麼作者要寫成那樣。
想知道為什麼你說的兩種寫法會導致一樣的動作（效果），必須理解其源碼。
《STL源碼剖析》p446 顯示，ostream_iterator 的 operator*(), operator++(), operator++(int)
都傳回 *this，因此上述兩種寫法結果相同。</pre>

<pre>檢閱你的這個問題時，我深入再思考了一下，並就此做出一些整理。</pre>

<pre>c:\&gt; advance2.exe &lt;Enter&gt;   // 註：執行程式
<font color="#0000FF">a b c d e f g h i</font> &lt;Enter&gt;   // 註：這是輸入
<font
color="#FF0000">c f </font>&lt;Enter&gt;                 // 註：這是輸出。程式尚未結束。鍵入一個 &lt;Enter&gt;，產生換行效果
<font
color="#0000FF">1 2 3 4 5 6 7 8 9</font> &lt;Enter&gt;   // 註：繼續輸入
<font
color="#FF0000">i 3 6</font> &lt;Ctrl-z&gt;&lt;Enter&gt;       // 註：這是輸出。再以 &lt;Ctrl-z&gt;&lt;Enter&gt; 模擬 end-of-stream 
9                           // 註：這是最後輸出 

請問，為什麼第一次輸出 <font
color="#FF0000">c f</font>，沒有 <font color="#FF0000">i</font>？為什麼第二次輸出 <font
color="#FF0000">i 3 6</font>？</pre>

<pre>如果徹底了解 iostream iterator 的行為（那一定必須看其源碼），就不會糊塗了。
以下細部分解。首先看書上的 main()，我在述句之後加了編號以利講解 :
int main()
{
    istream_iterator&lt;string&gt; cinPos(cin);		// (1)
    ostream_iterator&lt;string&gt; coutPos(cout,&quot; &quot;);		// (2)

    /* while input is not at the end of the file	
     * - write every third string
     */
    while (cinPos != istream_iterator&lt;string&gt;()) {	// (3)
        // ignore the following two strings
        advance (cinPos, 2);				// (4)

        // read and write the third string
        if (cinPos != istream_iterator&lt;string&gt;()) {	// (5)
            *coutPos++ = *cinPos++;			// (6)
            // 侯捷註：相當於 coutPos = *(cinPos++);    // (7)
        }
    }
    cout &lt;&lt; endl;
}</pre>

<pre>式1 生成一個 istream_iterator&lt;stream&gt; 時，cin 開始作用。此時輸入的
<font
color="#0000FF">a b c d e f g h i</font> &lt;Enter&gt; 
全部被吃進緩衝區之中。由於 stream 的 &quot;token&quot;（語彙單元）是以 space or tab or enter 為界，
所以此時讀入一個 'a'，邏輯上可想像 cinPos 現在指向 'a'。而後式3 成立，所以執行式4。
advance()的動作（ref.《STL源碼剖析》p95）在面對 input_iterator_tag 時，是執行 ++iter。
因此讀入兩個 string，也就是 'b' 和 'c'。此時邏輯上可想像 cinPos 指向 'c'。接下來式5 成立，
因此執行式6（式7 會比較清楚些），先對 cinPos 執行 postfix increment，而後
對其 return value 取值（提領）。所謂 postfix increment 意指 &quot;fetch and then increment&quot;，
所以先 return cinPos 再 ++cinPos。分析如下：
(a)：return cinPos（但實際上需待 (b) 完成之後再傳回）
(b)：++cinPos 造成讀入一個元素 'd'，邏輯上想像 cinPos 現在指向 'd'。
(c)：(a) 的結果被取值（提領）後輸出到 cout，因此螢幕上出現 'c'。
回到 while loop，再執行式4,5,6。於是 cinPos 指向 'g'，輸出 'f'。 
回到 while loop，
執行式4，於是 cinPos 指向 'i'；
執行式5，通過；
執行式6，於是重複上述(a),(b),(c)：
(a)：return cinPos（但實際上需待 (b) 完成之後再傳回）
(b)：++cinPos 造成要求讀入一個元素，於是程式停下來等待新的輸入...
這就是為什麼螢幕上輸出 <font
color="#FF0000">c f </font>的原因。

接下來鍵入 &lt;Enter&gt;，這對 cin 輸入沒有意義。
接下來鍵入<font
color="#0000FF"> 1 2 3 4 5 6 7 8 9</font>，於是程式接續剛才未完動作...
因此後來才又輸出 <font
color="#FF0000">i 3 6</font>。
最後：
(1) 以 Ctrl-C 強迫結束
(2) 以「輸入格式錯誤」（例如應輸入數值卻輸入文字）造成 stream status error 而結束程式 
(3) 鍵入 &lt;Ctrl-z&gt;&lt;Enter&gt;，模擬 end-of-stream 而結束程式。</pre>

<pre>情況皆不相同。(1) 是程式不正常結束，(2) 是程式正常結束。
(3) 亦是程式正常結束，並最後輸出 9。
註：在 Linux 之下可按 &lt;Ctrl-D&gt; 模擬 end-of-stream。

感謝：Chen Ru；以及 Solstice 對 end-of-stream 按鍵的補充。
日期：2003/02/19</pre>

<pre>■討論
<font color="#408080">讀者來函：
侯老師：您好！我是您在東軟上課時的學生，做第一排的那個大腦袋：）
請教您一個問題,我在 VC 和 linux下的gcc都做了，gcc上沒有出現問題，
vc中的 iostream 與 iostream.h 中 cout 析構過程是怎樣的呢

程式一：
</font><font
color="#FF0000">#include&lt;iostream&gt;</font><font color="#408080">
class display {
public:
 display() {
  std::cout &lt;&lt; &quot;Initialize&quot; &lt;&lt; '\n';
 }
 ~display() {
  std::cout &lt;&lt; &quot;Clean up&quot; &lt;&lt; '\n';
 }
};

display print;

void main(){
 std::cout &lt;&lt; &quot;Hello,world!&quot; &lt;&lt; '\n';
}

在vc6.0中執行這個代碼,怎麼只輸出:
Initialize
Hello,world!
 

程式二：
</font><font
color="#FF0000">#include&lt;iostream.h&gt;</font><font color="#408080">
class display {
public:
 display() {
  cout &lt;&lt; &quot;Initialize&quot; &lt;&lt; '\n';
 }
 ~display() {
  cout &lt;&lt; &quot;Clean up&quot; &lt;&lt; '\n';
 }
};

display print;
void main(){
  cout &lt;&lt; &quot;Hello,world!&quot; &lt;&lt; '\n';
}

這樣的程序是可以順利執行的啊（在VC6.0下）輸出:
Initialize
Hello,world!
Clean up

為什麼我執行兩個程序會是這樣兩種結果呢？謝謝！</font>

侯捷回覆：
這顯示 VC6 之中有 bug。不必花精神去探究別人的 bug — 除非它有點意思。
但這個 bug 一點意思也沒有。我個人的態度是這樣 :)

感謝：zhanglt 
日期：2003/02/28</pre>

<pre>■p202,表6.31第4欄（英文版錯誤）
原文：c.erase(<font color="#FF0000">elem</font>)   移除 &quot;<font
color="#FF0000">實值（value）</font>與 <font color="#FF0000">elem</font> 相等&quot; 的所有元素...
更正：c.erase(<font
color="#0000FF">x</font>)      移除 &quot;<font color="#0000FF">鍵值（key）</font>等於 <font
color="#0000FF">x</font>&quot; 的所有元素...
感謝：XuChunMing
日期：2003/12/30</pre>

<pre>-- the end</pre>
</body>
</html>
